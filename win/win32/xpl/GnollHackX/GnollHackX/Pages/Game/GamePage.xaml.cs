using SkiaSharp;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Reflection;
using System.IO;
using System.Diagnostics;
using System.Collections.ObjectModel;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using System.Net.Http;
using Newtonsoft.Json;
using System.Net.Http.Headers;
using System.Collections;
using System.Data;
using System.Xml.Linq;

#if GNH_MAUI
using GnollHackX;
using Microsoft.Maui.Controls.PlatformConfiguration;
using Microsoft.Maui.Controls.PlatformConfiguration.iOSSpecific;
using Microsoft.Maui.Controls.PlatformConfiguration.AndroidSpecific;
using SkiaSharp.Views.Maui;
using SkiaSharp.Views.Maui.Controls;
using Microsoft.Maui.Controls;
using System.Security.AccessControl;



#if WINDOWS
using Windows.UI.Core;
using Windows.System;
using GnollHackM.Platforms.Windows;
using GnollHackM.WinUI;
#endif

namespace GnollHackM
#else
using Xamarin.Forms;
using Xamarin.Forms.Xaml;
using Xamarin.Essentials;
using GnollHackX.Controls;
using Xamarin.Forms.PlatformConfiguration;
using Xamarin.Forms.PlatformConfiguration.iOSSpecific;
using Xamarin.Forms.PlatformConfiguration.AndroidSpecific;
using SkiaSharp.Views.Forms;
using static Xamarin.Essentials.Permissions;
using Xamarin.Forms.PlatformConfiguration.TizenSpecific;

namespace GnollHackX.Pages.Game
#endif
{
    [XamlCompilation(XamlCompilationOptions.Compile)]
    public partial class GamePage : ContentPage
    {
        private struct MenuClickResult
        {
            public bool OkClicked;
            public int MenuItemClickIndex;
            public long ItemIdentifier;
            public MenuClickResult(bool okClicked, int menuItemClickIndex, long itemIdentifier)
            {
                OkClicked = okClicked;
                MenuItemClickIndex = menuItemClickIndex;
                ItemIdentifier = itemIdentifier;
            }
        };

        private readonly object _canvasButtonLock = new object();
        private SKRect _canvasButtonRect = new SKRect(0, 0, 0, 0);

        private SKColor _cursorDefaultGreen = new SKColor(0, 255, 0);

        private int _isGameOn = 0;
        private int _gameEnded = 0;
        private int _fastForwardRequested = 0;
        public bool IsGameOn { get { return Interlocked.CompareExchange(ref _isGameOn, 0, 0) != 0; } set { Interlocked.Exchange(ref _isGameOn, value ? 1 : 0); } }
        public bool GameEnded { get { return Interlocked.CompareExchange(ref _gameEnded, 0, 0) != 0; } set { Interlocked.Exchange(ref _gameEnded, value ? 1 : 0); } }
        public bool FastForwardRequested { get { return Interlocked.CompareExchange(ref _fastForwardRequested, 0, 0) != 0; } set { Interlocked.Exchange(ref _fastForwardRequested, value ? 1 : 0); } }

        private int _isMainCanvasOn = 0;
        private int _isMainCanvasDrawing = 0;
        public bool IsMainCanvasOn 
        { 
            get
            {
                return Interlocked.CompareExchange(ref _isMainCanvasOn, 0, 0) != 0;
            } 
            set 
            {
                Interlocked.Exchange(ref _isMainCanvasOn, value ? 1 : 0);
                Interlocked.Exchange(ref _updateTimerTickCount, 0L);
            } 
        }
        public bool IsMainCanvasDrawing { get { return Interlocked.CompareExchange(ref _isMainCanvasDrawing, 0, 0) != 0; } set { Interlocked.Exchange(ref _isMainCanvasDrawing, value ? 1 : 0); } }
        public bool IsMainCanvasDrawingAndSetTrue 
        { 
            get 
            { 
                return Interlocked.Exchange(ref _isMainCanvasDrawing, 1) != 0;
            }
        }

        private readonly string _fontSizeString = "FontS";
        private int _refreshMsgHistoryRowCounts = 1;
        private bool RefreshMsgHistoryRowCounts { get { return Interlocked.CompareExchange(ref _refreshMsgHistoryRowCounts, 0, 0) != 0; } set { Interlocked.Exchange(ref _refreshMsgHistoryRowCounts, value ? 1 : 0); } }

        public List<string> ExtendedCommands { get; set; }

        private readonly IGnollHackService _gnollHackService;
        private bool _isFirstAppearance = true;

        private MapData[,] _mapData = new MapData[GHConstants.MapCols, GHConstants.MapRows];
        private Dictionary<SavedDarkenedBitmap, SKImage> _darkenedBitmaps = new Dictionary<SavedDarkenedBitmap, SKImage>();
        private Dictionary<SavedDarkenedAutodrawBitmap, SKImage> _darkenedAutodrawBitmaps = new Dictionary<SavedDarkenedAutodrawBitmap, SKImage>();

        private readonly object _uLock = new object();
        private int _ux = 0;
        private int _uy = 0;
        private int[] _statusmarkorder = { (int)game_ui_status_mark_types.STATUS_MARK_TOWNGUARD_PEACEFUL, (int)game_ui_status_mark_types.STATUS_MARK_TOWNGUARD_HOSTILE, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21 };
        public string[] _condition_names = new string[(int)bl_conditions.NUM_BL_CONDITIONS] {
            "Petrifying",
            "Slimed",
            "Being strangled",
            "Suffocating",
            "Food poisoned",
            "Terminally ill",
            "Blind",
            "Deaf",
            "Stun",
            "Confused",
            "Hallucinating",
            "Levitating",
            "Flying",
            "Riding",
            "Slowed",
            "Paralyzed",
            "Frightened",
            "Sleeping",
            "Cancelled",
            "Silenced",
            "Grabbed",
            "Mummy rot",
            "Lycanthropy",
            "Wounded legs",
        };

        public string[] _status_names = new string[(int)game_ui_status_mark_types.MAX_STATUS_MARKS] {
            "Pet",
            "Peaceful",
            "Detected",
            "Bounty",
            "Satiated",
            "Hungry",
            "Weak",
            "Fainting",
            "Burdened",
            "Stressed",
            "Strained",
            "Overtaxed",
            "Overloaded",
            "Two-weapon fighting",
            "Skill available",
            "Saddled",
            "Low hit points",
            "Critical hit points",
            "Cooldown",
            "Trapped",
            "Grabber",
            "Carrying object",
            "Peaceful townguard",
            "Hostile townguard",
        };

        private SKPoint[] _hoverAnimation = new SKPoint[]
        {
            new SKPoint(1f, 2f),
            new SKPoint(1.5f, 1.75f),
            new SKPoint(2f, 1.5f),
            new SKPoint(2.5f, 1.25f),
            new SKPoint(3f, 1f),
            new SKPoint(3.5f, 0.75f),
            new SKPoint(4f, 0.5f),
            new SKPoint(4.25f, 0.25f),
            new SKPoint(4.5f, 0f),
            new SKPoint(4.25f, 0.25f),
            new SKPoint(4f, 0.5f),
            new SKPoint(3.5f, 0.75f),
            new SKPoint(3f, 1f),
            new SKPoint(2.5f, 1.25f),
            new SKPoint(2f, 1.5f),
            new SKPoint(1.5f, 1.75f),
            new SKPoint(1f, 2f),
            new SKPoint(0.5f, 2.25f),
            new SKPoint(0f, 2.5f),
            new SKPoint(-0.5f, 2.25f),
            new SKPoint(-1f, 2f),
            new SKPoint(-1.5f, 1.75f),
            new SKPoint(-2f, 1.5f),
            new SKPoint(-2.5f, 1.25f),
            new SKPoint(-3f, 1f),
            new SKPoint(-3.5f, 0.75f),
            new SKPoint(-4f, 0.5f),
            new SKPoint(-4.25f, 0.25f),
            new SKPoint(-4.5f, 0f),
            new SKPoint(-4.25f, 0.25f),
            new SKPoint(-4f, 0.5f),
            new SKPoint(-3.5f, 0.75f),
            new SKPoint(-3f, 1f),
            new SKPoint(-2.5f, 1.25f),
            new SKPoint(-2f, 1.5f),
            new SKPoint(-1.5f, 1.75f),
            new SKPoint(-1f, 2f),
            new SKPoint(-0.5f, 2.25f),
            new SKPoint(0f, 2.5f),
        };

        private SKPoint[] _flyingAnimation = new SKPoint[]
        {
            new SKPoint(0f, 0f),
            new SKPoint(0f, 0.1f),
            new SKPoint(0f, 0.25f),
            new SKPoint(0f, 0.5f),
            new SKPoint(0f, 1f),
            new SKPoint(0f, 1.5f),
            new SKPoint(0f, 2f),
            new SKPoint(0f, 2.5f),
            new SKPoint(0f, 3f),
            new SKPoint(0f, 3.5f),
            new SKPoint(0f, 4f),
            new SKPoint(0f, 4.5f),
            new SKPoint(0f, 4.75f),
            new SKPoint(0f, 4.9f),
            new SKPoint(0f, 5f),
            new SKPoint(0f, 4.9f),
            new SKPoint(0f, 4.75f),
            new SKPoint(0f, 4.5f),
            new SKPoint(0f, 4f),
            new SKPoint(0f, 3.5f),
            new SKPoint(0f, 3f),
            new SKPoint(0f, 2.5f),
            new SKPoint(0f, 2f),
            new SKPoint(0f, 1.5f),
            new SKPoint(0f, 1f),
            new SKPoint(0f, 0.5f),
            new SKPoint(0f, 0.25f),
            new SKPoint(0f, 0.1f),
        };

        private SKPoint[] _blobAnimation = new SKPoint[]
        {
            new SKPoint(1.00000f, 0.9800f),
            new SKPoint(0.99625f, 0.9820f),
            new SKPoint(0.99250f, 0.9840f),
            new SKPoint(0.98500f, 0.9860f),
            new SKPoint(0.97750f, 0.9880f),
            new SKPoint(0.97000f, 0.9900f),
            new SKPoint(0.96250f, 0.9920f),
            new SKPoint(0.95500f, 0.9940f),
            new SKPoint(0.94750f, 0.9960f),
            new SKPoint(0.94000f, 0.9970f),
            new SKPoint(0.93250f, 0.9980f),
            new SKPoint(0.92875f, 0.9990f),
            new SKPoint(0.92688f, 0.9995f),
            new SKPoint(0.92500f, 1.0000f),
            new SKPoint(0.92688f, 0.9995f),
            new SKPoint(0.92875f, 0.9990f),
            new SKPoint(0.93250f, 0.9980f),
            new SKPoint(0.94000f, 0.9970f),
            new SKPoint(0.94750f, 0.9960f),
            new SKPoint(0.95500f, 0.9940f),
            new SKPoint(0.96250f, 0.9920f),
            new SKPoint(0.97000f, 0.9900f),
            new SKPoint(0.97750f, 0.9880f),
            new SKPoint(0.98500f, 0.9860f),
            new SKPoint(0.99250f, 0.9840f),
            new SKPoint(0.99625f, 0.9820f),
            new SKPoint(1.00000f, 0.9800f),
        };

        private SKPoint[] _swimAnimation = new SKPoint[]
        {
            new SKPoint(0f, -0f),
            new SKPoint(0f, -0.1f),
            new SKPoint(0f, -0.2f),
            new SKPoint(0f, -0.4f),
            new SKPoint(0f, -0.6f),
            new SKPoint(0f, -0.8f),
            new SKPoint(0f, -1f),
            new SKPoint(0f, -1.2f),
            new SKPoint(0f, -1.4f),
            new SKPoint(0f, -1.6f),
            new SKPoint(0f, -1.8f),
            new SKPoint(0f, -2f),
            new SKPoint(0f, -2.2f),
            new SKPoint(0f, -2.4f),
            new SKPoint(0f, -2.6f),
            new SKPoint(0f, -2.8f),
            new SKPoint(0f, -2.9f),
            new SKPoint(0f, -3f),
            new SKPoint(0f, -2.9f),
            new SKPoint(0f, -2.8f),
            new SKPoint(0f, -2.6f),
            new SKPoint(0f, -2.4f),
            new SKPoint(0f, -2.2f),
            new SKPoint(0f, -2f),
            new SKPoint(0f, -1.8f),
            new SKPoint(0f, -1.6f),
            new SKPoint(0f, -1.4f),
            new SKPoint(0f, -1.2f),
            new SKPoint(0f, -1.0f),
            new SKPoint(0f, -0.8f),
            new SKPoint(0f, -0.6f),
            new SKPoint(0f, -0.4f),
            new SKPoint(0f, -0.2f),
            new SKPoint(0f, -0.1f),
            new SKPoint(0f, 0f),
        };

        private SKPoint[] _sharkAnimation = new SKPoint[]
        {
            new SKPoint(0f, 0f),
            new SKPoint(0f, 0.1f),
            new SKPoint(0f, 0.25f),
            new SKPoint(0f, 0.5f),
            new SKPoint(0f, 1f),
            new SKPoint(0f, 1.5f),
            new SKPoint(0f, 2f),
            new SKPoint(0f, 2.5f),
            new SKPoint(0f, 3f),
            new SKPoint(0f, 3.5f),
            new SKPoint(0f, 4f),
            new SKPoint(0f, 4.5f),
            new SKPoint(0f, 4.75f),
            new SKPoint(0f, 4.9f),
            new SKPoint(0f, 5f),
            new SKPoint(0f, 4.9f),
            new SKPoint(0f, 4.75f),
            new SKPoint(0f, 4.5f),
            new SKPoint(0f, 4f),
            new SKPoint(0f, 3.5f),
            new SKPoint(0f, 3f),
            new SKPoint(0f, 2.5f),
            new SKPoint(0f, 2f),
            new SKPoint(0f, 1.5f),
            new SKPoint(0f, 1f),
            new SKPoint(0f, 0.5f),
            new SKPoint(0f, 0.25f),
            new SKPoint(0f, 0.1f),
        };

        private SKPoint[] _humanBreatheAnimation = new SKPoint[]
        {
            new SKPoint(0.99000f, 1.000f),
            new SKPoint(0.99025f, 0.9995f),
            new SKPoint(0.99050f, 0.9990f),
            new SKPoint(0.99100f, 0.9980f),
            new SKPoint(0.99200f, 0.9960f),
            new SKPoint(0.99300f, 0.9940f),
            new SKPoint(0.99400f, 0.9920f),
            new SKPoint(0.99500f, 0.9900f),
            new SKPoint(0.99600f, 0.9880f),
            new SKPoint(0.99700f, 0.9860f),
            new SKPoint(0.99800f, 0.9840f),
            new SKPoint(0.99900f, 0.9820f),
            new SKPoint(0.99950f, 0.9810f),
            new SKPoint(0.99975f, 0.9805f),
            new SKPoint(1.00000f, 0.9800f),
            new SKPoint(1.00000f, 0.9800f),
            new SKPoint(0.99975f, 0.9805f),
            new SKPoint(0.99950f, 0.9810f),
            new SKPoint(0.99900f, 0.9820f),
            new SKPoint(0.99800f, 0.9840f),
            new SKPoint(0.99700f, 0.9860f),
            new SKPoint(0.99600f, 0.9880f),
            new SKPoint(0.99500f, 0.9900f),
            new SKPoint(0.99400f, 0.9920f),
            new SKPoint(0.99300f, 0.9940f),
            new SKPoint(0.99200f, 0.9960f),
            new SKPoint(0.99100f, 0.9980f),
            new SKPoint(0.99050f, 0.9990f),
            new SKPoint(0.99025f, 0.9995f),
        };

        private SKPoint[] _animalBreatheAnimation = new SKPoint[]
        {
            new SKPoint(1.0000f, 0.9800f),
            new SKPoint(0.9995f, 0.9805f),
            new SKPoint(0.9990f, 0.9810f),
            new SKPoint(0.9980f, 0.9820f),
            new SKPoint(0.9960f, 0.9840f),
            new SKPoint(0.9940f, 0.9860f),
            new SKPoint(0.9920f, 0.9880f),
            new SKPoint(0.9900f, 0.9900f),
            new SKPoint(0.9880f, 0.9920f),
            new SKPoint(0.9860f, 0.9940f),
            new SKPoint(0.9840f, 0.9960f),
            new SKPoint(0.9820f, 0.9980f),
            new SKPoint(0.9810f, 0.9990f),
            new SKPoint(0.9805f, 0.9995f),
            new SKPoint(0.9800f, 1.0000f),
            new SKPoint(0.9800f, 1.0000f),
            new SKPoint(0.9805f, 0.9995f),
            new SKPoint(0.9810f, 0.9990f),
            new SKPoint(0.9820f, 0.9980f),
            new SKPoint(0.9840f, 0.9960f),
            new SKPoint(0.9860f, 0.9940f),
            new SKPoint(0.9880f, 0.9920f),
            new SKPoint(0.9900f, 0.9900f),
            new SKPoint(0.9920f, 0.9880f),
            new SKPoint(0.9940f, 0.9860f),
            new SKPoint(0.9960f, 0.9840f),
            new SKPoint(0.9980f, 0.9820f),
            new SKPoint(0.9990f, 0.9810f),
            new SKPoint(0.9995f, 0.9805f),
            new SKPoint(1.0000f, 0.9800f),
        };

        private int _isSizeAllocatedProcessed = 0;
        public bool IsSizeAllocatedProcessed { get { return Interlocked.CompareExchange(ref _isSizeAllocatedProcessed, 0, 0) != 0; } set { Interlocked.Exchange(ref _isSizeAllocatedProcessed, value ? 1 : 0); } }

        private int _forceAscii = 0;
        public bool ForceAscii { get { return Interlocked.CompareExchange(ref _forceAscii, 0, 0) != 0; } set { Interlocked.Exchange(ref _forceAscii, value ? 1 : 0); } }

        private int _forceAllMessages = 0;
        public bool ForceAllMessages
        {
            get 
            {
                return Interlocked.CompareExchange(ref _forceAllMessages, 0, 0) != 0;
            }
            set
            {
                Interlocked.Exchange(ref _forceAllMessages, value ? 1 : 0);
                MessageFilterFrame.IsVisible = LongerMessageHistory && value;
                if (!MessageFilterFrame.IsVisible)
                    MessageFilterEntry.Unfocus();
                MessageFilterEntry.IsEnabled = MessageFilterFrame.IsVisible;
                if (MessageFilterEntry.Text != "")
                {
                    MessageFilterEntry.Text = "";
                    UpdateMessageFilter();
                }
                else
                    RefreshMsgHistoryRowCounts = true;
            }
        }        

        public bool HasAllMessagesTransparentBackground { get; set; } = true;

        private int _showExtendedStatusBar = 0;
        public bool ShowExtendedStatusBar { get { return Interlocked.CompareExchange(ref _showExtendedStatusBar, 0, 0) != 0; } set { Interlocked.Exchange(ref _showExtendedStatusBar, value ? 1 : 0); } }

        private int _lighterDarkening = 0;
        private int _lighterDarkeningUpdated = 0;
        public bool LighterDarkening
        {
            get { return Interlocked.CompareExchange(ref _lighterDarkening, 0, 0) != 0; }
            set
            {
                if (Interlocked.Exchange(ref _lighterDarkening, value ? 1 : 0) != (value ? 1 : 0)) // Original value was different
                    Interlocked.Exchange(ref _lighterDarkeningUpdated, 1);
            }
        }

        private int _drawWallEnds = 0;
        public bool DrawWallEnds { get { return Interlocked.CompareExchange(ref _drawWallEnds, 0, 0) != 0; } set { Interlocked.Exchange(ref _drawWallEnds, value ? 1 : 0); } }

        private int _breatheAnimations = 0;
        public bool BreatheAnimations { get { return Interlocked.CompareExchange(ref _breatheAnimations, 0, 0) != 0; } set { Interlocked.Exchange(ref _breatheAnimations, value ? 1 : 0); } }

        int _longerMessageHistory = 0;
        public bool LongerMessageHistory
        {
            get
            {
                return Interlocked.CompareExchange(ref _longerMessageHistory, 0, 0) != 0;
            }
            set
            {
                Interlocked.Exchange(ref _longerMessageHistory, value ? 1 : 0);
                MessageFilterFrame.IsVisible = value && ForceAllMessages;
                if (!MessageFilterFrame.IsVisible)
                    MessageFilterEntry.Unfocus();
                MessageFilterEntry.IsEnabled = MessageFilterFrame.IsVisible;
                if (MessageFilterEntry.Text != "")
                {
                    MessageFilterEntry.Text = "";
                    UpdateMessageFilter();
                }
                else
                    RefreshMsgHistoryRowCounts = true;

                GHGame curGame = GHApp.CurrentGHGame;
                curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.UseLongerMessageHistory, value));
            }
        }

        int _hideMessageHistory = 0;
        public bool HideMessageHistory
        {
            get
            {
                return Interlocked.CompareExchange(ref _hideMessageHistory, 0, 0) != 0;
            }
            set
            {
                Interlocked.Exchange(ref _hideMessageHistory, value ? 1 : 0);
                RefreshMsgHistoryRowCounts = true;

                GHGame curGame = GHApp.CurrentGHGame;
                curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.UseHideMessageHistory, value));
            }
        }

        private int _alternativeLayerDrawing = 0;
        public bool AlternativeLayerDrawing { get { return Interlocked.CompareExchange(ref _alternativeLayerDrawing, 0, 0) != 0; } set { Interlocked.Exchange(ref _alternativeLayerDrawing, value ? 1 : 0); } }

        private int _refreshScreen = 1;
        public bool RefreshScreen { get { return Interlocked.CompareExchange(ref _refreshScreen, 0, 0) != 0; } set { Interlocked.Exchange(ref _refreshScreen, value ? 1 : 0); } }

        private game_cursor_types _cursorType;
        private bool _force_paint_at_cursor;
        private bool _show_cursor_on_u;

        private ObjectData[,] _objectData = new ObjectData[GHConstants.MapCols, GHConstants.MapRows];
        private ObjectDataItem _uChain = null;
        private ObjectDataItem _uBall = null;

        private bool _drawWeaponStyleAsGlyphs = true;

        public SimpleImageButton StandardMeasurementButton { get { return ESCButton; } } // UseSimpleCmdLayout ? SimpleESCButton : ESCButton
        public MeasurableGrid StandardMeasurementCmdLayout { get { return StoneButtonGrid; } } // UseSimpleCmdLayout ? SimpleUpperCmdLayout : UpperCmdLayout;
        public LabeledImageButton StandardReferenceButton { get { return UseSimpleCmdLayout ? lSimpleInventoryButton : lInventoryButton; } } // { get { return DesktopButtons ? lRowAbilitiesButton : lAbilitiesButton; } }
        public MeasurableStackLayout UsedButtonRowStack { get { return UseSimpleCmdLayout ? SimpleButtonRowStack : ButtonRowStack; } }

        private int _shownMessageRows = GHConstants.DefaultMessageRows;
        private int _shownPetRows = GHConstants.DefaultPetRows;
        private int _gridOpacity = 0;
        private readonly object _styleLock = new object();
        private TTYCursorStyle _cursorStyle;
        private GHGraphicsStyle _graphicsStyle;
        private MapRefreshRateStyle _mapRefreshRate = MapRefreshRateStyle.MapFPS60;

        public int NumDisplayedMessages { get { return Interlocked.CompareExchange(ref _shownMessageRows, 0, 0); } set { Interlocked.Exchange(ref _shownMessageRows, value); } }
        public int ActualDisplayedMessages { get { return ForceAllMessages ? (LongerMessageHistory ? GHConstants.MaxLongerMessageHistoryLength : GHConstants.AllMessageRows) : NumDisplayedMessages; } }
        public int NumDisplayedPetRows { get { return Interlocked.CompareExchange(ref _shownPetRows, 0, 0); } set { Interlocked.Exchange(ref _shownPetRows, value); } }
        public int GridOpacity { get { return Interlocked.CompareExchange(ref _gridOpacity, 0, 0); } set { Interlocked.Exchange(ref _gridOpacity, value); } }

        public TTYCursorStyle CursorStyle { get { lock (_styleLock) { return _cursorStyle; } } set { lock (_styleLock) { _cursorStyle = value; } } }
        public GHGraphicsStyle GraphicsStyle { get { lock (_styleLock) { return _graphicsStyle; } } set { lock (_styleLock) { _graphicsStyle = value; } } }
        public MapRefreshRateStyle MapRefreshRate
        {
            get
            {
                lock (_styleLock) { return _mapRefreshRate; }
            }
            set
            {
                lock (_styleLock)
                {
                    if (_mapRefreshRate == value)
                        return;

                    _mapRefreshRate = value;
                }
                StopMainCanvasAnimation();
                if (!LoadingGrid.ThreadSafeIsVisible)
                    StartMainCanvasAnimation();
            }
        }

        private int _useMainMipMap = 0;
        public bool UseMainMipMap
        {
            get 
            {
                return Interlocked.CompareExchange(ref _useMainMipMap, 0, 0) != 0;
            }
            set 
            { 
                Interlocked.Exchange(ref _useMainMipMap, value ? 1 : 0);
            }
        }

        public bool UseMainGLCanvas
        {
            get { return MainCanvasView.UseGL; }
            set { MainCanvasView.UseGL = value; }
        }

        public bool UseAuxiliaryGLCanvas
        {
            get { return CommandCanvas.UseGL; }
            set
            {
                /* SKGLView is non-transparent on Windows */
                CommandCanvas.UseGL = value;
#if !WINDOWS
                MenuCanvas.UseGL = value;
                TextCanvas.UseGL = value;
#endif
            }
        }

        private int _useSimpleCmdLayout = GHConstants.DefaultSimpleCmdLayout ? 1 : 0;
        public bool UseSimpleCmdLayout
        {
            get 
            {
                return Interlocked.CompareExchange(ref _useSimpleCmdLayout, 0, 0) != 0;
            }
            set
            {
                Interlocked.Exchange(ref _useSimpleCmdLayout, value ? 1 : 0);
                ButtonRowStack.IsVisible = !value;
                SimpleButtonRowStack.IsVisible = value;
            }
        }

        private int _showAltZoomButton;
        public bool ShowAltZoomButton { get { return Interlocked.CompareExchange(ref _showAltZoomButton, 0, 0) != 0; } set { Interlocked.Exchange(ref _showAltZoomButton, value ? 1 : 0); } }
        private int _showTravelModeButton;
        public bool ShowTravelModeButton { get { return Interlocked.CompareExchange(ref _showTravelModeButton, 0, 0) != 0; } set { Interlocked.Exchange(ref _showTravelModeButton, value ? 1 : 0); } }
        private int _showAutoDigButton;
        public bool ShowAutoDigButton { get { return Interlocked.CompareExchange(ref _showAutoDigButton, 0, 0) != 0; } set { Interlocked.Exchange(ref _showAutoDigButton, value ? 1 : 0); } }

        private int _showIgnoreButton;
        public bool ShowIgnoreStoppingButton { get { return Interlocked.CompareExchange(ref _showIgnoreButton, 0, 0) != 0; } set { Interlocked.Exchange(ref _showIgnoreButton, value ? 1 : 0); } }

        private int _showBattery;
        public bool ShowBattery { get { return Interlocked.CompareExchange(ref _showBattery, 0, 0) != 0; } set { Interlocked.Exchange(ref _showBattery, value ? 1 : 0); } }

        private int _showFPS;
        public bool ShowFPS { get { return Interlocked.CompareExchange(ref _showFPS, 0, 0) != 0; } set { Interlocked.Exchange(ref _showFPS, value ? 1 : 0); } }

        private int _showMemory;
        private long _memUsage = 0;
        public bool ShowMemory { get { return Interlocked.CompareExchange(ref _showMemory, 0, 0) != 0; } set { Interlocked.Exchange(ref _showMemory, value ? 1 : 0); } }

        private int _showZoom;
        public bool ShowZoom { get { return Interlocked.CompareExchange(ref _showZoom, 0, 0) != 0; } set { Interlocked.Exchange(ref _showZoom, value ? 1 : 0); } }

        private int _showRecording = 1;
        public bool ShowRecording { get { return Interlocked.CompareExchange(ref _showRecording, 0, 0) != 0; } set { Interlocked.Exchange(ref _showRecording, value ? 1 : 0); } }

        private double _fps;
        private double FPS { get { return Interlocked.CompareExchange(ref _fps, 0.0, 0.0); } set { Interlocked.Exchange(ref _fps, value); } }

        private long _previousMainFPSCounterValue = 0L;
        private long _previousCommandFPSCounterValue = 0L;

        private Stopwatch _stopWatch = new Stopwatch();
        private Stopwatch _mapUpdateStopWatch = new Stopwatch();

        private int _mapGrid = 0;
        public bool MapGrid { get { return Interlocked.CompareExchange(ref _mapGrid, 0, 0) != 0; } set { Interlocked.Exchange(ref _mapGrid, value ? 1 : 0); } }

        private int _hitPointBars = 0;
        public bool HitPointBars { get { return Interlocked.CompareExchange(ref _hitPointBars, 0, 0) != 0; } set { Interlocked.Exchange(ref _hitPointBars, value ? 1 : 0); } }

        private int _showOrbs = 1;
        public bool ShowOrbs { get { return Interlocked.CompareExchange(ref _showOrbs, 0, 0) != 0; } set { Interlocked.Exchange(ref _showOrbs, value ? 1 : 0); } }
        private int _showMaxHealthInOrb = 0;
        public bool ShowMaxHealthInOrb { get { return Interlocked.CompareExchange(ref _showMaxHealthInOrb, 0, 0) != 0; } set { Interlocked.Exchange(ref _showMaxHealthInOrb, value ? 1 : 0); } }
        private int _showMaxManaInOrb = 0;
        public bool ShowMaxManaInOrb { get { return Interlocked.CompareExchange(ref _showMaxManaInOrb, 0, 0) != 0; } set { Interlocked.Exchange(ref _showMaxManaInOrb, value ? 1 : 0); } }

        private int _playerMark = 0;
        public bool PlayerMark { get { return Interlocked.CompareExchange(ref _playerMark, 0, 0) != 0; } set { Interlocked.Exchange(ref _playerMark, value ? 1 : 0); } }

        private int _monsterTargeting = 0;
        public bool MonsterTargeting { get { return Interlocked.CompareExchange(ref _monsterTargeting, 0, 0) != 0; } set { Interlocked.Exchange(ref _monsterTargeting, value ? 1 : 0); } }

        private int _walkArrows = 0;
        public bool WalkArrows { get { return Interlocked.CompareExchange(ref _walkArrows, 0, 0) != 0; } set { Interlocked.Exchange(ref _walkArrows, value ? 1 : 0); } }

        private int _classicStatusBar = 0;
        public bool ClassicStatusBar { get { return Interlocked.CompareExchange(ref _classicStatusBar, 0, 0) != 0; } set { Interlocked.Exchange(ref _classicStatusBar, value ? 1 : 0); } }

        private int _desktopStatusBar = 0;
        private int _desktopButtons = 0;
        private int _showScore = 0;
        private int _showXP = 0;
        private int _rightAligned2ndRow = 0;
        private int _menuFadeEffects = 0;
        private int _menuHighFilterQuality = 0;
        private int _menuHighlightedKeys = 0;
        public bool DesktopStatusBar { get { return Interlocked.CompareExchange(ref _desktopStatusBar, 0, 0) != 0; } set { Interlocked.Exchange(ref _desktopStatusBar, value ? 1 : 0); } }
        public bool DesktopButtons
        {
            get 
            {
                return Interlocked.CompareExchange(ref _desktopButtons, 0, 0) != 0;
            }
            set
            {
                int usedValue = value ? 1 : 0;
                bool changed = Interlocked.Exchange(ref _desktopButtons, usedValue) != usedValue;
                if (changed)
                {
                    UpdateAbilityButtonVisibility(value);
                    UpdateButtonAndUISizes();
                }
            }
        }
        public bool MenuFadeEffects { get { return Interlocked.CompareExchange(ref _menuFadeEffects, 0, 0) != 0; } set { Interlocked.Exchange(ref _menuFadeEffects, value ? 1 : 0); } }
        public bool MenuHighFilterQuality { get { return Interlocked.CompareExchange(ref _menuHighFilterQuality, 0, 0) != 0; } set { Interlocked.Exchange(ref _menuHighFilterQuality, value ? 1 : 0); } }
        public bool MenuHighlightedKeys { get { return Interlocked.CompareExchange(ref _menuHighlightedKeys, 0, 0) != 0; } set { Interlocked.Exchange(ref _menuHighlightedKeys, value ? 1 : 0); } }
        public bool ShowScore { get { return Interlocked.CompareExchange(ref _showScore, 0, 0) != 0; } set { Interlocked.Exchange(ref _showScore, value ? 1 : 0); } }
        public bool ShowXP { get { return Interlocked.CompareExchange(ref _showXP, 0, 0) != 0; } set { Interlocked.Exchange(ref _showXP, value ? 1 : 0); } }
        public bool RightAligned2ndRow { get { return Interlocked.CompareExchange(ref _rightAligned2ndRow, 0, 0) != 0; } set { Interlocked.Exchange(ref _rightAligned2ndRow, value ? 1 : 0); } }

        private int _showPets = 0;
        public bool ShowPets { get { return Interlocked.CompareExchange(ref _showPets, 0, 0) != 0; } set { Interlocked.Exchange(ref _showPets, value ? 1 : 0); } }

        private int _cursorIsOn = 0;
        public bool CursorIsOn 
        { 
            get { return Interlocked.CompareExchange(ref _cursorIsOn, 0, 0) != 0; }
            set { Interlocked.Exchange(ref _cursorIsOn, value ? 1 : 0); }
        }

        private int _showDirections = 0;
        private bool ShowDirections { get { return Interlocked.CompareExchange(ref _showDirections, 0, 0) != 0; } set { Interlocked.Exchange(ref _showDirections, value ? 1 : 0); } }

        private int _showNumberPad = 0;
        private bool ShowNumberPad { get { return Interlocked.CompareExchange(ref _showNumberPad, 0, 0) != 0; } set { Interlocked.Exchange(ref _showNumberPad, value ? 1 : 0); } }

        private MainPage _mainPage;


        /* Persistent temporary bitmap */
        SKBitmap _tempBitmap = new SKBitmap(GHConstants.TileWidth, GHConstants.TileHeight, SKImageInfo.PlatformColorType, SKAlphaType.Unpremul);

        //private readonly object _skillRectLock = new object();
        //private SKRect _skillRect = new SKRect();
        //public SKRect SkillRect { get { lock (_skillRectLock) { return _skillRect; } } set { lock (_skillRectLock) { _skillRect = value; } } }

        //private readonly object _prevWepRectLock = new object();
        //private SKRect _prevWepRect = new SKRect();
        //public SKRect PrevWepRect { get { lock (_prevWepRectLock) { return _prevWepRect; } } set { lock (_prevWepRectLock) { _prevWepRect = value; } } }

        //private readonly object _healthRectLock = new object();
        //private SKRect _healthRect = new SKRect();
        //public SKRect HealthRect { get { lock (_healthRectLock) { return _healthRect; } } set { lock (_healthRectLock) { _healthRect = value; } } }

        //private readonly object _manaRectLock = new object();
        //private SKRect _manaRect = new SKRect();
        //public SKRect ManaRect { get { lock (_manaRectLock) { return _manaRect; } } set { lock (_manaRectLock) { _manaRect = value; } } }

        //private readonly object _statusBarRectLock = new object();
        //private SKRect _statusBarRect = new SKRect();
        //public SKRect StatusBarRect { get { lock (_statusBarRectLock) { return _statusBarRect; } } set { lock (_statusBarRectLock) { _statusBarRect = value; } } }
        //private readonly object _youRectLock = new object();
        //private SKRect _youRect = new SKRect();
        //public SKRect YouRect { get { lock (_youRectLock) { return _youRect; } } set { lock (_youRectLock) { _youRect = value; } } }

        private float _originMapOffsetWithNewClipX;
        private float _originMapOffsetWithNewClipY;
        private bool _targetClipOn;
        private long _targetClipStartCounterValue;
        private long _targetClipPanTime;

        private int _clipX;
        private int _clipY;
        private readonly object _clipLock = new object();

        private int _mapNoClipMode = 0;
        public bool MapNoClipMode { get { return Interlocked.CompareExchange(ref _mapNoClipMode, 0, 0) != 0; } set { Interlocked.Exchange(ref _mapNoClipMode, value ? 1 : 0); } }

        private int _mapLookMode = 0;
        public bool MapLookMode { get { return Interlocked.CompareExchange(ref _mapLookMode, 0, 0) != 0; } set { Interlocked.Exchange(ref _mapLookMode, value ? 1 : 0); } }

        private bool _savedMapTravelMode = false;
        private bool _savedMapTravelModeOnLevel = false;
        private int _mapTravelMode = 0;
        public bool MapTravelMode { get { return Interlocked.CompareExchange(ref _mapTravelMode, 0, 0) != 0; } set { Interlocked.Exchange(ref _mapTravelMode, value ? 1 : 0); } }
        public bool MapWalkMode { get { return (!MapTravelMode && !MapLookMode); } }
        private int _mapIgnoreMode = 0;
        public bool MapIgnoreMode { get { return Interlocked.CompareExchange(ref _mapIgnoreMode, 0, 0) != 0; } set { Interlocked.Exchange(ref _mapIgnoreMode, value ? 1 : 0); } }
        private int _mapAutoDig = 0;
        public bool MapAutoDig { get { return Interlocked.CompareExchange(ref _mapAutoDig, 0, 0) != 0; } set { Interlocked.Exchange(ref _mapAutoDig, value ? 1 : 0); } }

        private int _mapMiniMode = 0;
        public bool ZoomMiniMode { get { return Interlocked.CompareExchange(ref _mapMiniMode, 0, 0) != 0; } set { Interlocked.Exchange(ref _mapMiniMode, value ? 1 : 0); } }

        private int _mapAlternateMode = 0;
        public bool ZoomAlternateMode { get { return Interlocked.CompareExchange(ref _mapAlternateMode, 0, 0) != 0; } set { Interlocked.Exchange(ref _mapAlternateMode, value ? 1 : 0); } }

        private float _defaultMapFontSize = GHConstants.MapFontDefaultSize;
        private float _mapFontSize = GHConstants.MapFontDefaultSize;
        private float _mapFontAlternateSize = GHConstants.MapFontDefaultSize * GHConstants.MapFontRelativeAlternateSize;
        private float _mapFontMiniRelativeSize = 1.0f;
        private int _mapFontShowPercentageDecimal = 0;

        public float DefaultMapFontSize { get { return Interlocked.CompareExchange(ref _defaultMapFontSize, 0.0f, 0.0f); } set { Interlocked.Exchange(ref _defaultMapFontSize, value); } }
        public float MapFontSize { get { return Interlocked.CompareExchange(ref _mapFontSize, 0.0f, 0.0f); } set { Interlocked.Exchange(ref _mapFontSize, value); } }
        public float MapFontAlternateSize { get { return Interlocked.CompareExchange(ref _mapFontAlternateSize, 0.0f, 0.0f); } set { Interlocked.Exchange(ref _mapFontAlternateSize, value); } }
        public float MapFontMiniRelativeSize { get { return Interlocked.CompareExchange(ref _mapFontMiniRelativeSize, 0.0f, 0.0f); } set { Interlocked.Exchange(ref _mapFontMiniRelativeSize, value); } }
        public bool MapFontShowPercentageDecimal { get { return Interlocked.CompareExchange(ref _mapFontShowPercentageDecimal, 0, 0) != 0; } set { Interlocked.Exchange(ref _mapFontShowPercentageDecimal, value ? 1 : 0); } }

        private readonly object _tileSizeLock = new object();
        private float _usedTileWidth;
        private float _usedTileHeight;
        private float _mapWidth;
        private float _mapHeight;

        private float _mapFontAscent = 0.0f;
        private float UsedMapFontAscent { get { return Interlocked.CompareExchange(ref _mapFontAscent, 0.0f, 0.0f); } set { Interlocked.Exchange(ref _mapFontAscent, value); } }
        public SKImage[] TileMap { get { return GHApp._tileMap; } }

        public readonly object _floatingTextLock = new object();
        public readonly List<GHFloatingText> _floatingTexts = new List<GHFloatingText>();
        public readonly object _screenTextLock = new object();
        public GHScreenText _screenText = null;
        public readonly object _conditionTextLock = new object();
        public readonly List<GHConditionText> _conditionTexts = new List<GHConditionText>();
        public readonly object _screenFilterLock = new object();
        public readonly List<GHScreenFilter> _screenFilters = new List<GHScreenFilter>();
        public readonly object _guiEffectLock = new object();
        public readonly List<GHGUIEffect> _guiEffects = new List<GHGUIEffect>();

        private int _enableWizardMode = 0;
        public bool EnableWizardMode { get { return Interlocked.CompareExchange(ref _enableWizardMode, 0, 0) != 0; } set { Interlocked.Exchange(ref _enableWizardMode, value ? 1 : 0); } }

        private int _enableCasualMode = 0;
        public bool EnableCasualMode { get { return Interlocked.CompareExchange(ref _enableCasualMode, 0, 0) != 0; } set { Interlocked.Exchange(ref _enableCasualMode, value ? 1 : 0); } }

        private int _enableModernMode = 0;
        public bool EnableModernMode { get { return Interlocked.CompareExchange(ref _enableModernMode, 0, 0) != 0; } set { Interlocked.Exchange(ref _enableModernMode, value ? 1 : 0); } }

        public void SetPrimaryCanvasResourceCacheLimit(long cacheLimit)
        {
            Debug.WriteLine("Primary: ResourceCacheSize was " + MainCanvasView.ResourceCacheLimit);
            MainCanvasView.ResourceCacheLimit = cacheLimit;
            Debug.WriteLine("Primary: ResourceCacheSize is " + MainCanvasView.ResourceCacheLimit);
        }

        public void SetSecondaryCanvasResourceCacheLimit(long cacheLimit)
        {
            Debug.WriteLine("Secondary: ResourceCacheSize was " + MenuCanvas.ResourceCacheLimit);
            MenuCanvas.ResourceCacheLimit = cacheLimit;
            TextCanvas.ResourceCacheLimit = cacheLimit;
            CommandCanvas.ResourceCacheLimit = cacheLimit;
            Debug.WriteLine("Secondary: ResourceCacheSize is " + MenuCanvas.ResourceCacheLimit);
        }

        public CacheUsageInfo GetPrimaryCanvasResourceCacheUsage()
        {
            return MainCanvasView.ResourceCacheUsage;
        }

        protected override bool OnBackButtonPressed()
        {
            return true;  
        }

        public GamePage(MainPage mainPage)
        {
            InitializeComponent();
            On<iOS>().SetUseSafeArea(true);
            UIUtils.AdjustRootLayout(RootGrid);
            UIUtils.SetPageThemeOnHandler(this, GHApp.DarkMode);
            UIUtils.SetViewCursorOnHandler(RootGrid, GameCursorType.Normal);
            UIUtils.SetViewCursorOnHandler(ToggleMessageNumberButton, GameCursorType.Info);
            SizeChanged += GamePage_SizeChanged;
            PropertyChanged += GamePage_PropertyChanged;

            _mainPage = mainPage;
            _gnollHackService = GHApp.GnollHackService;

            for (int i = 0; i < GHConstants.NUM_BUFF_BIT_ULONGS; i++)
                _local_u_buff_bits[i] = 0;

            //lock (_mapDataLock)
            //{
            for (int i = 0; i < GHConstants.MapCols; i++)
                {
                    for (int j = 0; j < GHConstants.MapRows; j++)
                    {
                        _mapData[i, j] = new MapData();
                        _mapData[i, j].Glyph = GHApp.UnexploredGlyph;
                        _mapData[i, j].BkGlyph = GHApp.NoGlyph;
                        _mapData[i, j].NeedsUpdate = true;

                        _objectData[i, j] = new ObjectData();
                    }
                }
            //}
            SetLayerDrawOrder();

            int mapRefreshValue = Preferences.Get("MapRefreshRate", -1);
            MapRefreshRate = mapRefreshValue < 0 ? UIUtils.GetDefaultMapFPS() : (MapRefreshRateStyle)mapRefreshValue;
            CursorStyle = (TTYCursorStyle)Preferences.Get("CursorStyle", 1);
            GraphicsStyle = (GHGraphicsStyle)Preferences.Get("GraphicsStyle", 1);
            ShowFPS = Preferences.Get("ShowFPS", false);
            ShowBattery = Preferences.Get("ShowBattery", false);
            ShowZoom = Preferences.Get("ShowZoom", false);
            ShowRecording = Preferences.Get("ShowRecording", true);
            UseMainMipMap = Preferences.Get("UseMainMipMap", GHApp.IsUseMainMipMapDefault);
            UseMainGLCanvas = Preferences.Get("UseMainGLCanvas", GHApp.IsUseMainGPUDefault);
            UseAuxiliaryGLCanvas = Preferences.Get("UseAuxiliaryGLCanvas", GHApp.IsUseAuxGPUDefault);
            bool simpleCmdLayout = Preferences.Get("UseSimpleCmdLayout", GHConstants.DefaultSimpleCmdLayout);
            UseSimpleCmdLayout = simpleCmdLayout;
            ShowAltZoomButton = Preferences.Get("ShowAltZoomButton", !simpleCmdLayout);
            ShowTravelModeButton = Preferences.Get("ShowTravelModeButton", !simpleCmdLayout);
            ShowAutoDigButton = Preferences.Get("ShowAutoDigButton", false);
            ShowIgnoreStoppingButton = Preferences.Get("ShowIgnoreStoppingButton", false);
            ShowMemory = Preferences.Get("ShowMemory", false);
            MapGrid = Preferences.Get("MapGrid", false);
            GridOpacity = Preferences.Get("GridOpacity", 0);
            HitPointBars = Preferences.Get("HitPointBars", false);
            ClassicStatusBar = Preferences.Get("ClassicStatusBar", GHConstants.IsDefaultStatusBarClassic);
            DesktopStatusBar = Preferences.Get("DesktopStatusBar", GHApp.IsDesktop);
            ShowScore = Preferences.Get("ShowScore", GHApp.IsDesktop);
            ShowXP = Preferences.Get("ShowXP", GHApp.IsDesktop);
            RightAligned2ndRow = Preferences.Get("RightAligned2ndRow", false);
            MenuFadeEffects = !GHApp.IsWindows && Preferences.Get("MenuFadeEffects", GHConstants.AreMenuFadeEffectsDefault);
            MenuHighFilterQuality = Preferences.Get("MenuHighFilterQuality", GHApp.IsMenuHighFilterQualityDefault);
            MenuHighlightedKeys = Preferences.Get("MenuHighlightedKeys", GHApp.IsMenuHighlightedKeysDefault);
            ShowOrbs = Preferences.Get("ShowOrbs", true);
            ShowMaxHealthInOrb = Preferences.Get("ShowMaxHealthInOrb", false);
            ShowMaxManaInOrb = Preferences.Get("ShowMaxManaInOrb", false);
            ShowPets = Preferences.Get("ShowPets", true);
            PlayerMark = Preferences.Get("PlayerMark", false);
            MonsterTargeting = Preferences.Get("MonsterTargeting", false);
            NumDisplayedMessages = Preferences.Get("NumDisplayedMessages", GHConstants.DefaultMessageRows);
            NumDisplayedPetRows = Preferences.Get("NumDisplayedPetRows", GHConstants.DefaultPetRows);
            WalkArrows = Preferences.Get("WalkArrows", true);
            LighterDarkening = Preferences.Get("LighterDarkening", GHConstants.DefaultLighterDarkening);
            DrawWallEnds = Preferences.Get("DrawWallEnds", GHConstants.DefaultDrawWallEnds);
            BreatheAnimations = Preferences.Get("BreatheAnimations", GHConstants.DefaultBreatheAnimations);
            AlternativeLayerDrawing = Preferences.Get("AlternativeLayerDrawing", GHConstants.DefaultAlternativeLayerDrawing);
            Interlocked.Exchange(ref _longerMessageHistory, GHApp.SavedLongerMessageHistory ? 1 : 0); /* Cannot send response command yet, hence using private variable */

            float deffontsize = GetDefaultMapFontSize();
            DefaultMapFontSize = deffontsize;
            MapFontSize = Preferences.Get("MapFontSize", deffontsize);
            MapFontAlternateSize = Preferences.Get("MapFontAlternateSize", deffontsize * GHConstants.MapFontRelativeAlternateSize);
            MapFontMiniRelativeSize = Preferences.Get("MapFontMiniRelativeSize", 1.0f);
            lock (_mapOffsetLock)
            {
                _mapMiniOffsetX = Preferences.Get("MapMiniOffsetX", 0.0f);
                _mapMiniOffsetY = Preferences.Get("MapMiniOffsetY", 0.0f);
            }
            MapNoClipMode = Preferences.Get("DefaultMapNoClipMode", GHConstants.DefaultMapNoClipMode);

            for (int i = 0; i < 6; i++)
            {
                string keystr = "SimpleUILayoutCommandButton" + (i + 1);
                int defCmd = GHApp.DefaultShortcutButton(0, i, true).GetCommand();
                int savedCmd = Preferences.Get(keystr, defCmd);
                int listselidx = GHApp.SelectableShortcutButtonIndexInList(savedCmd, defCmd);
                if (listselidx >= 0)
                    SetSimpleLayoutCommandButton(i, listselidx);
            }

            for (int i = 0; i < 13; i++)
            {
                string keystr = "FullUILayoutCommandButton" + (i + 1);
                int defCmd = GHApp.DefaultShortcutButton(0, i, false).GetCommand();
                int savedCmd = Preferences.Get(keystr, defCmd);
                int listselidx = GHApp.SelectableShortcutButtonIndexInList(savedCmd, defCmd);
                if (listselidx >= 0)
                    SetFullLayoutCommandButton(i, listselidx);
            }

            ToggleTravelModeButton_Clicked(null, null);
            ZoomMiniMode = true;
            ZoomAlternateMode = true;
            ToggleZoomMiniButton_Clicked(null, null);
            ToggleZoomAlternateButton_Clicked(null, null);
            MapNoClipMode = !MapNoClipMode;
            ToggleAutoCenterModeButton_Clicked(null, null);
            LoadingDetailsLabel.Text = " "; /* Just make sure it shows up */
            StartAtBlack();
            //GHApp.DoKeyboardFocus();

            /* Do this last just in case */
            DesktopButtons = Preferences.Get("DesktopButtons", GHApp.IsDesktop);
#if WINDOWS
            Loaded += (s, e) => 
            {
                UpdateMoreNextPrevButtonVisibility(true, true);
                CommandCanvas.InvalidateSurface();
                MenuCanvas.InvalidateSurface();
                TextCanvas.InvalidateSurface();
            };
#endif

            GHApp.CurrentGamePage = this;
        }

        private void GamePage_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(Width))
            {
                ThreadSafeWidth = Width;
            }
            else if (e.PropertyName == nameof(Height))
            {
                ThreadSafeHeight = Height;
            }
        }

        private void GamePage_SizeChanged(object sender, EventArgs e)
        {
            ThreadSafeWidth = Width;
            ThreadSafeHeight = Height;
        }

        ~GamePage()
        {
            /* Dispose of all bitmaps */
            _paintBitmap.Dispose();
            _tempBitmap.Dispose();
            foreach (SKImage bmp in _savedRects.Values)
                bmp.Dispose();
            _savedRects.Clear();
            foreach (SKImage bmp in _darkenedAutodrawBitmaps.Values)
                bmp.Dispose();
            _darkenedAutodrawBitmaps.Clear();
            foreach (SKImage bmp in _darkenedBitmaps.Values)
                bmp.Dispose();
            _darkenedBitmaps.Clear();
            foreach (SKBitmap bmp in _savedAutoDrawBitmaps.Values)
                bmp.Dispose();
            _savedAutoDrawBitmaps.Clear();
        }

        private void UpdateAbilityButtonVisibility(bool isDesktop)
        {
            lAbilitiesButton.IsVisible = !isDesktop;
            lWornItemsButton.IsVisible = !isDesktop;
            lRowAbilitiesButton.IsVisible = isDesktop;
            lRowWornItemsButton.IsVisible = isDesktop;
            if (isDesktop)
            {
                lRowAbilitiesButton.SetButtonFocus();
            }
            else
            {
                lAbilitiesButton.SetButtonFocus();
            }
        }

        private void NextLabelHandler_PointerExited(object sender, EventArgs e)
        {
            //MoreNextButton.IsVisible = false;
        }

        private async void NextLabelHandler_PointerEntered(object sender, EventArgs e)
        {
            if (!MoreNextButton.IsVisible)
            {
                MoreNextButton.Opacity = 0;
                MoreNextButton.IsVisible = true;
                await MoreNextButton.FadeTo(1.0);
            }
        }

        private void PreviousLabelHandler_PointerExited(object sender, EventArgs e)
        {
            //MorePreviousButton.IsVisible = false;
        }

        private async void PreviousLabelHandler_PointerEntered(object sender, EventArgs e)
        {
            if (!MorePreviousButton.IsVisible)
            {
                MorePreviousButton.Opacity = 0;
                MorePreviousButton.IsVisible = true;
                await MorePreviousButton.FadeTo(1.0);
            }
        }

        private float GetDefaultMapFontSize()
        {
            float c_numerator = 1.0f;
            float c_denominator = 1.0f;
            var mainDisplayInfo = DeviceDisplay.MainDisplayInfo;
            float density = (float)mainDisplayInfo.Density;
#if GNH_MAUI
            DeviceIdiom ti = DeviceInfo.Idiom;
            if (ti == DeviceIdiom.Tablet || ti == DeviceIdiom.Phone)
            {
                c_numerator = 2.0f;
                c_denominator = 3.0f;
            }
#else
            TargetIdiom ti = Device.Idiom;
            switch (ti)
            {
                case TargetIdiom.Tablet:
                case TargetIdiom.Phone:
                    c_numerator = 2.0f;
                    c_denominator = 3.0f;
                    break;
                default:
                    break;
            }
#endif
            return GHConstants.MapFontDefaultSize * (density * c_numerator) / c_denominator;
        }

        public void SetCharacterClickAction(bool newValue)
        {
            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SetCharacterClickAction, newValue));
        }

        public void SetGetPositionArrows(bool newValue)
        {
            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SetGetPositionArrows, newValue));
        }
        public void SetDiceAsRanges(bool newValue)
        {
            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SetDiceAsRanges, newValue));
        }
        public void SetAutoDig(bool newValue)
        {
            if (MapAutoDig != newValue)
                ToggleAutoDigButton_BtnClicked(this, EventArgs.Empty); //Need to inform the game, too
        }
        public void SetIgnoreStopping(bool newValue)
        {
            if (MapIgnoreMode != newValue)
                ToggleIgnoreModeButton_BtnClicked(this, EventArgs.Empty); //Need to inform the game, too
        }


        public void SetRightMouseCommand(int newValue)
        {
            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SetRightMouseCommand, newValue));
        }

        public void SetMiddleMouseCommand(int newValue)
        {
            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SetMiddleMouseCommand, newValue));
        }

        public void StartExistingGame()
        {
            //CurrentGame = GHApp.CurrentGHGame;
            StartGameInitialTasks();
            //bool initAux = MaybeInitAuxCanvases();
            //MaybeFinalizeInitAuxCanvases(initAux);
            StartGameFinalTasks();
            HideLoadingScreen();
        }

        public async Task StartNewGame()
        {
            await StartGame(null, -1);
        }

        public async Task StartReplay(string replayFileName, int fromTurn)
        {
            await StartGame(replayFileName, fromTurn);
        }

        private readonly object _replayLock = new object();
        private string _replayFileName = null;
        public string ReplayFileName { get { lock (_replayLock) { return _replayFileName; } } set { lock (_replayLock) { _replayFileName = value; } } }
        public bool PlayingReplay { get { lock (_replayLock) { return _replayFileName != null; } } }

#if GNH_MAUI
        private IDispatcherTimer _pollingTimer = null;
        private IDispatcherTimer _updateTimer = null;
#endif
        public async Task StartGame(string replayFileName, int fromTurn)
        {
            try
            {
                ReplayFileName = replayFileName;
                LoadingDetailsLabel.Text = "Starting loading...";
                LoadingProgressBar.Progress = 0.0;

                StartGameInitialTasks();
                bool initAuxCanvases = MaybeInitAuxCanvases();

                LoadingDetailsLabel.Text = "Initializing GnollHack...";
                await _gnollHackService.InitializeGnollHack();

                var tasks = new List<Task>();

                LoadingDetailsLabel.Text = "Loading Music Bank...";
                tasks.Add(LoadingProgressBar.ProgressTo(0.1, 400, Easing.Linear));
                tasks.Add(Task.Run(() =>
                {
                    GHApp.FmodService.LoadBanks(sound_bank_loading_type.Music);
                }));
                await Task.WhenAll(tasks);
                tasks.Clear();

                if (!GHApp.StartGameDataSet)
                {
                    Task<SKImage> tileSetTask;
                    LoadingDetailsLabel.Text = "Loading Master Sound Banks...";
                    tasks.Add(LoadingProgressBar.ProgressTo(0.30, 400, Easing.Linear));
                    tasks.Add(Task.Run(() =>
                    {
                        GHApp.FmodService.LoadBanks(sound_bank_loading_type.Game);
                    }));
                    await Task.WhenAll(tasks);
                    tasks.Clear();

                    LoadingDetailsLabel.Text = "Loading Tile Sheet 1/2...";
                    tasks.Add(LoadingProgressBar.ProgressTo(0.45, 400, Easing.Linear));
                    tileSetTask = GHApp.LoadTilesetAsync("gnollhack_64x96_transparent_32bits.ghpng");
                    tasks.Add(tileSetTask);
                    await Task.WhenAll(tasks);
                    GHApp._tileMap[0] = tileSetTask.Result;
                    tasks.Clear();

                    LoadingDetailsLabel.Text = "Loading Tile Sheet 2/2...";
                    tasks.Add(LoadingProgressBar.ProgressTo(0.55, 200, Easing.Linear));
                    tileSetTask = GHApp.LoadTilesetAsync("gnollhack_64x96_transparent_32bits-2.ghpng");
                    tasks.Add(tileSetTask);
                    await Task.WhenAll(tasks);
                    GHApp._tileMap[1] = tileSetTask.Result;
                    tasks.Clear();

                    LoadingDetailsLabel.Text = "Loading GnollHack icon...";
                    tasks.Add(LoadingProgressBar.ProgressTo(0.575, 50, Easing.Linear));
                    tasks.Add(Task.Run(() =>
                    {
                        GHApp._logoBitmap = GHApp.LoadEmbeddedAssetsBitmap("gnollhack-icon-v2-512.png");
                    }));
                    await Task.WhenAll(tasks);
                    tasks.Clear();

                    LoadingDetailsLabel.Text = "Loading embedded bitmaps...";
                    tasks.Add(LoadingProgressBar.ProgressTo(0.65, 100, Easing.Linear));
                    tasks.Add(Task.Run(() =>
                    {
                        GHApp._skillBitmap = GHApp.LoadEmbeddedUIBitmap("skill.png");
                        GHApp._prevWepBitmap = GHApp.LoadEmbeddedUIBitmap("wield.png");
                        GHApp._prevUnwieldBitmap = GHApp.LoadEmbeddedUIBitmap("unwield.png");

                        GHApp.InitializeArrowButtons();
                        GHApp.InitializeUIBitmaps();
                        GHApp.InitializeMoreCommandButtons(UseSimpleCmdLayout);

                        GHApp.UnexploredGlyph = _gnollHackService.GetUnexploredGlyph();
                        GHApp.NoGlyph = _gnollHackService.GetNoGlyph();
                    }));
                    await Task.WhenAll(tasks);
                    tasks.Clear();

                    LoadingDetailsLabel.Text = "Loading tile offset data...";
                    tasks.Add(LoadingProgressBar.ProgressTo(0.675, 50, Easing.Linear));
                    tasks.Add(Task.Run(() =>
                    {
                        int animoff, enloff, reoff, general_tile_off, hit_tile_off, ui_tile_off, spell_tile_off, skill_tile_off, command_tile_off, buff_tile_off, cursor_off;
                        _gnollHackService.GetOffs(out animoff, out enloff, out reoff, out general_tile_off, out hit_tile_off, out ui_tile_off, out spell_tile_off, out skill_tile_off, out command_tile_off, out buff_tile_off,
                            out cursor_off);
                        GHApp.AnimationOff = animoff;
                        GHApp.EnlargementOff = enloff;
                        GHApp.ReplacementOff = reoff;
                        GHApp.GeneralTileOff = general_tile_off;
                        GHApp.HitTileOff = hit_tile_off;
                        GHApp.UITileOff = ui_tile_off;
                        GHApp.SpellTileOff = spell_tile_off;
                        GHApp.SkillTileOff = skill_tile_off;
                        GHApp.CommandTileOff = command_tile_off;
                        GHApp.BuffTileOff = buff_tile_off;
                        GHApp.CursorOff = cursor_off;
                    }));
                    await Task.WhenAll(tasks);
                    tasks.Clear();

                    LoadingDetailsLabel.Text = "Loading animations...";
                    tasks.Add(LoadingProgressBar.ProgressTo(0.700, 50, Easing.Linear));
                    tasks.Add(Task.Run(() =>
                    {
                        GHApp._animationDefs = _gnollHackService.GetAnimationArray();
                    }));
                    await Task.WhenAll(tasks);
                    tasks.Clear();

                    LoadingDetailsLabel.Text = "Loading enlargements...";
                    tasks.Add(LoadingProgressBar.ProgressTo(0.725, 50, Easing.Linear));
                    tasks.Add(Task.Run(() =>
                    {
                        GHApp._enlargementDefs = _gnollHackService.GetEnlargementArray();
                    }));
                    await Task.WhenAll(tasks);
                    tasks.Clear();

                    LoadingDetailsLabel.Text = "Loading replacements...";
                    tasks.Add(LoadingProgressBar.ProgressTo(0.75, 50, Easing.Linear));
                    tasks.Add(Task.Run(() =>
                    {
                        GHApp._replacementDefs = _gnollHackService.GetReplacementArray();
                    }));
                    await Task.WhenAll(tasks);
                    tasks.Clear();

                    LoadingDetailsLabel.Text = "Loading autodraws...";
                    tasks.Add(LoadingProgressBar.ProgressTo(0.775, 50, Easing.Linear));
                    tasks.Add(Task.Run(() =>
                    {
                        GHApp._autodraws = _gnollHackService.GetAutoDrawArray();
                    }));
                    await Task.WhenAll(tasks);
                    tasks.Clear();

                    GHApp.StartGameDataSet = true;
                }

                LoadingDetailsLabel.Text = "Loading extended commands...";
                tasks.Add(LoadingProgressBar.ProgressTo(0.90, 100, Easing.Linear));
                tasks.Add(Task.Run(() =>
                {
                    ExtendedCommands = _gnollHackService.GetExtendedCommands();
                }));
                await Task.WhenAll(tasks);
                tasks.Clear();

                LoadingDetailsLabel.Text = "Loading manuals...";
                tasks.Add(LoadingProgressBar.ProgressTo(0.95, 50, Easing.Linear));
                tasks.Add(Task.Run(() =>
                {
                    GHApp.CalculateFoundManuals();
                }));
                await Task.WhenAll(tasks);
                tasks.Clear();

                LoadingDetailsLabel.Text = "Cleaning up memory...";
                GHApp.CollectGarbage();
                await LoadingProgressBar.ProgressTo(0.98, 40, Easing.Linear);

                if (PlayingReplay)
                {
                    //MainGrid.IsEnabled = false;
                    lWornItemsButton.IsEnabled = false;
                    lAbilitiesButton.IsEnabled = false;
                    lRowWornItemsButton.IsEnabled = false;
                    lRowAbilitiesButton.IsEnabled = false;
                    //ContextLayout.IsEnabled = false;

                    GameMenuButton.IsEnabled = false;
                    ESCButton.IsEnabled = false;
                    LookModeButton.IsEnabled = false;
                    ToggleTravelModeButton.IsEnabled = false;
                    ToggleAutoDigButton.IsEnabled = false;
                    ToggleIgnoreModeButton.IsEnabled = false;
                    ButtonRowStack.IsEnabled = false;

                    GameMenuButton.Opacity = 0.5;
                    ESCButton.Opacity = 0.5;
                    LookModeButton.Opacity = 0.5;
                    ToggleTravelModeButton.Opacity = 0.5;

                    //SimpleGameMenuButton.IsEnabled = false;
                    //SimpleESCButton.IsEnabled = false;
                    //SimpleLookModeButton.IsEnabled = false;
                    //SimpleButtonRowStack.IsEnabled = false;

                    //SimpleGameMenuButton.Opacity = 0.5;
                    //SimpleESCButton.Opacity = 0.5;
                    //SimpleLookModeButton.Opacity = 0.5;

                    MenuGrid.IsEnabled = false;
                    TextGrid.IsEnabled = false;
                    GetLineGrid.IsEnabled = false;
                    YnGrid.IsEnabled = false;
                    PopupGrid.IsEnabled = false;
                    MoreCommandsGrid.IsEnabled = false;
                    TipView.IsEnabled = false;
                    ReplayRealTimeLabel.Text = "";
                    ReplayHeaderLabel.Text = "";
                    GHApp.ResetReplay();
                    GHApp.GoToTurn = fromTurn;
                    UpdateReplaySpeedButtons();
                    UpdateReplayPauseButton();
                    ReplayGrid.IsVisible = true;
                    DeviceDisplay.KeepScreenOn = true;
                }

                MaybeFinalizeInitAuxCanvases(initAuxCanvases);

                GHApp.FmodService?.StopAllUISounds();
                Thread t;
                if (PlayingReplay)
                    t = new Thread(new ThreadStart(GNHThreadProcForReplay));
                else
                    t = new Thread(new ThreadStart(GNHThreadProc));
                GHApp.GnhThread = t;
                t.Start();

                LoadingDetailsLabel.Text = "Finishing up...";
                await LoadingProgressBar.ProgressTo(0.99, 40, Easing.Linear);

                StartGameFinalTasks();

                await LoadingProgressBar.ProgressTo(1.0, 20, Easing.Linear);
                LoadingDetailsLabel.Text = "Done loading.";
                SetupKeyListening();
                GHApp.DebugCheckCurrentFileDescriptor("StartGameFinished");
                GHApp.MaybeWriteGHLog("StartGame finished successfully.", true, "Start Information");
            }
            catch (Exception ex)
            {
                GHApp.MaybeWriteGHLog("StartGame: " + ex.Message);
#if SENTRY
                SentrySdk.CaptureException(ex);
#endif
                await GHApp.DisplayMessageBox(this, "Error", "Error occurred when setting up the game: " + ex.Message, "OK");
            }
        }

        private void StartGameInitialTasks()
        {
            GHApp.GameStarted = true;
            MainCanvasView.Focus();

            MainCanvasView._gamePage = this;
            CommandCanvas._gamePage = this;
            MenuCanvas._gamePage = this;
            TextCanvas._gamePage = this;
            TipView._gamePage = this;

            MainCanvasView._parentGrid = MainGrid;
            CommandCanvas._parentGrid = MoreCommandsGrid;
            MenuCanvas._parentGrid = MenuGrid;
            TextCanvas._parentGrid = TextGrid;
            TipView._parentGrid = null;
        }

        private bool MaybeInitAuxCanvases()
        {
            bool initAuxCanvases = GHApp.IsAndroid && GHApp.UseGPU && !GHApp.DisableAuxGPU;
            if (initAuxCanvases)
            {
                MenuGrid.IsVisible = true;
                TextGrid.IsVisible = true;
                MoreCommandsGrid.IsVisible = true;
                MenuCanvas.InvalidateSurface();
                TextCanvas.InvalidateSurface();
                CommandCanvas.InvalidateSurface();
            }
            return initAuxCanvases;
        }

        private void MaybeFinalizeInitAuxCanvases(bool initAuxCanvases)
        {
            if (initAuxCanvases)
            {
                MenuGrid.IsVisible = false;
                TextGrid.IsVisible = false;
                MoreCommandsGrid.IsVisible = false;
            }
        }

        private void StartGameFinalTasks()
        {
            _stopWatch.Start();

            IsGameOn = true;
            IsMainCanvasOn = true;
            MainGrid.IsVisible = true;
            MainCanvasView.InvalidateSurface();

            /* Polling timer */
#if GNH_MAUI
                _pollingTimer = Microsoft.Maui.Controls.Application.Current.Dispatcher.CreateTimer();
                _pollingTimer.Interval = TimeSpan.FromSeconds(1.0 / GHConstants.PollingFrequency);
                _pollingTimer.IsRepeating = true;
                _pollingTimer.Tick += (s, e) => { DoPolling(); if (!IsGameOn) _pollingTimer?.Stop(); };
                _pollingTimer.Start();
#else
            Device.StartTimer(TimeSpan.FromSeconds(1.0 / GHConstants.PollingFrequency), () =>
            {
                DoPolling();
                return IsGameOn;
            });
#endif
            /* Cursor and FPS update timer */
#if GNH_MAUI
                _updateTimer = Microsoft.Maui.Controls.Application.Current.Dispatcher.CreateTimer();
                _updateTimer.Interval = TimeSpan.FromSeconds(0.5);
                _updateTimer.IsRepeating = true;
                _updateTimer.Tick += (s, e) => { DoUpdateTimer(); if (!IsGameOn) _updateTimer?.Stop(); };
                _updateTimer.Start();
#else
            Device.StartTimer(TimeSpan.FromSeconds(0.5), () =>
            {
                DoUpdateTimer();
                return IsGameOn;
            });
#endif

        }

        public void StopTimers()
        {
#if GNH_MAUI
            if (_updateTimer?.IsRunning ?? false)
               _updateTimer?.Stop();
            if (_pollingTimer?.IsRunning ?? false)
                _pollingTimer?.Stop();
            StopMenuHideTimers();
            StopTextHideTimers();
#endif
        }

        //private bool StartingPositionsSet { get; set; }
        public void DoPolling()
        {
            try
            {
                MainThread.BeginInvokeOnMainThread(() =>
                {
                    try
                    {
                        List<Task> tasks = null;
                        try
                        {
                            tasks = PollRequestQueue();
                        }
                        catch (Exception ex)
                        {
                            Debug.WriteLine(ex);
                        }
                        if (tasks != null)
                        {
                            /* Note that this await is for exception handling only. The tasks start immediately execution upon calling async Task method */
                            try
                            {
                                MainThread.InvokeOnMainThreadAsync(async () =>
                                {
                                    try
                                    {
                                        await Task.WhenAll(tasks);
                                    }
                                    catch (Exception ex)
                                    {
                                        Debug.WriteLine(ex);
                                    }
                                });
                            }
                            catch (Exception ex)
                            {
                                Debug.WriteLine(ex);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex);
                    }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
            }
        }

        //private bool _mainCounterDiffZeroObserved = false;
        //private bool _renderingCounterDiffZeroObserved = false;

        //private readonly object _updateTimerTickCountLock = new object();
        private long _updateTimerTickCount = 0L;
        public long UpdateTimerTickCount { get { return Interlocked.CompareExchange(ref _updateTimerTickCount, 0, 0); } }

        private void DoUpdateTimer()
        {
            MainThread.BeginInvokeOnMainThread(() =>
            {
                long incrementedValue = Interlocked.Increment(ref _updateTimerTickCount);
                if (incrementedValue == long.MaxValue)
                    Interlocked.Exchange(ref _updateTimerTickCount, 0);

                if (incrementedValue % 10 == 0)
                    GHApp.LogMemory();

                //lock (_updateTimerTickCountLock)
                //{
                //    _updateTimerTickCount++;
                //    if (_updateTimerTickCount == long.MaxValue)
                //        _updateTimerTickCount = 0L;
                //}
                //lock (_cursorIsOnLock)
                //{
                //    _cursorIsOn = !_cursorIsOn;
                //}
                CursorIsOn = !CursorIsOn;
                //lock (_showMemoryLock)
                {
                    if (ShowMemory)
                        Interlocked.Exchange(ref _memUsage, GC.GetTotalMemory(false));

                    //_memUsage = GC.GetTotalMemory(false);
                }

                if (ShowFPS)
                {
                    if (!_stopWatch.IsRunning)
                    {
                        _stopWatch.Restart();
                    }
                    else
                    {
                        _stopWatch.Stop();
                        TimeSpan ts = _stopWatch.Elapsed;
                        //lock (_fpslock)
                        {
                            long counterDiff = 0;
                            if (MoreCommandsGrid.IsVisible)
                            {
                                //lock (_commandFPSCounterLock)
                                {
                                    long countervalue = CommandFPSCounterValue;
                                    counterDiff = countervalue - _previousCommandFPSCounterValue;
                                    _previousCommandFPSCounterValue = countervalue;
                                }
                            }
                            else
                            {
                                //lock (_mainFPSCounterLock)
                                {
                                    long countervalue = MainFPSCounterValue;
                                    counterDiff = countervalue - _previousMainFPSCounterValue;
                                    _previousMainFPSCounterValue = countervalue;
                                }
#if false
                                long mainFPSCounter;
                                lock (_mainFPSCounterLock)
                                {
                                    mainFPSCounter = _mainFPSCounterValue;
                                    counterDiff = _mainFPSCounterValue - _previousMainFPSCounterValue;
                                    _previousMainFPSCounterValue = _mainFPSCounterValue;
                                }
                                if (GHApp.IsWindows)
                                {
                                    long renderingCounter = GHApp.RenderingCounter;
                                    long renderingCounterDiff = renderingCounter - _previousRenderingCounterValue;
                                    _previousRenderingCounterValue = renderingCounter;
                                    if (((renderingCounterDiff == 0 &&  !_renderingCounterDiffZeroObserved) || (counterDiff == 0 && mainFPSCounter > 0 && !_mainCounterDiffZeroObserved)) && UpdateTimerTickCount > 10 && IsGameOn && IsMainCanvasOn && !LoadingGrid.IsVisible && !MoreCommandsGrid.IsVisible && !MenuGrid.IsVisible && !TextGrid.IsVisible)
                                    {
                                        if (counterDiff == 0 && !_mainCounterDiffZeroObserved)
                                        {
                                            _mainCounterDiffZeroObserved = true;
                                            GHApp.MaybeWriteGHLog("MainCanvas counterDiff is 0");
                                        }
                                        if (renderingCounterDiff == 0 && !_renderingCounterDiffZeroObserved)
                                        {
                                            _renderingCounterDiffZeroObserved = true;
                                            GHApp.MaybeWriteGHLog("Rendering counterDiff is 0");
                                        }
                                        if ((_mainCounterDiffZeroObserved || _renderingCounterDiffZeroObserved) && !PleaseWaitLabel.IsVisible)
                                        {
                                            PleaseWaitLabel.IsVisible = true;
                                            StopMainCanvasAnimation();
                                            MainCanvasView.IsVisible = false;
                                            RefreshScreen = true;
                                            MainCanvasView.IsVisible = true;
                                            StartMainCanvasAnimation();
                                        }
                                    }
                                    else if ((renderingCounterDiff > 0 && _renderingCounterDiffZeroObserved) || (counterDiff > 0 && _mainCounterDiffZeroObserved))
                                    {
                                        if (counterDiff > 0)
                                        {
                                            _mainCounterDiffZeroObserved = false;
                                            GHApp.MaybeWriteGHLog("MainCanvas counter is back on");
                                        }
                                        if (renderingCounterDiff > 0)
                                        {
                                            _renderingCounterDiffZeroObserved = false;
                                            GHApp.MaybeWriteGHLog("Rendering counter is back on");
                                        }
                                        if (!_mainCounterDiffZeroObserved && !_renderingCounterDiffZeroObserved && PleaseWaitLabel.IsVisible)
                                            PleaseWaitLabel.IsVisible = false;
                                    }
                                }
#endif
                                //lock (AnimationTimerLock)
                                //{
                                //    currentCounterValue = Interlocked.CompareExchange(ref AnimationTimers.general_animation_counter, 0L, 0L);;
                                //}
                            }
                            //lock (_fpslock)
                            {
                                double calcFps = ts.TotalMilliseconds == 0.0 ? 0.0 : counterDiff / (ts.TotalMilliseconds / 1000.0);
                                if (calcFps < 0.0f || calcFps > 500.0f) /* Just in case if it is off somehow */
                                {
                                    calcFps = 0.0;
                                    counterDiff = 0;
                                }
                                FPS = calcFps;
                            }
                        }
                        _stopWatch.Restart();
                    }
                }
                else
                {
                    if (_stopWatch.IsRunning)
                        _stopWatch.Stop();
                }
                if (PlayingReplay)
                {
                    string realTime = GHApp.ReplayRealTime;
                    if (string.IsNullOrEmpty(realTime))
                        ReplayRealTimeLabel.Text = "";
                    else if (realTime != ReplayRealTimeLabel.Text)
                        ReplayRealTimeLabel.Text = realTime;

                    UpdateReplayHeaderLabel();
                }
            });
        }

        public async Task RestartGameAfterPageDestruction()
        {
            GHApp.FmodService?.StopAllGameSounds((uint)StopSoundFlags.All, 0);
            GHApp.FmodService?.ResetGameState();
            GHApp.GnollHackService?.SetExitHack(2);
            await GHApp.Navigation.PushModalAsync(this);
            await StartNewGame();
        }

        public async Task RestartGame()
        {
            Thread gnhThread = GHApp.GnhThread;
            if (gnhThread != null)
            {
                /* Game thread may have outstanding things to do, but wait for up to 1 second to let them finish */
                for (int i = 0; i < 20 && gnhThread.IsAlive; i++)
                {
                    await Task.Delay(50);
                }
            }
            //CurrentGame = null;
            GHApp.CurrentGHGame = null;
            GHApp.GnhThread = null;

            /* Collect garbage at this point */
            GHApp.CollectGarbage();
            await Task.Delay(50);

            Thread t = new Thread(new ThreadStart(GNHThreadProcForRestart));
            GHApp.GnhThread = t;
            t.Start();
        }

        public async Task RestartReplay()
        {
            /* Replay thread should have finished by now since it does not have any outstanding things to do, but wait for 50 millisecs just in case if this is not the case */
            
            if (GHApp.GnhThread?.IsAlive ?? false)
                await Task.Delay(50);

            //CurrentGame = null;
            GHApp.CurrentGHGame = null;
            GHApp.GnhThread = null;

            /* Collect garbage at this point */
            GHApp.CollectGarbage();
            await Task.Delay(50);

            Thread t = new Thread(new ThreadStart(GNHThreadProcForReplay));
            GHApp.GnhThread = t;
            t.Start();
        }

        public void UpdateMainCanvas(MapRefreshRateStyle refreshRateStyle)
        {
            if (RefreshScreen)
            {
                if (MainCanvasView.ThreadSafeIsVisible)
                {
                    if (ForceAllMessages)
                    {
                        float timePassed = 0;
                        if (!_mapUpdateStopWatch.IsRunning)
                        {
                            timePassed = 1.0f / UIUtils.GetMainCanvasAnimationFrequency(refreshRateStyle);
                            _mapUpdateStopWatch.Restart();
                        }
                        else
                        {
                            _mapUpdateStopWatch.Stop();
                            timePassed = (float)_mapUpdateStopWatch.ElapsedMilliseconds / 1000f;
                            _mapUpdateStopWatch.Restart();
                        }

                        //float canvasheight = MainCanvasView.ThreadSafeCanvasSize.Height;
                        float canvasheight;
                        lock (_savedCanvasLock)
                        {
                            canvasheight = _savedCanvasHeight;
                        }
                        if (canvasheight <= 0)
                            return;

                        lock (_messageScrollLock)
                        {
                            if (_messageScrollSpeedOn)
                            {
                                float speed = _messageScrollSpeed; /* pixels per second */
                                float topScrollLimit = Math.Max(0, -InterlockedMessageSmallestTop);
                                int sgn = Math.Sign(_messageScrollSpeed);
                                float delta = speed * timePassed; /* pixels */
                                _messageScrollOffset += delta;
                                if (_messageScrollOffset < topScrollLimit && _messageScrollOffset - delta > topScrollLimit)
                                {
                                    _messageScrollOffset = topScrollLimit;
                                    _messageScrollSpeed = 0;
                                    _messageScrollSpeedOn = false;
                                }
                                else if (_messageScrollOffset > 0 && _messageScrollOffset - delta < 0)
                                {
                                    _messageScrollOffset = 0;
                                    _messageScrollSpeed = 0;
                                    _messageScrollSpeedOn = false;
                                }
                                else if (_messageScrollOffset > topScrollLimit || _messageScrollOffset < 0)
                                {
                                    float deceleration1 = canvasheight * GHConstants.ScrollConstantDeceleration * GHConstants.ScrollConstantDecelerationOverEdgeMultiplier;
                                    float deceleration2 = Math.Abs(_messageScrollSpeed) * GHConstants.ScrollSpeedDeceleration * GHConstants.ScrollSpeedDecelerationOverEdgeMultiplier;
                                    float deceleration_per_second = deceleration1 + deceleration2;
                                    float distance_from_edge = _messageScrollOffset > topScrollLimit ? _messageScrollOffset - topScrollLimit : _messageScrollOffset - 0;
                                    float deceleration3 = (distance_from_edge + (float)Math.Sign(distance_from_edge) * GHConstants.ScrollDistanceEdgeConstant * canvasheight) * GHConstants.ScrollOverEdgeDeceleration;
                                    float distance_anchor_distance = canvasheight * GHConstants.ScrollDistanceAnchorFactor;
                                    float close_anchor_distance = canvasheight * GHConstants.ScrollCloseAnchorFactor;
                                    float target_speed_at_distance = GHConstants.ScrollTargetSpeedAtDistanceAnchor;
                                    float target_speed_at_close = GHConstants.ScrollTargetSpeedAtCloseAnchor;
                                    float target_speed_at_edge = GHConstants.ScrollTargetSpeedAtEdge;
                                    float dist_factor = (Math.Abs(distance_from_edge) - close_anchor_distance) / (distance_anchor_distance - close_anchor_distance);
                                    float close_factor = Math.Abs(distance_from_edge) / close_anchor_distance;
                                    float target_speed = -1.0f * (float)Math.Sign(distance_from_edge)
                                        * (
                                        Math.Max(0f, dist_factor) * (target_speed_at_distance - target_speed_at_close)
                                        + Math.Min(1f, close_factor) * (target_speed_at_close - target_speed_at_edge)
                                        + target_speed_at_edge
                                        )
                                        * canvasheight;
                                    if (_messageScrollOffset > topScrollLimit ? _messageScrollSpeed <= 0 : _messageScrollSpeed >= 0)
                                    {
                                        float target_factor = Math.Abs(distance_from_edge) / distance_anchor_distance;
                                        _messageScrollSpeed += (-1.0f * deceleration3) * timePassed;
                                        if (target_factor < 1.0f)
                                        {
                                            _messageScrollSpeed = _messageScrollSpeed * target_factor + target_speed * (1.0f - target_factor);
                                        }
                                    }
                                    else
                                        _messageScrollSpeed += (-1.0f * (float)sgn * deceleration_per_second - deceleration3) * timePassed;
                                }
                                else
                                {
                                    //if (_messageScrollSpeedReleaseStamp != null)
                                    {
                                        long millisecs_elapsed = (DateTime.Now.Ticks - _messageScrollSpeedReleaseStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                                        if (millisecs_elapsed > GHConstants.FreeScrollingTime)
                                        {
                                            float deceleration1 = canvasheight * GHConstants.ScrollConstantDeceleration;
                                            float deceleration2 = Math.Abs(_messageScrollSpeed) * GHConstants.ScrollSpeedDeceleration;
                                            float deceleration_per_second = deceleration1 + deceleration2;
                                            _messageScrollSpeed += -1.0f * (float)sgn * (deceleration_per_second * timePassed);
                                            if (sgn == 0 || (sgn > 0 && _messageScrollSpeed < 0) || (sgn < 0 && _messageScrollSpeed > 0))
                                                _messageScrollSpeed = 0;
                                        }
                                    }
                                }
                                InterlockedMessageScrollOffset = _messageScrollOffset;
                            }
                        }
                    }
                    MainThread.BeginInvokeOnMainThread(() =>
                    {
                        MainCanvasView.InvalidateSurface();
                    });
                }
            }
        }

        public void UpdateCommandCanvas(MapRefreshRateStyle refreshRateStyle)
        {
            if (MoreCommandsGrid.ThreadSafeIsVisible)
            {
                float timePassed = 1.0f / UIUtils.GetAuxiliaryCanvasAnimationFrequency(refreshRateStyle);
                //float timePassed = 0;
                //if (!_mapUpdateStopWatch.IsRunning)
                //{
                //    timePassed = 1.0f / UIUtils.GetAuxiliaryCanvasAnimationFrequency();
                //    _mapUpdateStopWatch.Restart();
                //}
                //else
                //{
                //    _mapUpdateStopWatch.Stop();
                //    timePassed = (float)_mapUpdateStopWatch.ElapsedMilliseconds / 1000f;
                //    _mapUpdateStopWatch.Restart();
                //}
                float offx = MoreCmdOffsetX;
                if (offx != 0 && (CommandTouchDictionary.Count == 0 || _commandChangedPage))
                {
                    //float canvaswidth = CommandCanvas.ThreadSafeCanvasSize.Width;
                    float canvaswidth;
                    lock (_savedCommandCanvasLock)
                    {
                        canvaswidth = _savedCommandCanvasWidth;
                    }
                    float canvasheight;
                    lock (_savedCommandCanvasLock)
                    {
                        canvasheight = _savedCommandCanvasHeight;
                    }
                    float delta = -1 * Math.Sign(offx) * canvaswidth * _moreCmdOffsetAutoSpeed * timePassed;
                    if (offx > 0 && offx + delta < 0)
                        MoreCmdOffsetX = 0;
                    else if (offx < 0 && offx + delta > 0)
                        MoreCmdOffsetX = 0;
                    else
                        MoreCmdOffsetX = offx + delta;
                }
                MainThread.BeginInvokeOnMainThread(() =>
                {
                    CommandCanvas.InvalidateSurface();
                });
            }
        }

        //private int _menuUpdateGCCounter = 0;
        public void UpdateMenuCanvas(MapRefreshRateStyle refreshRateStyle)
        {
            bool refresh = MenuRefresh;
            //lock (_menuDrawOnlyLock)
            //{
            //    refresh = _menuRefresh;
            //}
            if (refresh)
            {
                if (MenuGrid.ThreadSafeIsVisible)
                {
                    //float canvasheight = MenuCanvas.ThreadSafeCanvasSize.Height;
                    float canvasheight;
                    lock (_savedMenuCanvasLock)
                    {
                        canvasheight = _savedMenuCanvasHeight;
                    }
                    float timePassed = 1.0f / UIUtils.GetAuxiliaryCanvasAnimationFrequency(refreshRateStyle);
                    //float timePassed = 0;
                    //if (!_mapUpdateStopWatch.IsRunning)
                    //{
                    //    timePassed = 1.0f / UIUtils.GetAuxiliaryCanvasAnimationFrequency();
                    //    _mapUpdateStopWatch.Restart();
                    //}
                    //else
                    //{
                    //    _mapUpdateStopWatch.Stop();
                    //    timePassed = (float)_mapUpdateStopWatch.ElapsedMilliseconds / 1000f;
                    //    _mapUpdateStopWatch.Restart();
                    //}
                    //bool doGC = false;
                    lock (_menuScrollLock)
                    {
                        if (_menuScrollSpeedOn)
                        {
                            float speed = _menuScrollSpeed; /* pixels per second */
                            float bottomScrollLimit = Math.Min(0, canvasheight - TotalMenuHeight);
                            int sgn = Math.Sign(_menuScrollSpeed);
                            float delta = speed * timePassed;
                            _menuScrollOffset += delta;
                            if (_menuScrollOffset < 0 && _menuScrollOffset - delta > 0)
                            {
                                _menuScrollOffset = 0;
                                _menuScrollSpeed = 0;
                                _menuScrollSpeedOn = false;
                            }
                            else if (_menuScrollOffset > bottomScrollLimit && _menuScrollOffset - delta < bottomScrollLimit)
                            {
                                _menuScrollOffset = bottomScrollLimit;
                                _menuScrollSpeed = 0;
                                _menuScrollSpeedOn = false;
                            }
                            else if (_menuScrollOffset > 0 || _menuScrollOffset < bottomScrollLimit)
                            {
                                float deceleration1 = canvasheight * GHConstants.ScrollConstantDeceleration * GHConstants.ScrollConstantDecelerationOverEdgeMultiplier;
                                float deceleration2 = Math.Abs(_menuScrollSpeed) * GHConstants.ScrollSpeedDeceleration * GHConstants.ScrollSpeedDecelerationOverEdgeMultiplier;
                                float deceleration_per_second = deceleration1 + deceleration2;
                                float distance_from_edge = _menuScrollOffset > 0 ? _menuScrollOffset : _menuScrollOffset - bottomScrollLimit;
                                float deceleration3 = (distance_from_edge + (float)Math.Sign(distance_from_edge) * GHConstants.ScrollDistanceEdgeConstant * canvasheight) * GHConstants.ScrollOverEdgeDeceleration;
                                float distance_anchor_distance = canvasheight * GHConstants.ScrollDistanceAnchorFactor;
                                float close_anchor_distance = canvasheight * GHConstants.ScrollCloseAnchorFactor;
                                float target_speed_at_distance = GHConstants.ScrollTargetSpeedAtDistanceAnchor;
                                float target_speed_at_close = GHConstants.ScrollTargetSpeedAtCloseAnchor;
                                float target_speed_at_edge = GHConstants.ScrollTargetSpeedAtEdge;
                                float dist_factor = (Math.Abs(distance_from_edge) - close_anchor_distance) / (distance_anchor_distance - close_anchor_distance);
                                float close_factor = Math.Abs(distance_from_edge) / close_anchor_distance;
                                float target_speed = -1.0f * (float)Math.Sign(distance_from_edge)
                                    * (
                                    Math.Max(0f, dist_factor) * (target_speed_at_distance - target_speed_at_close)
                                    + Math.Min(1f, close_factor) * (target_speed_at_close - target_speed_at_edge)
                                    + target_speed_at_edge
                                    )
                                    * canvasheight;
                                if (_menuScrollOffset > 0 ? _menuScrollSpeed <= 0 : _menuScrollSpeed >= 0)
                                {
                                    float target_factor = Math.Abs(distance_from_edge) / distance_anchor_distance;
                                    _menuScrollSpeed += (-1.0f * deceleration3) * (float)UIUtils.GetAuxiliaryCanvasAnimationInterval(refreshRateStyle) / 1000;
                                    if (target_factor < 1.0f)
                                    {
                                        _menuScrollSpeed = _menuScrollSpeed * target_factor + target_speed * (1.0f - target_factor);
                                    }
                                }
                                else
                                    _menuScrollSpeed += (-1.0f * (float)sgn * deceleration_per_second - deceleration3) * (float)UIUtils.GetAuxiliaryCanvasAnimationInterval(refreshRateStyle) / 1000;
                            }
                            else
                            {
                                //if(_menuScrollSpeedReleaseStamp != null)
                                {
                                    long millisecs_elapsed = (DateTime.Now.Ticks - _menuScrollSpeedReleaseStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                                    if (millisecs_elapsed > GHConstants.FreeScrollingTime)
                                    {
                                        float deceleration1 = canvasheight * GHConstants.ScrollConstantDeceleration;
                                        float deceleration2 = Math.Abs(_menuScrollSpeed) * GHConstants.ScrollSpeedDeceleration;
                                        float deceleration_per_second = deceleration1 + deceleration2;
                                        _menuScrollSpeed += -1.0f * (float)sgn * ((deceleration_per_second * (float)UIUtils.GetAuxiliaryCanvasAnimationInterval(refreshRateStyle)) / 1000);
                                        if (sgn == 0 || (sgn > 0 && _menuScrollSpeed < 0) || (sgn < 0 && _menuScrollSpeed > 0))
                                            _menuScrollSpeed = 0;
                                    }
                                }
                            }
                            InterlockedMenuScrollOffset = _menuScrollOffset;
                        }
                        //if (!_menuScrollSpeedOn && GHApp.IsAndroid)
                        //{
                        //    if (_menuUpdateGCCounter >= 20)
                        //        doGC = true;
                        //    else
                        //        _menuUpdateGCCounter++;
                        //}
                    }

                    MainThread.BeginInvokeOnMainThread(() =>
                    {
                        MenuCanvas.InvalidateSurface();
                    });
                    //if(doGC)
                    //{
                    //    _menuUpdateGCCounter = 0;
                    //    GHApp.PlatformService?.CollectGarbage();
                    //    GC.Collect();
                    //}
                }
            }
        }

        public void UpdateTextCanvas(MapRefreshRateStyle refreshRateStyle)
        {
            if (TextGrid.ThreadSafeIsVisible)
            {
                //float canvasheight = TextCanvas.ThreadSafeCanvasSize.Height;
                float canvasheight;
                lock (_savedTextCanvasLock)
                {
                    canvasheight = _savedTextCanvasHeight;
                }
                float timePassed = 1.0f / UIUtils.GetAuxiliaryCanvasAnimationFrequency(refreshRateStyle);
                //float timePassed = 0;
                //if (!_mapUpdateStopWatch.IsRunning)
                //{
                //    timePassed = 1.0f / UIUtils.GetAuxiliaryCanvasAnimationFrequency();
                //    _mapUpdateStopWatch.Restart();
                //}
                //else
                //{
                //    _mapUpdateStopWatch.Stop();
                //    timePassed = (float)_mapUpdateStopWatch.ElapsedMilliseconds / 1000f;
                //    _mapUpdateStopWatch.Restart();
                //}
                lock (_textScrollLock)
                {
                    if (_textScrollSpeedOn)
                    {
                        float speed = _textScrollSpeed; /* pixels per second */
                        float bottomScrollLimit = bottomScrollLimit = Math.Min(0, canvasheight - TotalTextHeight);
                        int sgn = Math.Sign(_textScrollSpeed);
                        float delta = speed * timePassed; /* pixels */
                        _textScrollOffset += delta;
                        if (_textScrollOffset < 0 && _textScrollOffset - delta > 0)
                        {
                            _textScrollOffset = 0;
                            _textScrollSpeed = 0;
                            _textScrollSpeedOn = false;
                        }
                        else if (_textScrollOffset > bottomScrollLimit && _textScrollOffset - delta < bottomScrollLimit)
                        {
                            _textScrollOffset = bottomScrollLimit;
                            _textScrollSpeed = 0;
                            _textScrollSpeedOn = false;
                        }
                        else if (_textScrollOffset > 0 || _textScrollOffset < bottomScrollLimit)
                        {
                            float deceleration1 = canvasheight * GHConstants.ScrollConstantDeceleration * GHConstants.ScrollConstantDecelerationOverEdgeMultiplier;
                            float deceleration2 = Math.Abs(_textScrollSpeed) * GHConstants.ScrollSpeedDeceleration * GHConstants.ScrollSpeedDecelerationOverEdgeMultiplier;
                            float deceleration_per_second = deceleration1 + deceleration2;
                            float distance_from_edge = _textScrollOffset > 0 ? _textScrollOffset : _textScrollOffset - bottomScrollLimit;
                            float deceleration3 = (distance_from_edge + (float)Math.Sign(distance_from_edge) * GHConstants.ScrollDistanceEdgeConstant * canvasheight) * GHConstants.ScrollOverEdgeDeceleration;
                            float distance_anchor_distance = canvasheight * GHConstants.ScrollDistanceAnchorFactor;
                            float close_anchor_distance = canvasheight * GHConstants.ScrollCloseAnchorFactor;
                            float target_speed_at_distance = GHConstants.ScrollTargetSpeedAtDistanceAnchor;
                            float target_speed_at_close = GHConstants.ScrollTargetSpeedAtCloseAnchor;
                            float target_speed_at_edge = GHConstants.ScrollTargetSpeedAtEdge;
                            float dist_factor = (Math.Abs(distance_from_edge) - close_anchor_distance) / (distance_anchor_distance - close_anchor_distance);
                            float close_factor = Math.Abs(distance_from_edge) / close_anchor_distance;
                            float target_speed = -1.0f * (float)Math.Sign(distance_from_edge)
                                * (
                                Math.Max(0f, dist_factor) * (target_speed_at_distance - target_speed_at_close)
                                + Math.Min(1f, close_factor) * (target_speed_at_close - target_speed_at_edge)
                                + target_speed_at_edge
                                )
                                * canvasheight;
                            if (_textScrollOffset > 0 ? _textScrollSpeed <= 0 : _textScrollSpeed >= 0)
                            {
                                float target_factor = Math.Abs(distance_from_edge) / distance_anchor_distance;
                                _textScrollSpeed += (-1.0f * deceleration3) * (float)UIUtils.GetAuxiliaryCanvasAnimationInterval(refreshRateStyle) / 1000;
                                if (target_factor < 1.0f)
                                {
                                    _textScrollSpeed = _textScrollSpeed * target_factor + target_speed * (1.0f - target_factor);
                                }
                            }
                            else
                                _textScrollSpeed += (-1.0f * (float)sgn * deceleration_per_second - deceleration3) * (float)UIUtils.GetAuxiliaryCanvasAnimationInterval(refreshRateStyle) / 1000;
                        }
                        else
                        {
                            //if (_textScrollSpeedReleaseStamp != null)
                            {
                                long millisecs_elapsed = (DateTime.Now.Ticks - _textScrollSpeedReleaseStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                                if (millisecs_elapsed > GHConstants.FreeScrollingTime)
                                {
                                    float deceleration1 = canvasheight * GHConstants.ScrollConstantDeceleration;
                                    float deceleration2 = Math.Abs(_textScrollSpeed) * GHConstants.ScrollSpeedDeceleration;
                                    float deceleration_per_second = deceleration1 + deceleration2;
                                    _textScrollSpeed += -1.0f * (float)sgn * ((deceleration_per_second * (float)UIUtils.GetAuxiliaryCanvasAnimationInterval(refreshRateStyle)) / 1000);
                                    if (sgn == 0 || (sgn > 0 && _textScrollSpeed < 0) || (sgn < 0 && _textScrollSpeed > 0))
                                        _textScrollSpeed = 0;
                                }
                            }
                        }
                        InterlockedTextScrollOffset = _textScrollOffset;
                    }
                }

                MainThread.BeginInvokeOnMainThread(() =>
                {
                    TextCanvas.InvalidateSurface();
                });
            }
        }

        public bool PlatformRenderLoopToggled = false;

        private void StartMainCanvasAnimation(bool settingToggled = false)
        {
            if (!settingToggled && GHApp.UsePlatformRenderLoop)
                return;
            uint mainAnimationLength = GHConstants.MainCanvasAnimationTime / UIUtils.GetMainCanvasAnimationInterval(MapRefreshRate);
            Animation canvasAnimation = new Animation(v => MainCanvasView.GeneralAnimationCounter = (long)v, 1, mainAnimationLength);
            canvasAnimation.Commit(MainCanvasView, "GeneralAnimationCounter", length: GHConstants.MainCanvasAnimationTime,
                rate: UIUtils.GetMainCanvasAnimationInterval(MapRefreshRate), repeat: () => true /* MainGrid.IsVisible */);
            _mapUpdateStopWatch.Restart();
        }

        private void StopMainCanvasAnimation(bool settingToggled = false)
        {
            if (!settingToggled && GHApp.UsePlatformRenderLoop)
                return;
            if (MainCanvasView.AnimationIsRunning("GeneralAnimationCounter"))
                MainCanvasView.AbortAnimation("GeneralAnimationCounter");
            if (_mapUpdateStopWatch.IsRunning)
                _mapUpdateStopWatch.Stop();
        }

        private void StartCommandCanvasAnimation()
        {
            if (GHApp.UsePlatformRenderLoop)
                return;
            MapRefreshRateStyle refreshRateStyle = MapRefreshRate;
            uint auxAnimationLength = GHConstants.AuxiliaryCanvasAnimationTime / UIUtils.GetAuxiliaryCanvasAnimationInterval(refreshRateStyle);
            Animation commandAnimation = new Animation(v => CommandCanvas.GeneralAnimationCounter = (long)v, 1, auxAnimationLength);
            commandAnimation.Commit(CommandCanvas, "GeneralAnimationCounter", length: GHConstants.AuxiliaryCanvasAnimationTime,
                rate: UIUtils.GetAuxiliaryCanvasAnimationInterval(refreshRateStyle), repeat: () => true /* MoreCommandsGrid.IsVisible */);
            //_mapUpdateStopWatch.Restart();
        }

        private void StopCommandCanvasAnimation()
        {
            if (GHApp.UsePlatformRenderLoop)
                return;
            if (CommandCanvas.AnimationIsRunning("GeneralAnimationCounter"))
                CommandCanvas.AbortAnimation("GeneralAnimationCounter");
            //if (_mapUpdateStopWatch.IsRunning)
            //    _mapUpdateStopWatch.Stop();
        }

        private void StartMenuCanvasAnimation()
        {
            if (GHApp.UsePlatformRenderLoop)
                return;
            MapRefreshRateStyle refreshRateStyle = MapRefreshRate;
            uint auxAnimationLength = GHConstants.AuxiliaryCanvasAnimationTime / UIUtils.GetAuxiliaryCanvasAnimationInterval(refreshRateStyle);
            Animation commandAnimation = new Animation(v => MenuCanvas.GeneralAnimationCounter = (long)v, 1, auxAnimationLength);
            commandAnimation.Commit(MenuCanvas, "GeneralAnimationCounter", length: GHConstants.AuxiliaryCanvasAnimationTime, 
                rate: UIUtils.GetAuxiliaryCanvasAnimationInterval(refreshRateStyle), repeat: () => true /* MenuGrid.IsVisible */);
            //_mapUpdateStopWatch.Restart();
        }

        private void StopMenuCanvasAnimation()
        {
            if (GHApp.UsePlatformRenderLoop)
                return;
            if (MenuCanvas.AnimationIsRunning("GeneralAnimationCounter"))
                MenuCanvas.AbortAnimation("GeneralAnimationCounter");
            //if(_mapUpdateStopWatch.IsRunning)
            //    _mapUpdateStopWatch.Stop();
        }

        private void StartTextCanvasAnimation()
        {
            if (GHApp.UsePlatformRenderLoop)
                return;
            MapRefreshRateStyle refreshRateStyle = MapRefreshRate;
            uint auxAnimationLength = GHConstants.AuxiliaryCanvasAnimationTime / UIUtils.GetAuxiliaryCanvasAnimationInterval(refreshRateStyle);
            Animation commandAnimation = new Animation(v => TextCanvas.GeneralAnimationCounter = (long)v, 1, auxAnimationLength);
            commandAnimation.Commit(TextCanvas, "GeneralAnimationCounter", length: GHConstants.AuxiliaryCanvasAnimationTime, 
                rate: UIUtils.GetAuxiliaryCanvasAnimationInterval(refreshRateStyle), repeat: () => true /* TextGrid.IsVisible */);
            //_mapUpdateStopWatch.Restart();
        }

        private void StopTextCanvasAnimation()
        {
            if (GHApp.UsePlatformRenderLoop)
                return;
            if (TextCanvas.AnimationIsRunning("GeneralAnimationCounter"))
                TextCanvas.AbortAnimation("GeneralAnimationCounter");
            //if (_mapUpdateStopWatch.IsRunning)
            //    _mapUpdateStopWatch.Stop();
        }

        private double GetAnimationCounterFrameSpeed(MapRefreshRateStyle refreshRateStyle, bool isMainCanvas)
        {
            double framespeed = 1.0;
            if (!isMainCanvas) /* Auxiliary canvas runs at least at 60 FPS, otherwise the same as the main canvas */
            {
                //int auxRefreshRate = UIUtils.GetAuxiliaryCanvasAnimationFrequency(refreshRateStyle);
                //int mainFps = UIUtils.GetMainCanvasAnimationFrequency(refreshRateStyle);
                //if (mainFps > 0)
                //    framespeed *= (double)mainFps / (double)auxRefreshRate;
                if (refreshRateStyle < MapRefreshRateStyle.MapFPS60)
                    refreshRateStyle = MapRefreshRateStyle.MapFPS60;
            }

            switch (refreshRateStyle)
            {
                case MapRefreshRateStyle.MapFPS20:
                    framespeed *= 2.0; /* Animations skip at every other frame at 20fps to get 40fps */
                    break;
                case MapRefreshRateStyle.MapFPS30:
                    break;
                case MapRefreshRateStyle.MapFPS40:
                    break;
                case MapRefreshRateStyle.MapFPS60:
                case MapRefreshRateStyle.MapFPS72:
                    framespeed *= 0.5;
                    //subCounterMax = 1; /* Animations proceed at every other frame at 60fps to get 30fps */
                    break;
                case MapRefreshRateStyle.MapFPS80:
                    framespeed *= 0.5;
                    //subCounterMax = 1; /* Animations proceed at every other frame at 80fps to get 40fps */
                    break;
                case MapRefreshRateStyle.MapFPS90:
                    framespeed *= 1.0 / 3.0;
                    //subCounterMax = 2; /* Animations proceed at every third frame at 90fps to get 30fps */
                    break;
                case MapRefreshRateStyle.MapFPS120:
                    framespeed *= 1.0 / 3.0;
                    //subCounterMax = 2; /* Animations proceed at every third frame at 120fps to get 40fps */
                    break;
                case MapRefreshRateStyle.MapFPS144:
                    framespeed *= 1.0 / 4.0;
                    //subCounterMax = 3; /* Animations proceed at every fourth frame at 144fps to get 36fps */
                    break;
            }
            return framespeed;
        }

        /* Main counter runs at the defined MapRefreshRateStyle rate, e.g. 60 fps, 120 fps or 20 fps. It may, however, run at a different speed if the animation system cannot adhere to the full speed. This case is not considered currently. */
        /* General animation counter runs at 30fps or 40 fps based on the factor from GetAnimationCounterFrameSpeed applied on the main counter. This counter is intended for tile animations (also found in the legacy Windows version), which are designed to run at this rate so that there are not overly many frames to take memory / to be drawn by the artist. */ 
        /* However, this rate is too low for GUI animations, which need to be run at 60 FPS. Note also that if the main counter runs at a speed different from the intended full speed, then the animation counter runs equally differently as well. */
        
        /* Main counter and general animation counters are incremented on animation system call to UpdateMainCanvas(). Main counter practically measures the calls by the animation system to InvalidateSurface. */
        /* GUI animations such as found item animations (item bounces), death animations (the tile rotates), fading animations etc. are designed to run at 60 fps (specication have arrays just for this rate). These animations are not found in the legacy Windows version, and they require continuous refresh and redraw of the screen, which the legacy Windows version does not do. */
        /* One cannot use here the general animation counter, since it advances too slowly, so you need to use the main counter and adjust it for the GUI animation's target 60 FPS speed */

        /* Side note: */
        /* There is also _mainFPSCounterValue, which is updated on every call to PaintSurface, and it measures the calls to PaintSurface, which may be different from calls to UpdateMainCanvas / InvalidateSurface. */
        /* _mainFPSCounterValue, however, does not necessarily measure how often the map bitmap on the screen is updated, as this depends on further factors than just running through the drawing instructions in PaintSurface. */
        /* One could potentially use StopWatch to determine the necessary counter increments, but this could lead to unnecessarily dropped frames, so we have decided that it is better to advance animations potentially at an uneven speed rather than drop some frames. */

        private double GetMainCounterIncrementMultiplierForGUIAnimations(MapRefreshRateStyle refreshRateStyle)
        {
            double framespeed = 1.0;
            switch (refreshRateStyle)
            {
                case MapRefreshRateStyle.MapFPS20:
                    framespeed = 3.0;
                    break;
                case MapRefreshRateStyle.MapFPS30:
                    framespeed = 2.0;
                    break;
                case MapRefreshRateStyle.MapFPS40:
                    framespeed = 1.5;
                    break;
                case MapRefreshRateStyle.MapFPS60:
                    framespeed = 1;
                    break;
                case MapRefreshRateStyle.MapFPS72:
                    framespeed = 5.0 / 6.0;
                    break;
                case MapRefreshRateStyle.MapFPS80:
                    framespeed = 0.75;
                    break;
                case MapRefreshRateStyle.MapFPS90:
                    framespeed = 2.0 / 3.0;
                    break;
                case MapRefreshRateStyle.MapFPS120:
                    framespeed = 0.5;
                    break;
                case MapRefreshRateStyle.MapFPS144:
                    framespeed = 5.0 / 12.0;
                    break;
            }
            return framespeed;
        }

        private int _subCounter = 0;
        public long GetAnimationCounterIncrement(MapRefreshRateStyle refreshRateStyle, bool isMainCanvas)
        {
            long counter_increment = 1;
            int subCounterMax = 0;
            double framespeed = GetAnimationCounterFrameSpeed(refreshRateStyle, isMainCanvas);
            if(PlayingReplay)
            {
                double rpspeed = GHApp.ReplaySpeed;
                framespeed = framespeed * rpspeed;
            }
            if(framespeed >= 1)
            {
                counter_increment = (long)Math.Round(framespeed);
                subCounterMax = 0;
            }
            else if(framespeed > 0)
            {
                double inverse = 1.0 / framespeed;
                counter_increment = 1L;
                subCounterMax = Math.Max(1, (int)Math.Round(inverse) - 1);
            }
            if(subCounterMax > 0)
            {
                if (_subCounter != subCounterMax)
                    counter_increment = 0; /* otherwise 1 */
                _subCounter++;
                _subCounter = _subCounter % (subCounterMax + 1);
            }
            return counter_increment;
        }

        public void IncrementCounters(MapRefreshRateStyle refreshRateStyle, bool isMainCanvas)
        {
            GHGame curGame = GHApp.CurrentGHGame;
            if (curGame == null)
                return;

            int i;
            long counter_increment = GetAnimationCounterIncrement(refreshRateStyle, isMainCanvas);
            curGame.IncrementCounters(counter_increment);
            long maincountervalue = curGame.MainCounterValue;
            lock (_mapOffsetLock)
            {
                if (_targetClipOn && (maincountervalue < _targetClipStartCounterValue
                    || maincountervalue > _targetClipStartCounterValue + _targetClipPanTime))
                {
                    _targetClipOn = false;
                    _mapOffsetX = 0;
                    _mapOffsetY = 0;
                }

                if (_targetClipOn)
                {
                    _mapOffsetX = _originMapOffsetWithNewClipX * Math.Max(0.0f, 1.0f - (float)(maincountervalue - _targetClipStartCounterValue) / (float)_targetClipPanTime);
                    _mapOffsetY = _originMapOffsetWithNewClipY * Math.Max(0.0f, 1.0f - (float)(maincountervalue - _targetClipStartCounterValue) / (float)_targetClipPanTime);
                }
            }

            lock (_floatingTextLock)
            {
                for (i = _floatingTexts.Count - 1; i >= 0 && i < _floatingTexts.Count; i--)
                {
                    if (_floatingTexts[i].IsFinished(maincountervalue))
                        _floatingTexts.RemoveAt(i);
                }
            }

            lock (_conditionTextLock)
            {
                for (i = _conditionTexts.Count - 1; i >= 0 && i < _conditionTexts.Count; i--)
                {
                    if (_conditionTexts[i].IsFinished(maincountervalue))
                        _conditionTexts.RemoveAt(i);
                }
            }

            lock (_screenFilterLock)
            {
                for (i = _screenFilters.Count - 1; i >= 0 && i < _screenFilters.Count; i--)
                {
                    if (_screenFilters[i].IsFinished(maincountervalue))
                        _screenFilters.RemoveAt(i);
                }
            }

            lock (_guiEffectLock)
            {
                for (i = _guiEffects.Count - 1; i >= 0 && i < _guiEffects.Count; i--)
                {
                    if (_guiEffects[i].IsFinished(maincountervalue))
                        _guiEffects.RemoveAt(i);
                }
            }

            lock (_screenTextLock)
            {
                if (_screenText != null && _screenText.IsFinished(maincountervalue))
                    _screenText = null;
            }
        }

        public void HideLoadingScreen()
        {
            DelayedLoadingScreenHide();
            DelayedFadeFromBlackAtStart();
            //MainGrid.IsVisible = true;
            IsMainCanvasOn = true;
            StartMainCanvasAnimation();
        }

        public void DelayedLoadingScreenHide()
        {
#if GNH_MAUI
            var timer = Microsoft.Maui.Controls.Application.Current.Dispatcher.CreateTimer();
            timer.Interval = TimeSpan.FromSeconds(UIUtils.GetWindowHideSecs());
            timer.IsRepeating = false;
            timer.Tick += (s, e) => { DoHideLoadingScreen(); };
            timer.Start();
#else
            Device.StartTimer(TimeSpan.FromSeconds(UIUtils.GetWindowHideSecs()), () =>
            {
                DoHideLoadingScreen();
                return false;
            });
#endif
        }

        private bool _delayedFadeFromBlackAtStartOn = false;
        public void DelayedFadeFromBlackAtStart()
        {
            _delayedFadeFromBlackAtStartOn = true;
#if GNH_MAUI
            var timer = Microsoft.Maui.Controls.Application.Current.Dispatcher.CreateTimer();
            timer.Interval = TimeSpan.FromSeconds(UIUtils.GetWindowHideSecs() + GHConstants.FadeFromBlackAtStartExtraDelaySecs);
            timer.IsRepeating = false;
            timer.Tick += (s, e) => { DoFadeFromBlackAtStart(); };
            timer.Start();
#else
            Device.StartTimer(TimeSpan.FromSeconds(UIUtils.GetWindowHideSecs() + GHConstants.FadeFromBlackAtStartExtraDelaySecs), () =>
            {
                DoFadeFromBlackAtStart();
                return false;
            });
#endif
        }

        private void DoHideLoadingScreen()
        {
            MainThread.BeginInvokeOnMainThread(() =>
            {
                LoadingGrid.IsVisible = false;
            });
        }
        private void DoFadeFromBlackAtStart()
        {
            try
            {
                MainThread.BeginInvokeOnMainThread(async () =>
                {
                    try
                    { 
                        if (Interlocked.CompareExchange(ref _delayedMenuShow, 0, 1) == 1) // If was originally 1, set to 0
                        {
                            //_delayedMenuShow = false;
                            await DoShowMenuCanvas(DelayedMenuShowDoTextHide);
                        }
                        await FadeFromBlackAtStart(GHConstants.FadeFromBlackDurationAtStart);
                        _delayedFadeFromBlackAtStartOn = false;
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex);
                    }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
            }
        }

        public void DisplayFloatingText(DisplayFloatingTextData data)
        {
            lock (_floatingTextLock)
            {
                bool foundanother = false;
                long highestcounter = 0;
                SKPoint speedvector = new SKPoint(0, -1);
                foreach (GHFloatingText fl in _floatingTexts)
                {
                    if (fl.X == data.x && fl.Y == data.y)
                    {
                        foundanother = true;
                        if (fl.CreatedAt > highestcounter)
                        {
                            highestcounter = fl.CreatedAt;
                            speedvector = fl.GetVelocity(highestcounter);
                        }
                    }
                }

                long counter = 0;
                //lock (AnimationTimerLock)
                //{
                //    counter = Interlocked.CompareExchange(ref AnimationTimers.general_animation_counter, 0L, 0L);;
                //}
                //lock (_mainCounterLock)
                {
                    counter = GHApp.CurrentGHGame?.MainCounterValue ?? 0; // Interlocked.CompareExchange(ref _mainCounterValue, 0L, 0L);
                }

                if (foundanother)
                {
                    float YSpeed = Math.Abs(speedvector.Y);
                    float secs = 0.5f / YSpeed;
                    long ticks = (long)(secs * UIUtils.GetMainCanvasAnimationFrequency(MapRefreshRate));
                    if (counter - highestcounter >= -ticks * 10 && counter - highestcounter < ticks)
                    {
                        counter += ticks - (counter - highestcounter);
                    }
                }

                _floatingTexts.Add(new GHFloatingText(data, counter, this));
            }
        }

        public void DisplayScreenText(DisplayScreenTextData data)
        {
            GHGame curGame = GHApp.CurrentGHGame;
            if (curGame == null)
                return;

            long countervalue;
            //lock (AnimationTimerLock)
            //{
            //    countervalue = Interlocked.CompareExchange(ref AnimationTimers.general_animation_counter, 0L, 0L);;
            //}
            //lock (_mainCounterLock)
            {
                countervalue = curGame.MainCounterValue; // Interlocked.CompareExchange(ref _mainCounterValue, 0L, 0L);
            }
            lock (_screenTextLock)
            {
                _screenText = new GHScreenText(data, countervalue, this);
            }

            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.DisplayScreenText));
        }

        public void DisplayConditionText(DisplayConditionTextData data)
        {
            GHGame curGame = GHApp.CurrentGHGame;
            if (curGame == null)
                return;

            long counter = 0;
            //lock (AnimationTimerLock)
            //{
            //    counter = Interlocked.CompareExchange(ref AnimationTimers.general_animation_counter, 0L, 0L);;
            //}
            //lock (_mainCounterLock)
            {
                counter = curGame.MainCounterValue; // Interlocked.CompareExchange(ref _mainCounterValue, 0L, 0L);
            }

            lock (_conditionTextLock)
            {
                long highestcounter = 0;
                foreach (GHConditionText fl in _conditionTexts)
                {
                    long finishcount = fl.GetFinishCounterValue();
                    if (finishcount > highestcounter)
                    {
                        highestcounter = finishcount;
                    }
                }

                if (highestcounter > 0 && highestcounter > counter)
                {
                    counter = highestcounter;
                }

                _conditionTexts.Add(new GHConditionText(data, counter, this));
            }
        }

        public void DisplayScreenFilter(DisplayScreenFilterData data)
        {
            GHGame curGame = GHApp.CurrentGHGame;
            if (curGame == null)
                return;

            long counter = 0;
            //lock (AnimationTimerLock)
            //{
            //    counter = Interlocked.CompareExchange(ref AnimationTimers.general_animation_counter, 0L, 0L);;
            //}
            //lock (_mainCounterLock)
            {
                counter = curGame.MainCounterValue; // Interlocked.CompareExchange(ref _mainCounterValue, 0L, 0L);
            }

            lock (_screenFilterLock)
            {
                long highestcounter = 0;
                foreach (GHScreenFilter fl in _screenFilters)
                {
                    long finishcount = fl.GetFinishCounterValue();
                    if (finishcount > highestcounter)
                    {
                        highestcounter = finishcount;
                    }
                }

                if (highestcounter > 0 && highestcounter > counter)
                {
                    counter = highestcounter;
                }

                _screenFilters.Add(new GHScreenFilter(data, counter, this));
            }
        }

        public void DisplayGUIEffect(DisplayGUIEffectData data)
        {
            GHGame curGame = GHApp.CurrentGHGame;
            if (curGame == null)
                return;

            long counter = 0;
            //lock (AnimationTimerLock)
            //{
            //    counter = Interlocked.CompareExchange(ref AnimationTimers.general_animation_counter, 0L, 0L);;
            //}
            //lock (_mainCounterLock)
            {
                counter = curGame.MainCounterValue; // Interlocked.CompareExchange(ref _mainCounterValue, 0L, 0L);
            }

            lock (_guiEffectLock)
            {
                foreach (GHGUIEffect eff in _guiEffects)
                {
                    if (eff.X == data.x && eff.Y == data.y)
                    {
                        _guiEffects.Remove(eff);
                        break;
                    }
                }

                _guiEffects.Add(new GHGUIEffect(data, counter, this));
            }
        }


#if GNH_MAUI
        private Color _titleGoldColor = new Color((float)0xD4 / 255, (float)0xA0 / 255, (float)0x17 / 255);
        private Color _popupTransparentBlackColor = new Color(0, 0, 0, (float)0x66 / 255);
        private Color _popupDarkerTransparentBlackColor = new Color(0, 0, 0, (float)0xAA / 255);
#else
        private Color _titleGoldColor = new Color((double)0xD4 / 255, (double)0xA0 / 255, (double)0x17 / 255);
        private Color _popupTransparentBlackColor = new Color(0, 0, 0, (double)0x66 / 255);
        private Color _popupDarkerTransparentBlackColor = new Color(0, 0, 0, (double)0xAA / 255);
#endif
        private GlyphImageSource _popupImageSource = new GlyphImageSource();
        public void DisplayPopupText(DisplayScreenTextData data)
        {
            PopupTitleLabel.Text = data.subtext;
            if ((data.tflags & (ulong)popup_text_flags.POPUP_FLAGS_ADD_QUOTES) != 0)
                PopupLabel.Text = "\"" + data.text + "\"";
            else
                PopupLabel.Text = data.text;

            if (data.style == (int)popup_text_types.POPUP_TEXT_DIALOGUE ||
                data.style == (int)popup_text_types.POPUP_TEXT_ADVICE ||
                data.style == (int)popup_text_types.POPUP_TEXT_MESSAGE ||
                data.style == (int)popup_text_types.POPUP_TEXT_NO_MONSTERS_IN_LIST)
            {
                PopupTitleLabel.TextColor = _titleGoldColor;
                if ((data.tflags & (ulong)popup_text_flags.POPUP_FLAGS_COLOR_TEXT) != 0)
                    PopupLabel.TextColor = UIUtils.NHColor2XColor(data.color, data.attr, false, false);
                else
                    PopupLabel.TextColor = UIUtils.NHColor2XColor((int)NhColor.NO_COLOR, 0, false, false);
                PopupGrid.BackgroundColor = GHColors.Transparent;
                PopupFrame.BackgroundColor = _popupDarkerTransparentBlackColor;
                if (data.glyph != 0 && data.glyph != GHApp.NoGlyph)
                    PopupTitleLayout.HorizontalOptions = LayoutOptions.Start;
                else
                    PopupTitleLayout.HorizontalOptions = LayoutOptions.Center;
            }
            else if (data.style == (int)popup_text_types.POPUP_TEXT_REVIVAL)
            {
                PopupTitleLabel.TextColor = _titleGoldColor;
                if ((data.tflags & (ulong)popup_text_flags.POPUP_FLAGS_COLOR_TEXT) != 0)
                    PopupLabel.TextColor = UIUtils.NHColor2XColor(data.color, data.attr, false, false);
                else
                    PopupLabel.TextColor = UIUtils.NHColor2XColor((int)NhColor.NO_COLOR, 0, false, false);
                PopupGrid.BackgroundColor = _popupTransparentBlackColor;
                PopupFrame.BackgroundColor = _popupTransparentBlackColor;
                PopupTitleLayout.HorizontalOptions = LayoutOptions.Center;
            }
            else
            {
                if ((data.tflags & (ulong)popup_text_flags.POPUP_FLAGS_COLOR_TEXT) != 0)
                {
                    PopupTitleLabel.TextColor = UIUtils.NHColor2XColor((int)NhColor.NO_COLOR, 0, false, true);
                    PopupLabel.TextColor = UIUtils.NHColor2XColor(data.color, data.attr, false, false);
                }
                else
                {
                    PopupTitleLabel.TextColor = UIUtils.NHColor2XColor(data.color, data.attr, false, true);
                    PopupLabel.TextColor = UIUtils.NHColor2XColor((int)NhColor.NO_COLOR, 0, false, false);
                }
                PopupGrid.BackgroundColor = _popupTransparentBlackColor;
                PopupFrame.BackgroundColor = _popupTransparentBlackColor;
                PopupTitleLayout.HorizontalOptions = LayoutOptions.Center;
            }

            PopupImage.Source = null;
            if (data.glyph != 0 && data.glyph != GHApp.NoGlyph)
            {
                _popupImageSource.ReferenceGamePage = this;
                _popupImageSource.UseUpperSide = (data.tflags & (ulong)popup_text_flags.POPUP_FLAGS_UPPER_SIDE) != 0;
                _popupImageSource.Glyph = data.glyph;
                _popupImageSource.AutoSize = true;
                PopupImage.ActiveGlyphImageSource = _popupImageSource;
                PopupImage.IsVisible = true;
            }
            else
            {
                PopupImage.IsVisible = false;
            }
            PopupGrid.IsVisible = true;
        }

        private /*async*/ void ContentPage_Appearing(object sender, EventArgs e)
        {
            GHApp.BackButtonPressed += BackButtonPressed;
            RefreshScreen = true;

            if (PlatformRenderLoopToggled)
            {
                PlatformRenderLoopToggled = false;
                if (GHApp.UsePlatformRenderLoop)
                    StopMainCanvasAnimation(true);
                else
                    StartMainCanvasAnimation(true);
            }

            if (!PlayingReplay)
            {
                GameMenuButton.IsEnabled = true;
                //SimpleGameMenuButton.IsEnabled = true;
                lMoreButton.IsEnabled = true;
            }

            if (_isFirstAppearance)
            {
                _isFirstAppearance = false;
            }
        }

        protected void GNHThreadProc()
        {
            GHGame curGame = new GHGame(RunGnollHackFlags.None);
            //CurrentGame = curGame;
            GHApp.CurrentGHGame = curGame;
            _gnollHackService.StartGnollHack(curGame);
        }

        protected void GNHThreadProcForRestart()
        {
            GHGame curGame = new GHGame(RunGnollHackFlags.ForceLastPlayerName);
            //CurrentGame = curGame;
            GHApp.CurrentGHGame = curGame;
            _gnollHackService.StartGnollHack(curGame);
        }

        protected void GNHThreadProcForReplay()
        {
            GHGame curGame = new GHGame(RunGnollHackFlags.PlayingReplay);
            //CurrentGame = curGame;
            GHApp.CurrentGHGame = curGame;
            GHApp.PlayReplay(curGame, ReplayFileName);
        }

        private void EnqueueTask(ref List<Task> tasks, Task task)
        {
            if (tasks == null)
                tasks = new List<Task>();
            tasks.Add(task);
        }

        private List<Task> PollRequestQueue()
        {
            List<Task> tasks = null;
            GHGame curGame = GHApp.CurrentGHGame;
            if (curGame != null)
            {
                GHRequest req;
                while (curGame.RequestQueue.TryDequeue(out req))
                {
                    try
                    {
                        switch (req.RequestType)
                        {
                            case GHRequestType.PrintHistory:
                                PrintHistory(req.MessageHistory);
                                break;
                            case GHRequestType.PrintHistoryItem:
                                //PrintHistoryItem(req.MessageHistoryItem);
                                break;
                            case GHRequestType.PrintTopLine:
                                PrintTopLine(req.RequestString, req.RequestStringAttributes);
                                break;
                            case GHRequestType.ShowYnResponses:
                                ShowYnResponses(req.RequestInt, req.RequestAttr, req.RequestNhColor, req.RequestGlyph, req.TitleString, req.RequestString, req.Responses, req.ResponseDescriptions, req.IntroLineString, req.RequestFlags);
                                break;
                            case GHRequestType.HideYnResponses:
                                HideYnResponses();
                                break;
                            case GHRequestType.ShowDirections:
                                DoShowDirections();
                                break;
                            case GHRequestType.HideDirections:
                                DoHideDirections();
                                break;
                            case GHRequestType.GetChar:
                                GetChar();
                                break;
                            case GHRequestType.AskName:
                                EnqueueTask(ref tasks, AskName(req.RequestString, req.RequestString2, req.RequestString3));
                                break;
                            case GHRequestType.HideAskNamePage:
                                EnqueueTask(ref tasks, HideAskNamePage());
                                break;
                            case GHRequestType.GetLine:
                                GetLine(req.RequestString, req.PlaceHolderString, req.DefValueString, req.IntroLineString, req.RequestInt, req.RequestAttr, req.RequestNhColor);
                                break;
                            case GHRequestType.HideGetLine:
                                HideGetLine();
                                break;
                            case GHRequestType.EnterGetLineText:
                                EnterGetLineText(req.RequestString);
                                break;
                            case GHRequestType.ReturnToMainMenu:
                                IsGameOn = false;
                                MainGrid.IsEnabled = false;
                                //ClearMap();
                                StopCanvasAnimations();
                                StopTimers();
                                //CurrentGame = null;
                                GHApp.CurrentGHGame = null;
                                GHApp.GameStarted = false;
                                if (PlayingReplay)
                                    DeviceDisplay.KeepScreenOn = false;
                                EnqueueTask(ref tasks, ReturnToMainMenu());
                                break;
                            case GHRequestType.RestartGame:
                                EnqueueTask(ref tasks, RestartGame());
                                break;
                            case GHRequestType.RestartGameUponPageDestruction:
                                EnqueueTask(ref tasks, RestartGameAfterPageDestruction());
                                break;
                            case GHRequestType.RestartReplay:
                                EnqueueTask(ref tasks, RestartReplay());
                                break;
                            case GHRequestType.ShowMenuPage:
                                EnqueueTask(ref tasks, ShowMenuCanvas(req.RequestMenuInfo != null ? req.RequestMenuInfo : new GHMenuInfo(ghmenu_styles.GHMENU_STYLE_GENERAL), req.RequestingGHWindow));
                                break;
                            case GHRequestType.HideMenuPage:
                                EnqueueTask(ref tasks, DelayedMenuHide());
                                break;
                            case GHRequestType.ShowOutRipPage:
                                EnqueueTask(ref tasks, ShowOutRipPage(req.RequestOutRipInfo != null ? req.RequestOutRipInfo : new GHOutRipInfo("", 0, "", ""), req.RequestingGHWindow));
                                break;
                            case GHRequestType.HideOutRipPage:
                                EnqueueTask(ref tasks, HideOutRipPage());
                                break;
                            case GHRequestType.DestroyWindowView:
                                DestroyWindowView(req.RequestInt);
                                break;
                            case GHRequestType.DisplayWindowView:
                                EnqueueTask(ref tasks, DisplayWindowView(req.RequestInt));
                                break;
                            case GHRequestType.HideTextWindow:
                                EnqueueTask(ref tasks, DelayedTextHide());
                                break;
                            case GHRequestType.HideLoadingScreen:
                                HideLoadingScreen();
                                break;
                            case GHRequestType.ClearContextMenu:
                                //ClearContextMenu();
                                break;
                            case GHRequestType.AddContextMenu:
                                //AddContextMenu(req.ContextMenuData);
                                break;
                            case GHRequestType.DisplayFloatingText:
                                DisplayFloatingText(req.FloatingTextData);
                                break;
                            case GHRequestType.DisplayScreenText:
                                DisplayScreenText(req.ScreenTextData);
                                break;
                            case GHRequestType.DisplayPopupText:
                                DisplayPopupText(req.ScreenTextData);
                                break;
                            case GHRequestType.HidePopupText:
                                HidePopupGrid();
                                break;
                            case GHRequestType.DisplayGUIEffect:
                                DisplayGUIEffect(req.GUIEffectData);
                                break;
                            case GHRequestType.ShowSkillButton:
                                //lSkillButton.IsVisible = true;
                                break;
                            case GHRequestType.HideSkillButton:
                                //lSkillButton.IsVisible = false;
                                break;
                            case GHRequestType.FadeToBlack:
                                EnqueueTask(ref tasks, FadeToBlack((uint)req.RequestInt));
                                break;
                            case GHRequestType.FadeFromBlack:
                                EnqueueTask(ref tasks, FadeFromBlack((uint)req.RequestInt));
                                break;
                            case GHRequestType.SetToBlack:
                                SetToBlack();
                                break;
                            case GHRequestType.ShowGUITips:
                                ShowGUITips(true);
                                break;
                            case GHRequestType.CrashReport:
                                EnqueueTask(ref tasks, ReportCrashDetected());
                                break;
                            case GHRequestType.Panic:
                                EnqueueTask(ref tasks, ReportPanic(req.RequestString));
                                break;
                            case GHRequestType.Message:
                                EnqueueTask(ref tasks, ShowMessage(req.RequestString));
                                break;
                            case GHRequestType.YnConfirmation:
                                EnqueueTask(ref tasks, YnConfirmation(req.TitleString, req.RequestString, req.RequestString2, req.DefValueString));
                                break;
                            case GHRequestType.DisplayConditionText:
                                DisplayConditionText(req.ConditionTextData);
                                break;
                            case GHRequestType.DisplayScreenFilter:
                                DisplayScreenFilter(req.ScreenFilterData);
                                break;
                            case GHRequestType.SaveAndDisableTravelMode:
                                _savedMapTravelMode = MapTravelMode;
                                if (MapTravelMode)
                                    ToggleTravelModeButton_Clicked(ToggleTravelModeButton, EventArgs.Empty);
                                break;
                            case GHRequestType.RestoreTravelMode:
                                if (MapTravelMode != _savedMapTravelMode)
                                    ToggleTravelModeButton_Clicked(ToggleTravelModeButton, EventArgs.Empty);
                                break;
                            case GHRequestType.SaveAndDisableTravelModeOnLevel:
                                _savedMapTravelModeOnLevel = MapTravelMode;
                                if (MapTravelMode)
                                    ToggleTravelModeButton_Clicked(ToggleTravelModeButton, EventArgs.Empty);
                                break;
                            case GHRequestType.RestoreTravelModeOnLevel:
                                if (MapTravelMode != _savedMapTravelModeOnLevel)
                                    ToggleTravelModeButton_Clicked(ToggleTravelModeButton, EventArgs.Empty);
                                break;
                            case GHRequestType.PostDiagnosticData:
                                _mainPage.EnqueuePost(new GHPost(0, req.RequestType == GHRequestType.PostGameStatus, req.RequestInt, req.RequestInt2, req.RequestString, null, false));
                                break;
                            case GHRequestType.PostGameStatus:
                                _mainPage.EnqueuePost(new GHPost(0, req.RequestType == GHRequestType.PostGameStatus, req.RequestInt, req.RequestInt2, req.RequestString, null, false));
                                break;
                            case GHRequestType.PostXlogEntry:
                                _mainPage.EnqueuePost(new GHPost(1, true, req.RequestInt, req.RequestInt2, req.RequestString, null, false));
                                break;
                            case GHRequestType.PostBonesFile:
                                _mainPage.EnqueuePost(new GHPost(2, true, req.RequestInt, req.RequestInt2, req.RequestString, null, false));
                                break;
                            case GHRequestType.PostReplayFile:
                                _mainPage.EnqueuePost(new GHPost(3, true, req.RequestInt, req.RequestInt2, req.RequestString, null, false));
                                break;
                            case GHRequestType.DebugLog:
                                WriteDebugLog(req.RequestString, req.RequestInt, req.RequestInt2);
                                break;
                            case GHRequestType.CloseAllDialogs:
                                CloseAllDialogs();
                                break;
                            case GHRequestType.UseLongerMessageHistory:
                                LongerMessageHistory = req.RequestBool;
                                GHApp.SavedLongerMessageHistory = req.RequestBool;
                                break;
                            case GHRequestType.UseHideMessageHistory:
                                HideMessageHistory = req.RequestBool;
                                GHApp.SavedHideMessageHistory = req.RequestBool;
                                break;
                            case GHRequestType.InformRecordingWentOff:
                                GHApp.RecordGame = false;
                                try
                                {
                                    Preferences.Set("RecordGame", false);
                                }
                                catch (Exception ex)
                                {
                                    Debug.WriteLine(ex);
                                }
                                EnqueueTask(ref tasks, InformRecordingWentOff());
                                break;
                            case GHRequestType.ToggleMenuPositionSaving:
                                ToggleMenuPositionSaving(req.RequestInt, req.RequestInt2);
                                break;
                            case GHRequestType.ClipAround:
                                SetTargetClip(req.RequestInt, req.RequestInt2, req.RequestBool, GHApp.CurrentGHGame?.MainCounterValue ?? 0);
                                break;
                            case GHRequestType.GameEnded:
                                GameEnded = true;
                                break;
                            case GHRequestType.ZoomNormal:
                                SetZoomNormal();
                                break;
                            case GHRequestType.ZoomIn:
                                ZoomIn();
                                break;
                            case GHRequestType.ZoomOut:
                                ZoomOut();
                                break;
                            case GHRequestType.ZoomMini:
                                SetZoomMini();
                                break;
                            case GHRequestType.ZoomHalf:
                                SetZoomHalf();
                                break;
                            case GHRequestType.ZoomToScale:
                                break;
                            case GHRequestType.SaveZoom:
                                break;
                            case GHRequestType.RestoreZoom:
                                break;
                            case GHRequestType.SaveFileTrackingSave:
                                EnqueueTask(ref tasks, DoSaveFileTrackingSave(req.RequestLong, req.RequestString, req.RequestLong2, req.RequestString2));
                                break;
                            case GHRequestType.SaveFileTrackingLoad:
                                EnqueueTask(ref tasks, DoSaveFileTrackingLoad(req.RequestLong, req.RequestString, req.RequestLong2, req.RequestString2));
                                break;
                            case GHRequestType.ClearPetData:
                                //ClearPetData();
                                break;
                            case GHRequestType.AddPetData:
                                //AddPetData(req.MonstInfoData);
                                break;
                            case GHRequestType.UpdateGHWindow:
                                UpdateGHWindow(req.RequestInt, req.RequestingGHWindow);
                                break;
                            case GHRequestType.UpdateGHWindowVisibility:
                                UpdateGHWindowVisibility(req.RequestInt, req.RequestBool);
                                break;
                            case GHRequestType.KeyboardFocus:
                                GHApp.DoKeyboardFocus();
                                break;
                        }
                    }
                    catch (Exception ex)
                    {
                        /* Probably we should have a better handling of failed requests, but this is difficult so in order not to get requests that fail continuously, degrading performance */
                        Debug.WriteLine(ex);
                    }
                }
            }
            return tasks;
        }

        private readonly object _localWindowLock = new object();
        private GHWindow[] _localGHWindows = new GHWindow[GHConstants.MaxGHWindows];
        private int _localMapWindowId = 0;
        private int _localMessageWindowId = 0;
        private int _localStatusWindowId = 0;
        public void UpdateGHWindow(int winid, GHWindow ghWindow)
        {
            if (ghWindow == null)
                return;
            if (winid < 0 || winid >= GHConstants.MaxGHWindows)
                return;

            lock (_localWindowLock)
            {
                if (ghWindow.AutoPlacement && _localGHWindows[winid] != null)
                {
                    ghWindow.Left = _localGHWindows[winid].Left;
                    ghWindow.Top = _localGHWindows[winid].Top;
                }
                _localGHWindows[winid] = ghWindow;
                switch(ghWindow.WindowType)
                {
                    case GHWinType.Map:
                        _localMapWindowId = winid;
                        break;
                    case GHWinType.Message:
                        _localMessageWindowId = winid;
                        break;
                    case GHWinType.Status:
                        _localStatusWindowId = winid;
                        break;
                    default:
                        break;
                }
            }
        }
        private void UpdateGHWindowVisibility(int winid, bool isVisible)
        {
            if (winid < 0 || winid >= GHConstants.MaxGHWindows)
                return;

            lock (_localWindowLock)
            {
                if (_localGHWindows[winid] != null)
                    _localGHWindows[winid].Visible = isVisible;
            }
        }
        public void GetWindowIds(out int mapWindowId, out int messageWindowId, out int statusWindowId)
        {
            lock (_localWindowLock)
            {
                mapWindowId = _localMapWindowId;
                messageWindowId = _localMessageWindowId;
                statusWindowId = _localStatusWindowId;
            }
        }

        public async Task DoSaveFileTrackingSave(long timeStamp, string fileName, long fileLength, string sha256hash)
        {
            if (!GHApp.HasInternetAccess)
            {
                await GHApp.DisplayMessageBox(this, "No Internet for Save File Tracking", "You have no internet access. Please switch the internet on before proceeding.", "OK");
            }

            GHGame curGame = GHApp.CurrentGHGame;
            if (string.IsNullOrEmpty(fileName))
            {
                await GHApp.DisplayMessageBox(this, "No File Name for Save File Tracking", "The file name for save file tracking is null or empty. Aborting tracking after saving.", "OK");
                curGame.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SaveFileTrackingSave, 10));
                return;
            }

            SendResult res = await GHApp.SendSaveFileTrackingSaveRequest(this, timeStamp, fileName, fileLength, sha256hash);
            curGame.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SaveFileTrackingSave, res.IsSuccess ? 0 : res.IsException ? 1000 : (int)res.StatusCode));
        }

        public async Task DoSaveFileTrackingLoad(long timeStamp, string fileName, long fileLength, string sha256hash)
        {
            if (!GHApp.HasInternetAccess)
            {
                await GHApp.DisplayMessageBox(this, "No Internet for Save File Tracking", "You have no internet access. Please switch the internet on before proceeding.", "OK");
            }

            GHGame curGame = GHApp.CurrentGHGame;
            if (string.IsNullOrEmpty(fileName))
            {
                await GHApp.DisplayMessageBox(this, "No File Name for Save File Tracking", "The file name for save file tracking is null or empty. Aborting tracking after loading.", "OK");
                curGame.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SaveFileTrackingLoad, 10));
                return;
            }
            if (!File.Exists(fileName + GHConstants.SaveFileTrackingSuffix))
            {
                await GHApp.DisplayMessageBox(this, "No Tracking File for Save File", "The tracking file for the save file \'" + fileName + "' does not exist. Aborting tracking after loading.", "OK");
                curGame.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SaveFileTrackingLoad, 11));
                return;
            }

            SendResult res = await GHApp.SendSaveFileTrackingLoadRequest(this, timeStamp, fileName, fileLength, sha256hash);
            curGame.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SaveFileTrackingLoad, res.IsSuccess ? 0 : res.IsException ? 1000 : (int)res.StatusCode));
        }


        private readonly object _menuPositionLock = new object();
        private bool[] _menuPositionSavingOn = new bool[(int)ghmenu_styles.MAX_GHMENU_STYLES];
        private float[] _savedMenuScrollOffset = new float[(int)ghmenu_styles.MAX_GHMENU_STYLES];

        private void ToggleMenuPositionSaving(int menuStyle, int toggleValue)
        {
            lock (_menuPositionLock)
            {
                _menuPositionSavingOn[menuStyle] = toggleValue != 0;
                _savedMenuScrollOffset[menuStyle] = 0.0f;
            }
        }

        private async Task InformRecordingWentOff()
        {
            await GHApp.DisplayMessageBox(this, "Recording Switched Off", "Game recording has been switched off due to critically low disk space.", "OK");
        }

        private void CloseAllDialogs()
        {
            StopMenuCanvasAnimation();
            StopTextCanvasAnimation();

            TextGrid.IsVisible = false;
            MenuGrid.IsVisible = false;
            MenuWindowGlyphImage.StopAnimation();
            MenuCountGrid.IsVisible = false;
            MenuCountEntry.IsEnabled = false;
            GetLineGrid.IsVisible = false;
            PopupGrid.IsVisible = false;
            TextWindowGlyphImage.StopAnimation();
            YnGrid.IsVisible = false;
            DoHideDirections();

            if (!LoadingGrid.IsVisible && ( !IsMainCanvasOn || /* !MainGrid.IsVisible || */ (!MainCanvasView.AnimationIsRunning("GeneralAnimationCounter") && !GHApp.UsePlatformRenderLoop)))
            {
                //MainGrid.IsVisible = true;
                IsMainCanvasOn = true;
                RefreshScreen = true;
                StartMainCanvasAnimation();
            }
        }

        private void WriteDebugLog(string log_str, int log_type, int log_param)
        {
            if (!string.IsNullOrWhiteSpace(log_str))
            {
                switch (log_type)
                {
                    default:
                    case (int)debug_log_types.DEBUGLOG_GENERAL: /* Both release and debug modes */
                        GHApp.MaybeWriteGHLog(log_str);
                        break;
                    case (int)debug_log_types.DEBUGLOG_DEBUG_ONLY: /* Debug mode only */
#if DEBUG
                        GHApp.MaybeWriteGHLog(log_str);
#endif
                        break;
                    case (int)debug_log_types.DEBUGLOG_FILE_DESCRIPTOR:
                        break;
                }
            }
        }

        private void DestroyWindowView(int winid)
        {
            if (winid < 0 || winid >= GHConstants.MaxGHWindows)
                return;

            GHWindow win = null;
            lock (_localWindowLock)
            {
                win = _localGHWindows[winid];
            }
            if (win != null)
            {
                _localGHWindows[winid] = null;
                win.Visible = false;
                switch (win.WindowType)
                {
                    case GHWinType.Map:
                        _localMapWindowId = 0;
                        break;
                    case GHWinType.Message:
                        _localMessageWindowId = 0;
                        break;
                    case GHWinType.Status:
                        _localStatusWindowId = 0;
                        break;
                    default:
                        break;
                }
            }
        }

        private async Task DisplayWindowView(int winid)
        {
            if (winid < 0 || winid >= GHConstants.MaxGHWindows)
                return;

            GHWindow window = null;
            lock (_localWindowLock)
            {
                window = _localGHWindows[winid];
            }
            if(window != null)
                await ShowWindowCanvas(window);
        }

        private async Task ShowWindowCanvas(GHWindow window)
        {
            List<GHPutStrItem> strs = window.PutStrs;
            /* Cancel delayed text hide */
#if GNH_MAUI
            StopTextHideTimers();
#endif
            //lock (_delayedTextHideLock)
            {
                DelayedTextHideCancelled = true;
            }

            /* Cancel delayed touch hide */
            bool dohidemenu = false;
            //lock(_menuHideCancelledLock)
            {
                if (MenuHideOn)
                {
#if GNH_MAUI
                    StopMenuHideTimers();
#endif
                    MenuHideCancelled = true;
                    dohidemenu = true;
                }
            }

            /* On iOS, hide TextStack to start fade in */
            if (GHApp.IsiOS)
            {
                TextStack.IsVisible = false;
            }

            RefreshScreen = false;

            lock (_textScrollLock)
            {
                _textScrollOffset = 0;
                _textScrollSpeed = 0;
                _textScrollSpeedOn = false;
                _textScrollSpeedRecords.Clear();
                InterlockedTextScrollOffset = _textScrollOffset;
            }

            TextCanvas.RevertBlackAndWhite = !GHApp.DarkMode;

            TextWindowGlyphImage.Source = null;

            _textGlyphImageSource.ReferenceGamePage = this;
            _textGlyphImageSource.AutoSize = true;
            _textGlyphImageSource.ObjData = window.ObjData;
            _textGlyphImageSource.Glyph = window.Glyph;
            _textGlyphImageSource.UseUpperSide = window.UseUpperSide;

            float customScale = GHApp.CustomScreenScale;
            TextWindowGlyphImage.WidthRequest = 75 * customScale;
            TextWindowGlyphImage.HeightRequest = 75 * customScale;
            TextWindowGlyphImage.ActiveGlyphImageSource = TextGlyphImage;
            TextWindowGlyphImage.IsVisible = IsTextGlyphVisible;

            //lock (TextCanvas.TextItemLock)
            {
                List<GHPutStrItem> items = null;
                if (window.WindowStyle == ghwindow_styles.GHWINDOW_STYLE_PAGER_GENERAL || window.WindowStyle == ghwindow_styles.GHWINDOW_STYLE_PAGER_SPEAKER 
                    || window.WindowStyle == ghwindow_styles.GHWINDOW_STYLE_HAS_INDENTED_TEXT || window.WindowStyle == ghwindow_styles.GHWINDOW_STYLE_DISPLAY_FILE_WITH_INDENTED_TEXT)
                {
                    items = new List<GHPutStrItem>();
                    UIUtils.ProcessAdjustedItems(items, strs);
                }
                else
                    items = strs;

                TextTouchDictionary.Clear();
                TextCanvas.GHWindow = window;

                TextCanvas.PutStrItems = items;
            }

            if(PlayingReplay)
            {
                TextStack.IsEnabled = false;
                TextCanvas.IsEnabled = false;
                TextCanvas.EnableTouchEvents = false;
            }

            if (GHApp.IsiOS)
            {
                /* On iOS, fade in the text window. NOTE: this was originally a work-around for bad layout performance on iOS */
#if GNH_MAUI
                var timer = Microsoft.Maui.Controls.Application.Current.Dispatcher.CreateTimer();
                timer.Interval = TimeSpan.FromSeconds(1.0 / 20);
                timer.IsRepeating = false;
                timer.Tick += (s, e) => { DoiOSShowTextStack(dohidemenu); };
                timer.Start();
#else
                Device.StartTimer(TimeSpan.FromSeconds(1.0 / 20), () =>
                {
                    DoiOSShowTextStack(dohidemenu);
                    return false;
                });
#endif
            }
            else
            {
                if (MenuFadeEffects && !MenuGrid.IsVisible && !TextGrid.IsVisible)
                {
                    TextGrid.Opacity = 0;
                    TextGrid.IsVisible = true;
                    await TextGrid.FadeTo(1.0);
                }
                else
                    TextGrid.IsVisible = true;
                //MainGrid.IsVisible = false;
                IsMainCanvasOn = false;
                if (dohidemenu)
                {
                    MenuGrid.IsVisible = false;
                }
            }

            StopMainCanvasAnimation();
            StartTextCanvasAnimation();
        }

        private void DoiOSShowTextStack(bool dohidemenu)
        {
            try
            {
                MainThread.BeginInvokeOnMainThread(async () =>
                {
                    try
                    {
                        TextStack.CancelAnimations();
                        TextStack.Opacity = 0.0;
                        TextStack.IsVisible = true;

                        TextGrid.IsVisible = true;
                        IsMainCanvasOn = false;
                        if (dohidemenu)
                        {
                            MenuGrid.IsVisible = false;
                        }
#if !GNH_MAUI
                        TextStack.ForceLayout();
#endif
                        await TextStack.FadeTo(1.0, 256);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex);
                    }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
            }
        }

        private GlyphImageSource _menuGlyphImageSource = new GlyphImageSource();

        public GlyphImageSource MenuGlyphImage
        {
            get
            {
                return _menuGlyphImageSource;
            }
        }

        public bool IsMenuGlyphVisible
        {
            get
            {
                return (Math.Abs(_menuGlyphImageSource.Glyph) > 0 && _menuGlyphImageSource.Glyph != GHApp.NoGlyph);
            }
        }


        private void PrintTopLine(string str, uint attributes)
        {

        }

        private GlyphImageSource _ynImageSource = new GlyphImageSource();
        private string _ynResponses = null;
        private void ShowYnResponses(int style, int attr, int color, int glyph, string title, string question, string responses, string descriptions, string introline, ulong ynflags)
        {
            string[] descr_list = null;
            if (descriptions != null)
            {
                descr_list = descriptions.Split('\n');
            }

            /* Title Label */
            if (title == null)
            {
                YnTitleLabel.IsVisible = false;
                YnTitleLabel.Text = "";
                YnTitleLabel.TextColor = GHColors.White;
            }
            else
            {
                YnTitleLabel.Text = title;
                YnTitleLabel.IsVisible = true;
                YnQuestionLabel.TextColor = GHColors.White;
                switch (style)
                {
                    case (int)yn_function_styles.YN_STYLE_MONSTER_QUESTION:
                        YnTitleLabel.TextColor = _titleGoldColor;
                        break;
                    default:
                        YnTitleLabel.TextColor = UIUtils.NHColor2XColor(color, attr, false, true);
                        break;
                }
            }

            /* Title Glyph */
            YnImage.Source = null;
            if (glyph != 0 && glyph != GHApp.NoGlyph)
            {
                YnTitleLayout.HorizontalOptions = LayoutOptions.Start;
                _ynImageSource.ReferenceGamePage = this;
                _ynImageSource.UseUpperSide = (ynflags & 1) != 0;
                _ynImageSource.Glyph = glyph;
                _ynImageSource.AutoSize = true;
                YnImage.ActiveGlyphImageSource = _ynImageSource;
                YnImage.IsVisible = true;
            }
            else
            {
                YnTitleLayout.HorizontalOptions = LayoutOptions.Center;
                YnImage.IsVisible = false;
            }

            if (!YnImage.IsVisible && !YnTitleLabel.IsVisible)
                YnTitleLayout.IsVisible = false;
            else
                YnTitleLayout.IsVisible = true;

            string txt;
            /* Question */
            if(!string.IsNullOrWhiteSpace(introline))
                txt = introline + " ";
            else
                txt = "";

            if (!string.IsNullOrWhiteSpace(question))
                txt += question;

            YnQuestionLabel.Text = txt;

            /* Buttons */
            LabeledImageButton[] btnList = { ZeroButton, FirstButton, SecondButton, ThirdButton, FourthButton };
            if (responses == null || responses.Length == 0)
                return;
            else
            {
                for (int i = 0; i < 5; i++)
                {
                    if (i < responses.Length)
                    {
                        btnList[i].BtnLetter = responses[i];
                        if (descriptions != null && descr_list != null && descr_list.Length > i)
                            btnList[i].LblText = descr_list[i];
                        else
                            btnList[i].LblText = btnList[i].BtnLetter.ToString();
                        btnList[i].IsVisible = true;
                    }
                    else
                    {
                        btnList[i].BtnLetter = '?';
                        btnList[i].LblText = "?";
                        btnList[i].IsVisible = false;
                    }
                    btnList[i].ImgSourcePath = GetYnImgSourcePath(btnList[i].BtnLetter, btnList[i].LblText);
                    if (PlayingReplay)
                        btnList[i].IsEnabled = false;
                }
            }
            _ynResponses = responses;

            float inverseCanvasScale = GHApp.DisplayDensity;
            float customScale = GHApp.CustomScreenScale;
            bool usingDesktopButtons = DesktopButtons;
            bool usingSimpleCmdLayout = UseSimpleCmdLayout;
            int stoneButtonRows = StoneButtonGrid.RowDefinitions?.Count ?? 0;
            for (int i = 0; i < 5; i++)
                btnList[i].SetSideSize(_currentPageWidth, _currentPageHeight, usingDesktopButtons, usingSimpleCmdLayout, stoneButtonRows, inverseCanvasScale, customScale);

            YnButtonStack.HeightRequest = btnList[0].GridHeight;
            switch(style)
            {
                case (int)yn_function_styles.YN_STYLE_END:
                    YnGrid.BackgroundColor = GHColors.VeryTransparentBlack;
                    YnFrame.BackgroundColor = GHColors.LessTransparentBlack;
                    break;
                default:
                    YnGrid.BackgroundColor = GHColors.SemiTransparentBlack;
                    YnFrame.BackgroundColor = GHColors.SemiTransparentBlack;
                    break;
            }
            YnGrid.IsVisible = true;
        }

        private string GetYnImgSourcePath(char ch, string desc)
        {
            string res = "resource://" + GHApp.AppResourceName + ".Assets.UI.missing_icon.png";
            switch (ch)
            {
                case 'm':
                    res = "resource://" + GHApp.AppResourceName + ".Assets.UI.name.png";
                    break;
                case 's':
                case 'i':
                    res = "resource://" + GHApp.AppResourceName + ".Assets.UI.inventory.png";
                    break;
                case 'd':
                    if (desc != null && desc.Length >= 4 && desc.Substring(0, 4) == "Drop")
                        res = "resource://" + GHApp.AppResourceName + ".Assets.UI.dropmany.png";
                    else if (desc == "Disarm")
                        res = "resource://" + GHApp.AppResourceName + ".Assets.UI.yes.png";
                    break;
                case 'y':
                    res = "resource://" + GHApp.AppResourceName + ".Assets.UI.yes.png";
                    break;
                case 'n':
                    res = "resource://" + GHApp.AppResourceName + ".Assets.UI.no.png";
                    break;
                case 'q':
                    res = "resource://" + GHApp.AppResourceName + ".Assets.UI.cancel.png";
                    break;
                case 'a':
                    if (desc == "Auto")
                        res = "resource://" + GHApp.AppResourceName + ".Assets.UI.autostash.png";
                    else
                        res = "resource://" + GHApp.AppResourceName + ".Assets.UI.yestoall.png";
                    break;
                case 'r':
                    res = "resource://" + GHApp.AppResourceName + ".Assets.UI.rightring.png";
                    break;
                case 'l':
                    if (desc == "Load")
                        res = "resource://" + GHApp.AppResourceName + ".Assets.UI.load.png";
                    else
                        res = "resource://" + GHApp.AppResourceName + ".Assets.UI.leftring.png";
                    break;
                default:
                    break;
            }
            return res;
        }

        private void HideYnResponses()
        {
            YnGrid.IsVisible = false;
        }
        private void DoShowDirections()
        {
            ShowDirections = true;
            ShowNumberPad = false;
        }
        private void DoHideDirections()
        {
            ShowDirections = false;
            ShowNumberPad = false;
        }
        public void DoShowNumberPad()
        {
            if (!ShowDirections)
                ShowNumberPad = true;
        }

        public void ShowGUITips(bool is_game_start)
        {
            _blockingTipView = is_game_start;
            ShownTip = is_game_start ? 0 : 1;
            TipView.IsVisible = true;
            TipView.InvalidateSurface();
        }
        //private readonly object _msgHistoryLock = new object();
        private GHMsgHistorySpan _msgHistory = null;
        private void PrintHistory(GHMsgHistorySpan msgHistory)
        {
            //lock(_msgHistoryLock)
            //{
            //    _msgHistory = msgHistory;
            //}
            Interlocked.Exchange(ref _msgHistory, msgHistory);
            RefreshMsgHistoryRowCounts = true;
        }

        //private void PrintHistoryItem(GHMsgHistoryItem msgHistoryItem)
        //{
        //    lock (_msgHistoryLock)
        //    {
        //        if (_msgHistory == null)
        //            _msgHistory = new List<GHMsgHistoryItem>(GHConstants.MaxMessageHistoryLength + 1);
        //        _msgHistory.Add(msgHistoryItem);
        //    }
        //    RefreshMsgHistoryRowCounts = true;
        //}

        private async Task AskName(string modeName, string modeDescription, string replayEnteredPlayerName)
        {
            var namePage = new NamePage(this, modeName, modeDescription, replayEnteredPlayerName);
            await GHApp.Navigation.PushModalAsync(namePage);
        }

        private int _getLineStyle = 0;
        private Regex _getLineRegex = null;
        private void GetLine(string query, string placeholder, string linesuffix, string introline, int style, int attr, int color)
        {
#if GNH_MAUI
            GetLineFrame.Stroke = SolidColorBrush.Black;
#else
            GetLineFrame.BorderColor = GHColors.Black;
#endif
            GetLineOkButton.IsEnabled = true;
            GetLineCancelButton.IsEnabled = true;
            GetLineQuestionMarkButton.IsEnabled = true;
            GetLineMenuButton.IsEnabled = true;

            Color clr = UIUtils.NHColor2XColor(color, attr, false, false); /* Non-title / white coloring works better here */
            string PlaceHolderText = null;
            if (!string.IsNullOrWhiteSpace(placeholder) && placeholder.Length > 0)
            {
                PlaceHolderText = char.ToUpper(placeholder[0]) + placeholder.Substring(1);
            }

            if (!string.IsNullOrWhiteSpace(introline))
                GetLineCaption.Text = introline + " ";
            else
                GetLineCaption.Text = "";

            GetLineCaption.Text += query;
            if (!string.IsNullOrWhiteSpace(linesuffix) && linesuffix != " -")
                GetLineCaption.Text += " " + linesuffix;

            GetLineCaption.TextColor = clr;

            GetLineEntryText.Text = "";
            GetLineEntryText.MaxLength = GHConstants.BUFSZ - 1;
            GetLineQuestionMarkButton.IsVisible = false;
            GetLineMenuButton.IsVisible = false;
            GetLineEntryText.IsEnabled = true;
            GetLineEntryText.IsVisible = true;
            GetLineEntryText.Keyboard = Keyboard.Default;
            GetLineEntryText.WidthRequest = 320;
            GetLineAutoComplete.Text = "";
            GetLineAutoComplete.IsVisible = false;

            _getLineStyle = style;
            _getLineRegex = null;
            GetLineCancelButton.Text = "Cancel";

            switch (style)
            {
                case (int)getline_types.GETLINE_EXTENDED_COMMAND:
                    GetLineEntryText.WidthRequest = 230;
                    GetLineQuestionMarkButton.IsVisible = true;
                    GetLineAutoComplete.IsVisible = true;
                    GetLineEntryText.Placeholder = "Type the command";
                    _getLineRegex = new Regex(@"^[A-Za-z0-9_]{0,64}$");
                    break;
                case (int)getline_types.GETLINE_LEVELPORT:
                    GetLineEntryText.Placeholder = "Type the level here";
                    GetLineEntryText.Keyboard = Keyboard.Numeric;
                    _getLineRegex = new Regex(@"^[A-Za-z0-9_? ]{0,32}$");
                    /* '*' could be possible as well, but not implemented at the moment */
                    break;
                case (int)getline_types.GETLINE_WIZ_LEVELPORT:
                    GetLineEntryText.WidthRequest = 230;
                    GetLineQuestionMarkButton.IsVisible = true;
                    GetLineEntryText.Placeholder = "Type the level";
                    GetLineEntryText.Keyboard = Keyboard.Numeric;
                    _getLineRegex = new Regex(@"^[A-Za-z0-9_? ]{0,32}$");
                    break;
                case (int)getline_types.GETLINE_LEVEL_CHANGE:
                case (int)getline_types.GETLINE_NUMBERS_ONLY:
                    GetLineEntryText.WidthRequest = 240;
                    GetLineEntryText.Keyboard = Keyboard.Numeric;
                    if (style == (int)getline_types.GETLINE_LEVEL_CHANGE)
                        GetLineEntryText.Placeholder = "Type the level here";
                    else
                        GetLineEntryText.Placeholder = "Type the number here";
                    _getLineRegex = new Regex(@"^[A-Za-z0-9_? ]{0,32}$");
                    break;
                case (int)getline_types.GETLINE_WISHING:
                    GetLineEntryText.Placeholder = "Type your wish here";
                    _getLineRegex = new Regex(@"^[A-Za-z0-9_ \(\:\)\+\-\'\’]{0,128}$");
                    GetLineCancelButton.Text = "Random";
                    GetLineMenuButton.IsVisible = true;
                    break;
                case (int)getline_types.GETLINE_GENESIS:
                case (int)getline_types.GETLINE_POLYMORPH:
                case (int)getline_types.GETLINE_GENOCIDE:
                case (int)getline_types.GETLINE_MONSTER:
                    GetLineEntryText.Placeholder = "Type the monster here";
                    _getLineRegex = new Regex(@"^[A-Za-z0-9_ \-]{0,64}$");
                    GetLineMenuButton.IsVisible = true;
                    break;
                case (int)getline_types.GETLINE_MONSTER_CLASS:
                    GetLineEntryText.WidthRequest = 230;
                    GetLineEntryText.MaxLength = 1;
                    GetLineQuestionMarkButton.IsVisible = true;
                    GetLineEntryText.Placeholder = "Type the monster class";
                    _getLineRegex = new Regex(@"^[A-Za-z0-9_ \'\&\#\:\;]{0,64}$");
                    GetLineMenuButton.IsVisible = true;
                    break;
                case (int)getline_types.GETLINE_TUNE:
                    GetLineEntryText.WidthRequest = 240;
                    GetLineEntryText.Placeholder = "Type the tune here";
                    _getLineRegex = new Regex(@"^[A-Za-z]{0,10}$");
                    break;
                case (int)getline_types.GETLINE_QUESTION:
                    GetLineEntryText.Placeholder = "Type the answer here";
                    _getLineRegex = new Regex(@"^[A-Za-z0-9_ \$\*\&\.\,\<\>\=\?\!\#\(\:\;\)\+\-\']{0,128}$");
                    break;
                case (int)getline_types.GETLINE_MENU_SEARCH:
                    GetLineEntryText.Placeholder = "Type the search here";
                    _getLineRegex = new Regex(@"^[A-Za-z0-9_ \`\|\~\^\""\'\%\/\\\[\]\{\}\$\*\&\.\,\<\>\=\?\!\#\(\:\;\)\+\-]{0,128}$");
                    break;
                default:
                    if (PlaceHolderText != null)
                        GetLineEntryText.Placeholder = PlaceHolderText;
                    else
                        GetLineEntryText.Placeholder = "Type the text here";
                    _getLineRegex = new Regex(@"^[A-Za-z0-9_ åäöÅÄÖ\$\*\&\.\,\<\>\=\?\!\#\(\:\;\)\+\-]{0,128}$");
                    break;
            }

            if(PlayingReplay)
            {
                GetLineOkButton.IsEnabled = false;
                GetLineCancelButton.IsEnabled = false;
                GetLineQuestionMarkButton.IsEnabled = false;
                GetLineMenuButton.IsEnabled = false;
                //GetLineEntryText.IsEnabled = false;
            }

            GetLineGrid.IsVisible = true;

            if(!PlayingReplay)
            {
                if(GHApp.AutoFocusOnEntry)
                {
#if GNH_MAUI
                    var timer = Microsoft.Maui.Controls.Application.Current.Dispatcher.CreateTimer();
                    timer.Interval = TimeSpan.FromSeconds(GHConstants.KeyboardFocusDelay);
                    timer.IsRepeating = false;
                    timer.Tick += (s, e) => { FocusToGetLineEntry(); };
                    timer.Start();
#else
                    GetLineEntryText.Focus();
#endif
                }
            }
        }
        private void FocusToGetLineEntry()
        {
            MainThread.BeginInvokeOnMainThread(() =>
            {
                GetLineEntryText.Focus();
            });
        }

        private void HideGetLine()
        {
            GetLineGrid.IsVisible = false;
            GetLineEntryText.Text = "";
            GetLineCaption.Text = "";
            GetLineEntryText.IsEnabled = false;
            GetLineEntryText.Unfocus();
        }

        private void EnterGetLineText(string enteredLine)
        {
            if(enteredLine != null)
            {
                GetLineEntryText.Text = enteredLine;
            }
        }

        private void GetLineOkButton_Clicked(object sender, EventArgs e)
        {
            GetLineOkButton.IsEnabled = false;
            GetLineCancelButton.IsEnabled = false;
            GetLineQuestionMarkButton.IsEnabled = false;
            GHApp.PlayButtonClickedSound();

            string res = GetLineEntryText.Text;
            if (string.IsNullOrEmpty(GetLineEntryText.Text))
            {
                res = "";
            }
            else if (string.IsNullOrWhiteSpace(GetLineEntryText.Text))
            {
                res = " ";
            }
            else
            {
                res.Trim();
            }

            if(_getLineRegex != null && !_getLineRegex.IsMatch(res))
            {
#if GNH_MAUI
                GetLineFrame.Stroke = SolidColorBrush.Red;
#else
                GetLineFrame.BorderColor = GHColors.Red;
#endif
                GetLineEntryText.Focus();
                GetLineOkButton.IsEnabled = true;
                GetLineCancelButton.IsEnabled = true;
                GetLineQuestionMarkButton.IsEnabled = true;
                return;
            }
#if GNH_MAUI
            GetLineFrame.Stroke = SolidColorBrush.Black;
#else
            GetLineFrame.BorderColor = GHColors.Black;
#endif

            /* Style-dependent behavior */
            switch (_getLineStyle)
            {
                case (int)getline_types.GETLINE_EXTENDED_COMMAND:
                    res = res.ToLower();
                    break;
                case (int)getline_types.GETLINE_WISHING:
                    if (GHApp.EmptyWishIsNothing && (res == "" || res == " "))
                        res = "nothing";
                    else
                        res = res.Replace("’", "'");
                    break;
                default:
                    break;
            }

            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.GetLine, res));
            HideGetLine();
        }

        private void GetLineQuestionMarkButton_Clicked(object sender, EventArgs e)
        {
            GetLineOkButton.IsEnabled = false;
            GetLineCancelButton.IsEnabled = false;
            GetLineQuestionMarkButton.IsEnabled = false;
            GHApp.PlayButtonClickedSound();

            string res = "?";
            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.GetLine, res));
            HideGetLine();
        }

        private void GetLineCancelButton_Clicked(object sender, EventArgs e)
        {
            GetLineOkButton.IsEnabled = false;
            GetLineCancelButton.IsEnabled = false;
            GetLineQuestionMarkButton.IsEnabled = false;
            GHApp.PlayButtonClickedSound();
            
            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.GetLine, '\x1B'.ToString()));

            HideGetLine();
        }

        private void GetChar()
        {
            // Set focus to GameViewPage
        }

        public bool MainPageBackgroundNeedsUpdate { get; set; }

        private async Task ReturnToMainMenu()
        {
            GHApp.AddSentryBreadcrumb("ReturnToMainMenu", GHConstants.SentryGnollHackGeneralCategoryName);
            try
            {
                /* These need to be returned to their non-game default values */
                GHApp.TournamentMode = Preferences.Get("TournamentMode", false);
                GHApp.SetMirroredOptionsToDefaults();
                /* These need to be set also here in the case game over was fast forwarded */
                Preferences.Set("WentToSleepWithGameOn", false);
                Preferences.Set("GameSaveResult", 0);
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
            }

            StopKeyListening();
            if (MainPageBackgroundNeedsUpdate)
            {
                _mainPage.UpdateMainScreenBackgroundStyle();
                MainPageBackgroundNeedsUpdate = false;
            }
            _mainPage.UpdateLayout();
            _mainPage.ActivateLocalGameButton();
            GHApp.FmodService.UnloadBanks(sound_bank_loading_type.Music);
            if (GHApp.GameMuteMode)
                GHApp.GameMuteMode = false;
            //GHApp.CurrentGamePage = null;
            //GHApp.ReportLockDataResults();
            ShutDownCanvasViews();
            _mainPage.PlayMainScreenVideoAndMusic(); /* Just to be doubly sure */
            bool fastForward = FastForwardRequested;
            if (fastForward && GHApp.IsAndroid) /* FragmentManager cannot deal with closing pages when going to sleep; needs to be done with a delay after returning */
            {
                GHApp.PopAllModalRequested = true;
            }
            else
            {
                await GHApp.PopAllModalPagesAsync(!fastForward);
            }
            if (GHApp.DoAppExitOnReturn)
                _mainPage.ForceCloseApp();
            await _mainPage.StartGeneralTimerAsync(); /* Just to be doubly sure */
        }

        //private readonly object _menuDrawOnlyLock = new object();
        private int _menuDrawOnlyClear = 1;
        private int _menuRefresh = 0;
        private int _delayedMenuShow = 0;
        private int _delayedMenuShowDoTextHide = 0;
        public bool MenuDrawOnlyClear { get { return Interlocked.CompareExchange(ref _menuDrawOnlyClear, 0, 0) != 0; } set { Interlocked.Exchange(ref _menuDrawOnlyClear, value ? 1 : 0); } }
        public bool MenuRefresh { get { return Interlocked.CompareExchange(ref _menuRefresh, 0, 0) != 0; } set { Interlocked.Exchange(ref _menuRefresh, value ? 1 : 0); } }
        public bool DelayedMenuShow { get { return Interlocked.CompareExchange(ref _delayedMenuShow, 0, 0) != 0; } set { Interlocked.Exchange(ref _delayedMenuShow, value ? 1 : 0); } }
        public bool DelayedMenuShowDoTextHide { get { return Interlocked.CompareExchange(ref _delayedMenuShowDoTextHide, 0, 0) != 0; } set { Interlocked.Exchange(ref _delayedMenuShowDoTextHide, value ? 1 : 0); } }

        private async Task ShowMenuCanvas(GHMenuInfo menuinfo, GHWindow ghwindow)
        {
            /* Cancel delayed menu hide */
#if GNH_MAUI
            StopMenuHideTimers();
#endif
            //lock (_menuHideCancelledLock)
            {
                if(MenuHideOn)
                {
                    MenuHideCancelled = true;
                }
            }

            MenuCancelButton.IsEnabled = true;
            /* Enabling OKButton is done below */

            /* On iOS, hide MenuStack to start fade in */
            if (GHApp.IsiOS)
            {
                MenuStack.IsVisible = false;
            }

            /* Cancel delayed text hide */
            bool dohidetext = false;
            //lock(_delayedTextHideLock)
            {
                if(DelayedTextHideOn)
                {
                    DelayedTextHideCancelled = true;
                    dohidetext = true;
                }
            }
            RefreshScreen = false;

            MenuDrawOnlyClear = true;
            MenuRefresh = false;
            //lock (_menuDrawOnlyLock)
            //{
            //    _menuDrawOnlyClear = true;
            //    _menuRefresh = false;
            //}

            GHApp.DebugWriteProfilingStopwatchTimeAndStart("ShowMenuCanvas Start");
            float customScale = GHApp.CustomScreenScale;
            MenuTouchDictionary.Clear();
            lock(_menuScrollLock)
            {
                _menuScrollSpeed = 0;
                _menuScrollSpeedOn = false;
                _menuScrollSpeedRecords.Clear();
            }

            /* Set headers */
            if (menuinfo.Header == null)
            {
                MenuHeaderLabel.IsVisible = true;
                MenuHeaderLabel.Text = " ";
                MenuHeaderLabel.OutlineWidth = 0;
            }
            else
            {
                MenuHeaderLabel.IsVisible = true;
                MenuHeaderLabel.Text = menuinfo.Header;
                MenuHeaderLabel.OutlineWidth = UIUtils.MenuHeaderOutlineWidth(menuinfo.Style);
            }
            MenuHeaderLabel.FontFamily = UIUtils.MenuHeaderFontFamily(menuinfo.Style);
            MenuHeaderLabel.FontSize = UIUtils.MenuHeaderFontSize(menuinfo.Style) * customScale;
            MenuHeaderLabel.TextColor = UIUtils.MenuHeaderTextColor(menuinfo.Style);
            MenuHeaderLabel.OutlineColor = UIUtils.MenuHeaderOutlineColor(menuinfo.Style);

            if (menuinfo.Subtitle == null)
            {
                MenuSubtitleLabel.IsVisible = false;
                MenuSubtitleLabel.Text = "";
                MenuSubtitleLabel.OutlineWidth = 0;
                MenuSubtitleLabel.Margin = new Thickness();
            }
            else
            {
                MenuSubtitleLabel.IsVisible = true;
                MenuSubtitleLabel.Text = menuinfo.Subtitle;
                MenuSubtitleLabel.FontFamily = UIUtils.MenuSubtitleFontFamily(menuinfo.Style);
                MenuSubtitleLabel.FontSize = UIUtils.MenuSubtitleFontSize(menuinfo.Style) * customScale;
                MenuSubtitleLabel.UseSpecialSymbols = UIUtils.MenuSubtitleUsesSpecialSymbols(menuinfo.Style);
                MenuSubtitleLabel.WordWrapSeparator = UIUtils.MenuSubtitleWordWrapSeparator(menuinfo.Style);
                MenuSubtitleLabel.DisplayWrapSeparator = UIUtils.MenuSubtitleDisplayWrapSeparator(menuinfo.Style);
                MenuSubtitleLabel.TextColor = UIUtils.MenuSubtitleTextColor(menuinfo.Style);
                MenuSubtitleLabel.OutlineColor = UIUtils.MenuSubtitleOutlineColor(menuinfo.Style);
                MenuSubtitleLabel.OutlineWidth = UIUtils.MenuSubtitleOutlineWidth(menuinfo.Style);
                MenuSubtitleLabel.Margin = UIUtils.MenuSubtitleMargin(menuinfo.Style, CurrentPageWidth, CurrentPageHeight);
            }

            /* Update canvas */
            MenuCanvas.GHWindow = ghwindow;
            MenuCanvas.MenuStyle = menuinfo.Style;
            MenuCanvas.SelectionHow = menuinfo.SelectionHow;
            MenuCanvas.SelectionIndex = -1;
            if (MenuCanvas.SelectionHow == SelectionMode.Single)
            {
                bool selectedFound = false;
                int idx = -1;
                foreach (GHMenuItem mi in menuinfo.MenuItems)
                {
                    idx++;
                    if (mi.Selected)
                    {
                        mi.Selected = false; /* Clear out, with single selection we are using SelectionIndex */
                        MenuCanvas.SelectionIndex = idx;
                        selectedFound = true;
                        break;
                    }
                }
                MenuOKButton.IsEnabled = selectedFound;
            }
            else
            {
                MenuOKButton.IsEnabled = true;
            }

            switch(menuinfo.Style)
            {
                case ghmenu_styles.GHMENU_STYLE_START_GAME_MENU:
                    MenuBackground.BackgroundStyle = BackgroundStyles.FitToScreen;
                    MenuBackground.BackgroundBitmap = BackgroundBitmaps.LoadingScreen;
                    MenuBackground.BorderStyle = BorderStyles.None;
                    MenuCanvas.RevertBlackAndWhite = false;
                    MenuCanvas.UseTextOutline = true;
                    MenuCanvas.HideMenuLetters = true;
                    MenuCanvas.MenuButtonStyle = true;
                    MenuCanvas.ClickOKOnSelection = true;
                    MenuCanvas.MenuGlyphAtBottom = false;
                    MenuCanvas.AllowLongTap = false;
                    MenuCanvas.SpecialClickOnLongTap = false;
                    MenuCanvas.AllowHighlight = true;
                    break;
                case ghmenu_styles.GHMENU_STYLE_CHOOSE_DIFFICULTY:
                case ghmenu_styles.GHMENU_STYLE_ACCEPT_PLAYER:
                    MenuBackground.BackgroundStyle = BackgroundStyles.Automatic;
                    MenuBackground.BackgroundBitmap = BackgroundBitmaps.AutoMenuBackground;
                    MenuBackground.BorderStyle = BorderStyles.SimpleAlternative;
                    MenuCanvas.RevertBlackAndWhite = !GHApp.DarkMode;
                    MenuCanvas.UseTextOutline = false;
                    MenuCanvas.HideMenuLetters = true;
                    MenuCanvas.MenuButtonStyle = true;
                    MenuCanvas.ClickOKOnSelection = true;
                    MenuCanvas.MenuGlyphAtBottom = true;
                    MenuCanvas.AllowLongTap = false;
                    MenuCanvas.SpecialClickOnLongTap = false;
                    MenuCanvas.AllowHighlight = true;
                    break;
                case ghmenu_styles.GHMENU_STYLE_GENERAL_COMMAND:
                case ghmenu_styles.GHMENU_STYLE_SKILL_COMMAND:
                case ghmenu_styles.GHMENU_STYLE_CHARACTER:
                case ghmenu_styles.GHMENU_STYLE_VIEW_SPELL:
                case ghmenu_styles.GHMENU_STYLE_VIEW_SPELL_ALTERNATE:
                case ghmenu_styles.GHMENU_STYLE_CHAT:
                case ghmenu_styles.GHMENU_STYLE_SKILLS:
                case ghmenu_styles.GHMENU_STYLE_SKILLS_ALTERNATE:
                    MenuBackground.BackgroundStyle = BackgroundStyles.Automatic;
                    MenuBackground.BackgroundBitmap = BackgroundBitmaps.AutoMenuBackground;
                    MenuCanvas.RevertBlackAndWhite = !GHApp.DarkMode;
                    MenuCanvas.UseTextOutline = false;
                    MenuCanvas.HideMenuLetters = false;
                    MenuCanvas.MenuButtonStyle = false;
                    MenuCanvas.ClickOKOnSelection = menuinfo.SelectionHow == SelectionMode.Single;
                    MenuCanvas.MenuGlyphAtBottom = false;
                    MenuBackground.BorderStyle = MenuCanvas.ClickOKOnSelection ? BorderStyles.SimpleAlternative : BorderStyles.Simple;
                    MenuCanvas.AllowLongTap = false;
                    MenuCanvas.SpecialClickOnLongTap = false;
                    MenuCanvas.AllowHighlight = true;
                    break;
                case ghmenu_styles.GHMENU_STYLE_SPELL_COMMAND:
                    MenuBackground.BackgroundStyle = BackgroundStyles.Automatic;
                    MenuBackground.BackgroundBitmap = BackgroundBitmaps.AutoMenuBackground;
                    MenuCanvas.RevertBlackAndWhite = !GHApp.DarkMode;
                    MenuCanvas.UseTextOutline = false;
                    MenuCanvas.HideMenuLetters = false;
                    MenuCanvas.MenuButtonStyle = false;
                    MenuCanvas.ClickOKOnSelection = false;
                    MenuCanvas.MenuGlyphAtBottom = false;
                    MenuBackground.BorderStyle = BorderStyles.Simple;
                    MenuCanvas.AllowLongTap = false;
                    MenuCanvas.SpecialClickOnLongTap = false;
                    MenuCanvas.AllowHighlight = true;
                    break;
                case ghmenu_styles.GHMENU_STYLE_PICK_CATEGORY_LIST:
                    MenuBackground.BackgroundStyle = BackgroundStyles.Automatic;
                    MenuBackground.BackgroundBitmap = BackgroundBitmaps.AutoMenuBackground;
                    MenuBackground.BorderStyle = BorderStyles.Simple;
                    MenuCanvas.RevertBlackAndWhite = !GHApp.DarkMode;
                    MenuCanvas.UseTextOutline = false;
                    MenuCanvas.HideMenuLetters = false;
                    MenuCanvas.MenuButtonStyle = false;
                    MenuCanvas.ClickOKOnSelection = false;
                    MenuCanvas.MenuGlyphAtBottom = false;
                    MenuCanvas.AllowLongTap = false;
                    MenuCanvas.SpecialClickOnLongTap = false;
                    MenuCanvas.AllowHighlight = true;
                    break;
                case ghmenu_styles.GHMENU_STYLE_PICK_ITEM_LIST_AUTO_OK:
                    MenuBackground.BackgroundStyle = BackgroundStyles.Automatic;
                    MenuBackground.BackgroundBitmap = BackgroundBitmaps.AutoMenuBackground;
                    MenuBackground.BorderStyle = BorderStyles.SimpleAlternative;
                    MenuCanvas.RevertBlackAndWhite = !GHApp.DarkMode;
                    MenuCanvas.UseTextOutline = false;
                    MenuCanvas.HideMenuLetters = false;
                    MenuCanvas.MenuButtonStyle = false;
                    MenuCanvas.ClickOKOnSelection = true;
                    MenuCanvas.MenuGlyphAtBottom = false;
                    MenuCanvas.AllowLongTap = false;
                    MenuCanvas.SpecialClickOnLongTap = false;
                    MenuCanvas.AllowHighlight = true;
                    break;
                case ghmenu_styles.GHMENU_STYLE_ITEM_COMMAND:
                case ghmenu_styles.GHMENU_STYLE_PICK_ITEM_LIST:
                    MenuBackground.BackgroundStyle = BackgroundStyles.Automatic;
                    MenuBackground.BackgroundBitmap = BackgroundBitmaps.AutoMenuBackground;
                    MenuBackground.BorderStyle = BorderStyles.Simple;
                    MenuCanvas.RevertBlackAndWhite = !GHApp.DarkMode;
                    MenuCanvas.UseTextOutline = false;
                    MenuCanvas.HideMenuLetters = false;
                    MenuCanvas.MenuButtonStyle = false;
                    MenuCanvas.ClickOKOnSelection = false;
                    MenuCanvas.MenuGlyphAtBottom = false;
                    MenuCanvas.AllowLongTap = true;
                    MenuCanvas.SpecialClickOnLongTap = false;
                    MenuCanvas.AllowHighlight = true;
                    break;
                case ghmenu_styles.GHMENU_STYLE_SPELLS:
                case ghmenu_styles.GHMENU_STYLE_SPELLS_ALTERNATE:
                    MenuBackground.BackgroundStyle = BackgroundStyles.Automatic;
                    MenuBackground.BackgroundBitmap = BackgroundBitmaps.AutoMenuBackground;
                    MenuBackground.BorderStyle = BorderStyles.Simple;
                    MenuCanvas.RevertBlackAndWhite = !GHApp.DarkMode;
                    MenuCanvas.UseTextOutline = false;
                    MenuCanvas.HideMenuLetters = false;
                    MenuCanvas.MenuButtonStyle = false;
                    MenuCanvas.ClickOKOnSelection = false;
                    MenuCanvas.MenuGlyphAtBottom = false;
                    MenuCanvas.AllowLongTap = true;
                    MenuCanvas.SpecialClickOnLongTap = true;
                    MenuCanvas.AllowHighlight = false;
                    break;
                default:
                    MenuBackground.BackgroundStyle = BackgroundStyles.Automatic;
                    MenuBackground.BackgroundBitmap = BackgroundBitmaps.AutoMenuBackground;
                    MenuBackground.BorderStyle = BorderStyles.Simple;
                    MenuCanvas.RevertBlackAndWhite = !GHApp.DarkMode;
                    MenuCanvas.UseTextOutline = false;
                    MenuCanvas.HideMenuLetters = false;
                    MenuCanvas.MenuButtonStyle = false;
                    MenuCanvas.ClickOKOnSelection = false;
                    MenuCanvas.MenuGlyphAtBottom = false;
                    MenuCanvas.AllowLongTap = true;
                    MenuCanvas.SpecialClickOnLongTap = false;
                    MenuCanvas.AllowHighlight = false;
                    break;
            }

            if (MenuCanvas.ClickOKOnSelection && !MenuCanvas.MenuButtonStyle)
            {
                MenuOKButton.Text = "Auto";
                MenuOKButton.Opacity = 0.5;
            }
            else
            {
                MenuOKButton.Text = "OK";
                MenuOKButton.Opacity = 1.0;
            }

            /* Reset glyph */
            MenuWindowGlyphImage.Source = null;

            _menuGlyphImageSource.ReferenceGamePage = this;
            _menuGlyphImageSource.AutoSize = true;
            _menuGlyphImageSource.ObjData = ghwindow.ObjData;
            _menuGlyphImageSource.Glyph = ghwindow.Glyph;
            _menuGlyphImageSource.UseUpperSide = ghwindow.UseUpperSide;

            MenuWindowGlyphImage.WidthRequest = 75 * customScale;
            MenuWindowGlyphImage.HeightRequest = 75 * customScale;
            MenuWindowGlyphImage.ActiveGlyphImageSource = MenuGlyphImage;
            MenuWindowGlyphImage.VerticalOptions = MenuCanvas.MenuGlyphAtBottom ? LayoutOptions.End : LayoutOptions.Start;
            MenuWindowGlyphImage.IsVisible = IsMenuGlyphVisible;

            MenuHeaderLabel.Margin = UIUtils.GetHeaderMarginWithBorder(MenuBackground.BorderStyle, _currentPageWidth, _currentPageHeight);
            MenuCloseGrid.Margin = UIUtils.GetFooterMarginWithBorder(MenuBackground.BorderStyle, _currentPageWidth, _currentPageHeight);
            MenuOKButton.WidthRequest = 135 * customScale;
            MenuOKButton.HeightRequest = 60 * customScale;
            MenuOKButton.FontSize = 20 * customScale;
            MenuCancelButton.WidthRequest = 135 * customScale;
            MenuCancelButton.HeightRequest = 60 * customScale;
            MenuCancelButton.FontSize = 20 * customScale;

            ObservableCollection<GHMenuItem> newmis = new ObservableCollection<GHMenuItem>();
            if (menuinfo != null)
            {
                foreach (GHMenuItem mi in menuinfo.MenuItems)
                {
                    newmis.Add(mi);
                }
            }

            //MainCanvasView.MenuItems = newmis;
            MenuCanvas.MenuItems = newmis;
            //lock (MenuCanvas.MenuItemLock)
            //{
            //    MenuCanvas.MenuItems = newmis;
            //}
            RefreshMenuRowCounts = true;
            _unselectOnTap = false;

            MenuDrawOnlyClear = false;
            MenuRefresh = true;
            //lock (_menuDrawOnlyLock)
            //{
            //    _menuDrawOnlyClear = false;
            //    _menuRefresh = true;
            //}

            lock (_menuPositionLock)
            {
                if (_menuPositionSavingOn[(int)MenuCanvas.MenuStyle])
                {
                    lock(_menuScrollLock)
                    {
                        _menuScrollOffset = _savedMenuScrollOffset[(int)MenuCanvas.MenuStyle];
                        InterlockedMenuScrollOffset = _menuScrollOffset;
                    }
                }
            }

            if (PlayingReplay)
            {
                MenuOKButton.IsEnabled = false;
                MenuCancelButton.IsEnabled = false;
                MenuHeaderLabel.IsEnabled = false;
                MenuStack.IsEnabled = false;
                MenuCanvas.IsEnabled = false;
                MenuCanvas.EnableTouchEvents = false;
            }

            DelayedMenuShow = _delayedFadeFromBlackAtStartOn;
            DelayedMenuShowDoTextHide = dohidetext;

            if (!DelayedMenuShow)
                await DoShowMenuCanvas(dohidetext);

            StopMainCanvasAnimation();
            StartMenuCanvasAnimation();
            GHApp.DebugWriteProfilingStopwatchTimeAndStart("ShowMenuCanvas End");
        }

        private async Task DoShowMenuCanvas(bool dohidetext)
        {
            if (GHApp.IsiOS)
            {
                /* On iOS, fade in the menu. NOTE: this was originally a work-around for bad layout performance on iOS */
#if GNH_MAUI
                var timer = Microsoft.Maui.Controls.Application.Current.Dispatcher.CreateTimer();
                timer.Interval = TimeSpan.FromSeconds(1.0 / 20);
                timer.IsRepeating = false;
                timer.Tick += (s, e) => { DoiOSShowMenuCanvas(dohidetext); };
                timer.Start();
#else
                Device.StartTimer(TimeSpan.FromSeconds(1.0 / 20), () =>
                {
                    DoiOSShowMenuCanvas(dohidetext);
                    return false;
                });
#endif
            }
            else
            {
                if(MenuFadeEffects && !MenuGrid.IsVisible && !TextGrid.IsVisible)
                {
                    MenuGrid.Opacity = 0;
                    MenuGrid.IsVisible = true;
                    await MenuGrid.FadeTo(1.0);
                }
                else
                    MenuGrid.IsVisible = true;

                //MainGrid.IsVisible = false;
                IsMainCanvasOn = false;
                if (dohidetext)
                {
                    TextGrid.IsVisible = false;
                }
            }
        }

        private void DoiOSShowMenuCanvas(bool dohidetext)
        {
            try
            {
                MainThread.BeginInvokeOnMainThread(async () =>
                {
                    try
                    {
                        MenuStack.CancelAnimations();
                        MenuStack.Opacity = 0.0;
                        MenuStack.IsVisible = true;

                        MenuGrid.IsVisible = true;
                        IsMainCanvasOn = false;
                        if (dohidetext)
                        {
                            TextGrid.IsVisible = false;
                        }
#if !GNH_MAUI
                        MenuStack.ForceLayout();
#endif
                        await MenuStack.FadeTo(1.0, 256);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex);
                    }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
            }
        }

        private async Task ShowOutRipPage(GHOutRipInfo outripinfo, GHWindow ghwindow)
        {
            var outRipPage = new OutRipPage(this, ghwindow, outripinfo);
            await GHApp.Navigation.PushModalAsync(outRipPage);
        }
        private async Task HideOutRipPage()
        {
            if (!FastForwardRequested) /* If FastForwardRequested, then this will be handled by GHApp.PopAllModalPages async */
            {
                var page = await GHApp.Navigation.PopModalAsync();
                GHApp.DisconnectIViewHandlers(page);
            }
        }
        private async Task HideAskNamePage()
        {
            var page = await GHApp.Navigation.PopModalAsync();
            GHApp.DisconnectIViewHandlers(page);
        }

        private async Task<bool> BackButtonPressed(object sender, EventArgs e)
        {
            if (MoreCommandsGrid.IsVisible)
            {
                MoreCommandsGrid.IsVisible = false;
                MoreCommandsFilterEntry.Text = "";
                MoreCommandsFilterEntry.Unfocus();
                MoreCommandsFilterEntry.IsEnabled = false;
                //MainGrid.IsVisible = true;
                IsMainCanvasOn = true;
                UpdateMoreNextPrevButtonVisibility(true, true);
                StopCommandCanvasAnimation();
                RefreshScreen = true;
                StartMainCanvasAnimation();
            }
            else if (GetLineGrid.IsVisible)
            {
                GetLineCancelButton_Clicked(sender, e);
            }
            else if (PopupGrid.IsVisible)
            {
                PopupOkButton_Clicked(sender, e);
            }
            else if (YnGrid.IsVisible)
            {
                LabeledImageButton btn;
                if (FourthButton.IsVisible)
                    btn = FourthButton;
                else if (ThirdButton.IsVisible)
                    btn = ThirdButton;
                else if (SecondButton.IsVisible)
                    btn = SecondButton;
                else if (FirstButton.IsVisible)
                    btn = FirstButton;
                else
                    btn = ZeroButton;
                YnButton_Clicked(btn, e);
            }
            else if (TextGrid.IsVisible)
            {
                GenericButton_Clicked(sender, e, GHConstants.CancelChar);
                TextGrid.IsVisible = false;
                //MainGrid.IsVisible = true;
                IsMainCanvasOn = true;
                StopTextCanvasAnimation();
                RefreshScreen = true;
                StartMainCanvasAnimation();
            }
            else if (MenuGrid.IsVisible)
            {
                GHGame curGame = GHApp.CurrentGHGame;
                GHWindow origWindow;
                if (MenuCanvas.GHWindow.ClonedFrom == null)
                    curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.ShowMenuPage, MenuCanvas.GHWindow, new List<GHMenuItem>(), true));
                else if (MenuCanvas.GHWindow.ClonedFrom.TryGetTarget(out origWindow))
                    curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.ShowMenuPage, origWindow, new List<GHMenuItem>(), true));
                else
                    curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.ShowMenuPage, null, new List<GHMenuItem>(), true));
                MenuGrid.IsVisible = false;
                //MainGrid.IsVisible = true;
                IsMainCanvasOn = true;
                StopMenuCanvasAnimation();
                RefreshScreen = true;
                StartMainCanvasAnimation();
            }
            else
            {
                var menu = new GameMenuPage(this);
                SendRequestForTallyRealTime();
                await GHApp.Navigation.PushModalAsync(menu);
            }

            return false;
        }
        public async Task ShowGameMenu()
        {
            var menu = new GameMenuPage(this);
            SendRequestForTallyRealTime();
            await GHApp.Navigation.PushModalAsync(menu);
        }

        private void ContentPage_Disappearing(object sender, EventArgs e)
        {
            PropertyChanged -= GamePage_PropertyChanged;
            SizeChanged -= GamePage_SizeChanged;

            GHApp.BackButtonPressed -= BackButtonPressed;
            RefreshScreen = false;

            MainThread.BeginInvokeOnMainThread(() =>
            {
                try
                {
                    Preferences.Set("MapFontSize", Math.Max(GHConstants.MinimumMapFontSize, MapFontSize));
                    Preferences.Set("MapFontAlternateSize", Math.Max(GHConstants.MinimumMapFontSize, MapFontAlternateSize));
                    Preferences.Set("MapFontMiniRelativeSize", Math.Min(GHConstants.MaximumMapMiniRelativeFontSize, Math.Max(GHConstants.MinimumMapMiniRelativeFontSize, MapFontMiniRelativeSize)));
                    lock (_mapOffsetLock)
                    {
                        Preferences.Set("MapMiniOffsetX", _mapMiniOffsetX);
                        Preferences.Set("MapMiniOffsetY", _mapMiniOffsetY);
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine(ex);
                }
            });
        }


        private SKMaskFilter _blur = SKMaskFilter.CreateBlur(SKBlurStyle.Normal, 3.4f);
        private SKMaskFilter _lookBlur = SKMaskFilter.CreateBlur(SKBlurStyle.Normal, 20.0f);

        public struct layer_draw_order_definition
        {
            public int layer;
            public int enlargement_position;
            public bool darken;
        }

        private readonly object _drawOrderLock = new object();
        private List<layer_draw_order_definition> _draw_order = new List<layer_draw_order_definition>();

        private void SetLayerDrawOrder()
        {
            lock (_drawOrderLock)
            {
                _draw_order.Clear();

                layer_draw_order_definition dodfloor = new layer_draw_order_definition();
                dodfloor.layer = (int)layer_types.LAYER_FLOOR;
                dodfloor.enlargement_position = -1;
                _draw_order.Add(dodfloor);

                layer_draw_order_definition dodcarpet = new layer_draw_order_definition();
                dodcarpet.layer = (int)layer_types.LAYER_CARPET;
                dodcarpet.enlargement_position = -1;
                _draw_order.Add(dodcarpet);

                for (int partition = 0; partition <= 1; partition++)
                {
                    int[] partition_start = { (int)layer_types.LAYER_CARPET + 1, (int)layer_types.LAYER_GENERAL_UI, (int)layer_types.MAX_LAYERS };
                    for (int enl_round = 0; enl_round <= 1; enl_round++)
                    {
                        for (int i = partition_start[partition]; i < partition_start[partition + 1]; i++)
                        {
                            for (int j = 0; j < 3; j++)
                            {
                                int[] pos0 = { 3, -1, 4 };
                                int[] pos1 = { 0, 1, 2 };
                                layer_draw_order_definition dod = new layer_draw_order_definition();
                                dod.layer = i;
                                dod.enlargement_position = enl_round == 0 ? pos0[j] : pos1[j];
                                if (i == partition_start[partition + 1] - 1 && dod.enlargement_position == -1)
                                    dod.darken = true;
                                _draw_order.Add(dod);
                            }
                        }
                    }
                }
                layer_draw_order_definition dodmax = new layer_draw_order_definition();
                dodmax.layer = (int)layer_types.MAX_LAYERS;
                dodmax.enlargement_position = -1;
                _draw_order.Add(dodmax);

                layer_draw_order_definition dodmax1 = new layer_draw_order_definition();
                dodmax1.layer = (int)layer_types.MAX_LAYERS + 1;
                dodmax1.enlargement_position = -1;
                _draw_order.Add(dodmax1);
            }
        }

        private GlyphImageSource _paintGlyphImageSource = new GlyphImageSource();
        private SKBitmap _paintBitmap = new SKBitmap(GHConstants.TileWidth, GHConstants.TileHeight);
        private bool _mainCanvasThreadChecked = false;
        private void canvasView_PaintSurface(object sender, SKPaintSurfaceEventArgs e)
        {
            bool isCanvasOnMainThread = MainThread.IsMainThread;
            if (!_mainCanvasThreadChecked && !isCanvasOnMainThread)
            {
                _mainCanvasThreadChecked = true;
                GHApp.MaybeWriteGHLog("canvasView_PaintSurface not on main thread!");
            }

            if (MenuGrid.ThreadSafeIsVisible || TextGrid.ThreadSafeIsVisible || MoreCommandsGrid.ThreadSafeIsVisible || !IsGameOn)
                return;

            if (IsMainCanvasDrawingAndSetTrue) /* In the case of some sort of reentrancy or new draw before previous is finished */
                return;

            PaintMainGamePage(sender, e, isCanvasOnMainThread);

            if (Interlocked.Increment(ref _mainFPSCounterValue) == long.MaxValue)
                Interlocked.Exchange(ref _mainFPSCounterValue, 0L);
            //lock (_mainFPSCounterLock)
            //{
            //    _mainFPSCounterValue++;
            //    if (_mainFPSCounterValue < 0)
            //        _mainFPSCounterValue = 0;
            //}

            SKImageInfo info = e.Info;
            SKSurface surface = e.Surface;
            SKCanvas canvas = surface.Canvas;

            /* Finally, flush */
            canvas.Flush();
            IsMainCanvasDrawing = false;
        }

        public CanvasTypes GetActiveCanvas()
        {
            CanvasTypes canvasType;
            if (TextGrid.ThreadSafeIsVisible)
                canvasType = CanvasTypes.TextCanvas;
            else if (MenuGrid.ThreadSafeIsVisible)
                canvasType = CanvasTypes.MenuCanvas;
            else if (MoreCommandsGrid.ThreadSafeIsVisible)
                canvasType = CanvasTypes.CommandCanvas;
            else
                canvasType = CanvasTypes.MainCanvas;

            return canvasType;
        }

        public void RenderCanvas()
        {
            RenderCanvasByCanvasType(GetActiveCanvas());
        }

        public void RenderCanvasByCanvasType(CanvasTypes canvasType)
        {
            MapRefreshRateStyle refreshRateStyle = MapRefreshRate;
            switch (canvasType)
            {
                case CanvasTypes.MainCanvas:
                    {
                        IncrementCounters(refreshRateStyle, true);
                        UpdateMainCanvas(refreshRateStyle);
                        break;
                    }
                case CanvasTypes.CommandCanvas:
                    {
                        UpdateCommandCanvas(refreshRateStyle);
                        break;
                    }
                case CanvasTypes.MenuCanvas:
                    {
                        IncrementCounters(refreshRateStyle, false);
                        UpdateMenuCanvas(refreshRateStyle);
                        break;
                    }
                case CanvasTypes.TextCanvas:
                    {
                        IncrementCounters(refreshRateStyle, false);
                        UpdateTextCanvas(refreshRateStyle);
                        break;
                    }
                default:
                    break;
            }
        }

        private float[] _gridIntervals = { 2.0f, 2.0f };

        //public float GetTextScale()
        //{
        //    return UIUtils.CalculateTextScale();
        //}
        //public float GetTextScale()
        //{
        //    //return (float)((StandardReferenceButton.Width <= 0 ? StandardReferenceButton.WidthRequest : StandardReferenceButton.Width) / 50.0f) * GetInverseCanvasScale();
        //    return GetTextScaleEx(MainCanvasView.Width, MainCanvasView.Height, DesktopButtons, UseSimpleCmdLayout);
        //}

        //public float GetTextScaleEx(double canvasViewWidth, double canvasViewHeight, bool usingDesktopButtons, bool usingSimpleCmdLayout)
        //{
        //    return GetTextScaleEx(canvasViewWidth, canvasViewHeight, usingDesktopButtons, usingSimpleCmdLayout, GHApp.DisplayDensity, GHApp.CustomScreenScale);
        //}

        //public float GetTextScaleEx(double canvasViewWidth, double canvasViewHeight, bool usingDesktopButtons, bool usingSimpleCmdLayout, float inverseCanvasScale, float customScale)
        //{
        //    return ((float)UIUtils.CalculateButtonSideWidth(canvasViewWidth, canvasViewHeight, usingDesktopButtons, usingSimpleCmdLayout, inverseCanvasScale, customScale, 0, 0, false) / 50.0f) * inverseCanvasScale;
        //}

        //public float GetTextScaleEx2(float inverseCanvasScale, float customScale)
        //{
        //    return UIUtils.CalculateTextScale(customScale, inverseCanvasScale);
        //}

#if GNH_MAP_PROFILING && DEBUG
        private static Stopwatch _profilingStopwatchBmp = new Stopwatch();
        private static Stopwatch _profilingStopwatchText = new Stopwatch();
        private static Stopwatch _profilingStopwatchRect = new Stopwatch();

        private enum GHProfilingStyle
        {
            Bitmap,
            Text,
            Rect
        }

        private void StartProfiling(GHProfilingStyle style)
        {
            lock(GHApp.ProfilingStopwatchLock)
            {
                switch (style)
                {
                    case GHProfilingStyle.Bitmap:
                        _profilingStopwatchBmp.Start();
                        break;
                    case GHProfilingStyle.Text:
                        _profilingStopwatchText.Start();
                        break;
                    case GHProfilingStyle.Rect:
                        _profilingStopwatchRect.Start();
                        break;
                }
            }
        }

        private void StopProfiling(GHProfilingStyle style)
        {
            lock (GHApp.ProfilingStopwatchLock)
            {
                switch(style)
                {
                    case GHProfilingStyle.Bitmap:
                        _profilingStopwatchBmp.Stop();
                        break;
                    case GHProfilingStyle.Text:
                        _profilingStopwatchText.Stop();
                        break;
                    case GHProfilingStyle.Rect:
                        _profilingStopwatchRect.Stop();
                        break;
                }
            }
        }
#endif

        private void PaintMapUIElements(SKCanvas canvas, GHSkiaFontPaint textPaint, SKPaint paint, SKPathEffect pathEffect, int mapx, int mapy, float width, float height, float offsetX, float offsetY, float usedOffsetX, float usedOffsetY, float base_move_offset_x, float base_move_offset_y, float targetscale, long generalcountervalue, float usedFontSize, float mapFontAscent, int monster_height, bool loc_is_you, bool canspotself, bool usingGL, bool fixRects, bool mapGrid, int gridOpacity, bool hitPointBars, bool playerMark, bool monsterTargeting)
        {
            float scaled_y_height_change = 0;
            //float mapFontAscent = UsedMapFontAscent;
            float tx = 0, ty = 0;
            if (monster_height > 0)
                scaled_y_height_change = (float)-monster_height * height / (float)GHConstants.TileHeight;

            /* Grid */
            if (mapGrid)
            {
                tx = (offsetX + usedOffsetX + width * (float)mapx);
                ty = (offsetY + usedOffsetY + mapFontAscent + height * (float)mapy);

                textPaint.Style = SKPaintStyle.Stroke;
                textPaint.StrokeWidth = 2.0f;
                textPaint.Color = _gridColorArray[gridOpacity];
                textPaint.PathEffect = pathEffect;
                SKPoint p0 = new SKPoint(tx, ty);
                SKPoint p1 = new SKPoint(tx, ty + height);
                canvas.DrawLine(p0, p1, textPaint.Paint);
                SKPoint p2 = new SKPoint(tx + width, ty + height);
                canvas.DrawLine(p1, p2, textPaint.Paint);
                textPaint.PathEffect = null;
                textPaint.Style = SKPaintStyle.Fill;
            }

            /* Chain */
            if(loc_is_you && _uBall != null && _uChain != null)
            {
                tx = (offsetX + usedOffsetX + base_move_offset_x + width * (float)mapx);
                ty = (offsetY + usedOffsetY + base_move_offset_y + mapFontAscent + height * (float)mapy); /* No scaled_y_height_change */
                DrawChain(canvas, paint, mapx, mapy, 0, true, width, height, ty, tx, 1.0f, targetscale, usingGL, false, fixRects);
            }

            /* Cursor */
            bool cannotseeself = (loc_is_you && !canspotself);
            if ((!loc_is_you || (loc_is_you && (cannotseeself || _show_cursor_on_u)))
                && (mapx == _localMapCursorX && mapy == _localMapCursorY)
                )
            {
                int cidx = (cannotseeself && _cursorType == game_cursor_types.CURSOR_STYLE_GENERIC_CURSOR ?
                    (int)game_cursor_types.CURSOR_STYLE_INVISIBLE :
                    (int)_cursorType);
                int cglyph = cidx + GHApp.CursorOff;
                int ctile = GHApp.Glyph2Tile[cglyph];
                int animation = GHApp.Tile2Animation[ctile];
                int autodraw = GHApp.Tile2Autodraw[ctile];
                int anim_frame_idx = 0, main_tile_idx = 0;
                sbyte mapAnimated = 0;
                int tile_animation_idx = _gnollHackService.GetTileAnimationIndexFromGlyph(cglyph);
                ctile = _gnollHackService.GetAnimatedTile(ctile, tile_animation_idx, (int)animation_play_types.ANIMATION_PLAY_TYPE_ALWAYS, generalcountervalue, out anim_frame_idx, out main_tile_idx, out mapAnimated, ref autodraw);
                int sheet_idx = GHApp.TileSheetIdx(ctile);
                int tile_x = GHApp.TileSheetX(ctile);
                int tile_y = GHApp.TileSheetY(ctile);

                tx = (offsetX + usedOffsetX + (loc_is_you ? base_move_offset_x : 0) + width * (float)mapx);
                ty = (offsetY + usedOffsetY + (loc_is_you ? base_move_offset_y : 0) + scaled_y_height_change + mapFontAscent + height * (float)mapy);
                SKRect targetrect = new SKRect(tx, ty, tx + width, ty + height);
                SKRect sourcerect = new SKRect(tile_x, tile_y, tile_x + GHConstants.TileWidth, tile_y + GHConstants.TileHeight);
#if GNH_MAP_PROFILING && DEBUG
                StartProfiling(GHProfilingStyle.Bitmap);
#endif
                GHApp.MaybeFixRects(ref sourcerect, ref targetrect, targetscale, usingGL, fixRects);
                canvas.DrawImage(TileMap[sheet_idx], sourcerect, targetrect);
#if GNH_MAP_PROFILING && DEBUG
                StopProfiling(GHProfilingStyle.Bitmap);
#endif
            }

            /* General tx, ty for all others, except cursors */
            tx = (offsetX + usedOffsetX + base_move_offset_x + width * (float)mapx);
            ty = (offsetY + usedOffsetY + base_move_offset_y + scaled_y_height_change + mapFontAscent + height * (float)mapy);

            if (hitPointBars)
            {
                /* Draw hit point bars */
                if (((_mapData[mapx, mapy].Layers.monster_flags & (ulong)(LayerMonsterFlags.LMFLAGS_YOU | LayerMonsterFlags.LMFLAGS_CANSPOTMON)) != 0 || (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_UXUY) != 0)
                && (_mapData[mapx, mapy].Layers.monster_flags & (ulong)(LayerMonsterFlags.LMFLAGS_WORM_TAIL)) == 0
                && _mapData[mapx, mapy].Layers.monster_maxhp > 0)
                {
                    int hp = _mapData[mapx, mapy].Layers.monster_hp;
                    int hpmax = _mapData[mapx, mapy].Layers.monster_maxhp;
                    float fraction = (hpmax == 0 ? 0 : Math.Max(0, Math.Min(1, (float)hp / (float)hpmax)));
                    float r_mult = fraction <= 0.25f ? fraction * 2.0f + 0.5f : fraction <= 0.5f ? 1.0f : (1.0f - fraction) * 2.0f;
                    float g_mult = fraction <= 0.25f ? 0 : fraction <= 0.5f ? (fraction - 0.25f) * 4.0f : 1.0f;
                    SKColor clr = new SKColor((byte)(255.0f * r_mult), (byte)(255.0f * g_mult), 0);
                    SKRect smaller_rect = new SKRect();
                    SKRect even_smaller_rect = new SKRect();
                    smaller_rect.Bottom = ty + height;
                    smaller_rect.Top = ty + height - Math.Max(1f, (height) / 12);
                    smaller_rect.Left = tx;
                    smaller_rect.Right = tx + width;
                    even_smaller_rect.Bottom = smaller_rect.Bottom - 1 * targetscale;
                    even_smaller_rect.Top = smaller_rect.Top + 1 * targetscale;
                    even_smaller_rect.Left = smaller_rect.Left + 1 * targetscale;
                    even_smaller_rect.Right = even_smaller_rect.Left + (fraction * (smaller_rect.Right - 1 * targetscale - even_smaller_rect.Left));

                    paint.Style = SKPaintStyle.Fill;
                    paint.Color = SKColors.Black;
                    canvas.DrawRect(smaller_rect, paint);
                    paint.Color = clr;
                    canvas.DrawRect(even_smaller_rect, paint);
                }
            }

            /* Chain lock mark */
            if (loc_is_you && _uBall != null && _uChain != null)
            {
                int mglyph = (int)game_ui_tile_types.ITEM_AUTODRAW_GRAPHICS + GHApp.UITileOff;
                int mtile = GHApp.Glyph2Tile[mglyph];
                int m_sheet_idx = GHApp.TileSheetIdx(mtile);
                int source_x = GHApp.TileSheetX(mtile) + 0;
                int source_y = GHApp.TileSheetY(mtile) + 64;
                int source_width = 32;
                int source_height = 32;
                float target_x = tx + 2.0f * targetscale;
                float target_y = ty + height - (float)(source_height + 2) * targetscale;
                float target_width = (float)source_width * targetscale;
                float target_height = (float)source_height * targetscale;
                SKRect sourcerect = new SKRect(source_x, source_y, source_x + source_width, source_y + source_height);
                SKRect targetrect = new SKRect(target_x, target_y, target_x + target_width, target_y + target_height);
#if GNH_MAP_PROFILING && DEBUG
                StartProfiling(GHProfilingStyle.Bitmap);
#endif
                GHApp.MaybeFixRects(ref sourcerect, ref targetrect, targetscale, usingGL, fixRects);
                canvas.DrawImage(TileMap[m_sheet_idx], sourcerect, targetrect);
#if GNH_MAP_PROFILING && DEBUG
                StopProfiling(GHProfilingStyle.Bitmap);
#endif
            }

            bool draw_character = false;
            /* Player mark */
            if (playerMark && loc_is_you)
            {
                int cglyph = (int)game_ui_tile_types.U_TILE_MARK + GHApp.UITileOff;
                int ctile = GHApp.Glyph2Tile[cglyph];
                int animation = GHApp.Tile2Animation[ctile];
                int autodraw = GHApp.Tile2Autodraw[ctile];
                int anim_frame_idx = 0, main_tile_idx = 0;
                sbyte mapAnimated = 0;
                int tile_animation_idx = _gnollHackService.GetTileAnimationIndexFromGlyph(cglyph);
                ctile = _gnollHackService.GetAnimatedTile(ctile, tile_animation_idx, (int)animation_play_types.ANIMATION_PLAY_TYPE_ALWAYS, generalcountervalue, out anim_frame_idx, out main_tile_idx, out mapAnimated, ref autodraw);
                int sheet_idx = GHApp.TileSheetIdx(ctile);
                int tile_x = GHApp.TileSheetX(ctile);
                int tile_y = GHApp.TileSheetY(ctile);

                SKRect targetrect = new SKRect(tx, ty, tx + width, ty + height);
                SKRect sourcerect = new SKRect(tile_x, tile_y, tile_x + GHConstants.TileWidth, tile_y + GHConstants.TileHeight);
                GHApp.MaybeFixRects(ref sourcerect, ref targetrect, targetscale, usingGL, fixRects);
                canvas.DrawImage(TileMap[sheet_idx], sourcerect, targetrect);

                if (_mapData[mapx, mapy].Symbol != null && _mapData[mapx, mapy].Symbol != "")
                {
                    draw_character = true;
                }
            }

            /* Monster targeting mark */
            if (monsterTargeting && !loc_is_you && (_mapData[mapx, mapy].Layers.monster_flags & (ulong)(LayerMonsterFlags.LMFLAGS_CANSPOTMON)) != 0)
            {
                int cglyph = (int)game_ui_tile_types.MAIN_TILE_MARK + GHApp.UITileOff;
                int ctile = GHApp.Glyph2Tile[cglyph];
                int animation = GHApp.Tile2Animation[ctile];
                int autodraw = GHApp.Tile2Autodraw[ctile];
                int anim_frame_idx = 0, main_tile_idx = 0;
                sbyte mapAnimated = 0;
                int tile_animation_idx = _gnollHackService.GetTileAnimationIndexFromGlyph(cglyph);
                ctile = _gnollHackService.GetAnimatedTile(ctile, tile_animation_idx, (int)animation_play_types.ANIMATION_PLAY_TYPE_ALWAYS, generalcountervalue, out anim_frame_idx, out main_tile_idx, out mapAnimated, ref autodraw);
                int sheet_idx = GHApp.TileSheetIdx(ctile);
                int tile_x = GHApp.TileSheetX(ctile);
                int tile_y = GHApp.TileSheetY(ctile);

                SKRect targetrect = new SKRect(tx, ty, tx + width, ty + height);
                SKRect sourcerect = new SKRect(tile_x, tile_y, tile_x + GHConstants.TileWidth, tile_y + GHConstants.TileHeight);
                GHApp.MaybeFixRects(ref sourcerect, ref targetrect, targetscale, usingGL, fixRects);
                canvas.DrawImage(TileMap[sheet_idx], sourcerect, targetrect);

                if (_mapData[mapx, mapy].Symbol != null && _mapData[mapx, mapy].Symbol != "")
                {
                    draw_character = true;
                }
            }

            if (draw_character)
            {
                textPaint.TextSize = usedFontSize / 4;
                textPaint.Typeface = GHApp.DejaVuSansMonoTypeface;
                textPaint.Color = _mapData[mapx, mapy].Color;
                //textPaint.TextAlign = SKTextAlign.Center;
                float textheight = textPaint.FontSpacing; // FontMetrics.Descent - textPaint.FontMetrics.Ascent;
                float texttx = tx + width / 2;
                float textty = ty + height / 2 - textheight / 2 - textPaint.FontMetrics.Ascent - 1f / 96f * height;
                //canvas.DrawText(_mapData[mapx, mapy].Symbol, texttx, textty, textPaint);
                textPaint.DrawTextOnCanvas(canvas, _mapData[mapx, mapy].Symbol, texttx, textty, SKTextAlign.Center);
                //textPaint.TextAlign = SKTextAlign.Left;
            }

            if (((_mapData[mapx, mapy].Layers.monster_flags & (ulong)(LayerMonsterFlags.LMFLAGS_YOU | LayerMonsterFlags.LMFLAGS_CANSPOTMON)) != 0 || (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_UXUY) != 0)
                && (_mapData[mapx, mapy].Layers.monster_flags & (ulong)(LayerMonsterFlags.LMFLAGS_WORM_TAIL)) == 0)
            {
                /* Draw condition and status marks */
                float x_scaling_factor = width / (float)(GHConstants.TileWidth);
                float y_scaling_factor = height / (float)(GHConstants.TileHeight);
                int max_fitted_rows = (GHConstants.TileHeight - 4) / (GHConstants.StatusMarkHeight + 2);
                int status_count = 0;

                ulong status_bits = _mapData[mapx, mapy].Layers.status_bits;
                if (status_bits != 0)
                {
                    foreach (int status_mark in _statusmarkorder)
                    {
                        if (status_count >= max_fitted_rows)
                            break;

                        ulong statusbit = 1UL << status_mark;
                        if ((status_bits & statusbit) != 0)
                        {
                            int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                            int mglyph = (int)game_ui_tile_types.STATUS_MARKS + status_mark / GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS + GHApp.UITileOff;
                            int mtile = GHApp.Glyph2Tile[mglyph];
                            int sheet_idx = GHApp.TileSheetIdx(mtile);
                            int tile_x = GHApp.TileSheetX(mtile);
                            int tile_y = GHApp.TileSheetY(mtile);
                            int within_tile_x = (status_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) % tiles_per_row;
                            int within_tile_y = (status_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) / tiles_per_row;
                            int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                            int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                            SKRect source_rt = new SKRect();
                            source_rt.Left = c_x;
                            source_rt.Right = c_x + GHConstants.StatusMarkWidth;
                            source_rt.Top = c_y;
                            source_rt.Bottom = c_y + GHConstants.StatusMarkHeight;

                            /* Define draw location in target */
                            int unscaled_left = GHConstants.TileWidth - 2 - GHConstants.StatusMarkWidth;
                            int unscaled_right = unscaled_left + GHConstants.StatusMarkWidth;
                            int unscaled_top = 2 + (2 + GHConstants.StatusMarkWidth) * status_count;
                            int unscaled_bottom = unscaled_top + GHConstants.StatusMarkHeight;

                            SKRect target_rt = new SKRect();
                            target_rt.Left = tx + (int)(x_scaling_factor * (double)unscaled_left);
                            target_rt.Right = tx + (int)(x_scaling_factor * (double)unscaled_right);
                            target_rt.Top = ty + (int)(y_scaling_factor * (double)unscaled_top);
                            target_rt.Bottom = ty + (int)(y_scaling_factor * (double)unscaled_bottom);
#if GNH_MAP_PROFILING && DEBUG
                            StartProfiling(GHProfilingStyle.Bitmap);
#endif
                            GHApp.MaybeFixRects(ref source_rt, ref target_rt, targetscale, usingGL, fixRects);
                            canvas.DrawImage(TileMap[sheet_idx], source_rt, target_rt);
#if GNH_MAP_PROFILING && DEBUG
                            StopProfiling(GHProfilingStyle.Bitmap);
#endif
                            status_count++;
                        }
                    }
                }

                ulong condition_bits = _mapData[mapx, mapy].Layers.condition_bits;
                if (condition_bits != 0)
                {
                    int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                    for (int condition_mark = 0; condition_mark < (int)bl_conditions.NUM_BL_CONDITIONS; condition_mark++)
                    {
                        if (status_count >= max_fitted_rows)
                            break;

                        ulong conditionbit = 1UL << condition_mark;
                        if ((condition_bits & conditionbit) != 0)
                        {
                            int mglyph = (int)game_ui_tile_types.CONDITION_MARKS + condition_mark / GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS + GHApp.UITileOff;
                            int mtile = GHApp.Glyph2Tile[mglyph];
                            int sheet_idx = GHApp.TileSheetIdx(mtile);
                            int tile_x = GHApp.TileSheetX(mtile);
                            int tile_y = GHApp.TileSheetY(mtile);
                            int within_tile_x = (condition_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) % tiles_per_row;
                            int within_tile_y = (condition_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) / tiles_per_row;
                            int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                            int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                            SKRect source_rt = new SKRect();
                            source_rt.Left = c_x;
                            source_rt.Right = c_x + GHConstants.StatusMarkWidth;
                            source_rt.Top = c_y;
                            source_rt.Bottom = c_y + GHConstants.StatusMarkHeight;

                            /* Define draw location in target */
                            int unscaled_left = GHConstants.TileWidth - 2 - GHConstants.StatusMarkWidth;
                            int unscaled_right = unscaled_left + GHConstants.StatusMarkWidth;
                            int unscaled_top = 2 + (2 + GHConstants.StatusMarkWidth) * status_count;
                            int unscaled_bottom = unscaled_top + GHConstants.StatusMarkHeight;

                            SKRect target_rt = new SKRect();
                            target_rt.Left = tx + (int)(x_scaling_factor * (double)unscaled_left);
                            target_rt.Right = tx + (int)(x_scaling_factor * (double)unscaled_right);
                            target_rt.Top = ty + (int)(y_scaling_factor * (double)unscaled_top);
                            target_rt.Bottom = ty + (int)(y_scaling_factor * (double)unscaled_bottom);
#if GNH_MAP_PROFILING && DEBUG
                            StartProfiling(GHProfilingStyle.Bitmap);
#endif
                            GHApp.MaybeFixRects(ref source_rt, ref target_rt, targetscale, usingGL, fixRects);
                            canvas.DrawImage(TileMap[sheet_idx], source_rt, target_rt);
#if GNH_MAP_PROFILING && DEBUG
                            StopProfiling(GHProfilingStyle.Bitmap);
#endif
                            status_count++;
                        }
                    }
                }

                for (int buff_ulong = 0; buff_ulong < GHConstants.NUM_BUFF_BIT_ULONGS; buff_ulong++)
                {
                    if (status_count >= max_fitted_rows)
                        break;

                    ulong buff_bits = _mapData[mapx, mapy].Layers.buff_bits[buff_ulong];
                    int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                    if (buff_bits != 0)
                    {
                        for (int buff_idx = 0; buff_idx < 32; buff_idx++)
                        {
                            if (status_count >= max_fitted_rows)
                                break;

                            ulong buffbit = 1UL << buff_idx;
                            if ((buff_bits & buffbit) != 0)
                            {
                                int propidx = buff_ulong * 32 + buff_idx;
                                if (propidx > GHConstants.LAST_PROP)
                                    break;
                                int mglyph = (propidx - 1) / GHConstants.BUFFS_PER_TILE + GHApp.BuffTileOff;
                                int mtile = GHApp.Glyph2Tile[mglyph];
                                int sheet_idx = GHApp.TileSheetIdx(mtile);
                                int tile_x = GHApp.TileSheetX(mtile);
                                int tile_y = GHApp.TileSheetY(mtile);

                                int buff_mark = (propidx - 1) % GHConstants.BUFFS_PER_TILE;
                                int within_tile_x = buff_mark % tiles_per_row;
                                int within_tile_y = buff_mark / tiles_per_row;
                                int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                                int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                                SKRect source_rt = new SKRect();
                                source_rt.Left = c_x;
                                source_rt.Right = c_x + GHConstants.StatusMarkWidth;
                                source_rt.Top = c_y;
                                source_rt.Bottom = c_y + GHConstants.StatusMarkHeight;

                                /* Define draw location in target */
                                int unscaled_left = GHConstants.TileWidth - 2 - GHConstants.StatusMarkWidth;
                                int unscaled_right = unscaled_left + GHConstants.StatusMarkWidth;
                                int unscaled_top = 2 + (2 + GHConstants.StatusMarkWidth) * status_count;
                                int unscaled_bottom = unscaled_top + GHConstants.StatusMarkHeight;

                                SKRect target_rt = new SKRect();
                                target_rt.Left = tx + (int)(x_scaling_factor * (double)unscaled_left);
                                target_rt.Right = tx + (int)(x_scaling_factor * (double)unscaled_right);
                                target_rt.Top = ty + (int)(y_scaling_factor * (double)unscaled_top);
                                target_rt.Bottom = ty + (int)(y_scaling_factor * (double)unscaled_bottom);

#if GNH_MAP_PROFILING && DEBUG
                                StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                GHApp.MaybeFixRects(ref source_rt, ref target_rt, targetscale, usingGL, fixRects);
                                canvas.DrawImage(TileMap[sheet_idx], source_rt, target_rt);
#if GNH_MAP_PROFILING && DEBUG
                                StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                status_count++;
                            }
                        }
                    }
                }
            }

            /* Draw death and hit markers */
            if ((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_KILLED) != 0)
            {
                int mglyph = (int)general_tile_types.GENERAL_TILE_DEATH + GHApp.GeneralTileOff;
                int mtile = GHApp.Glyph2Tile[mglyph];
                int sheet_idx = GHApp.TileSheetIdx(mtile);
                int tile_x = GHApp.TileSheetX(mtile);
                int tile_y = GHApp.TileSheetY(mtile);

                SKRect targetrect = new SKRect(tx, ty, tx + width, ty + height);
                SKRect sourcerect = new SKRect(tile_x, tile_y, tile_x + GHConstants.TileWidth, tile_y + GHConstants.TileHeight);
                GHApp.MaybeFixRects(ref sourcerect, ref targetrect, targetscale, usingGL, fixRects);
                canvas.DrawImage(TileMap[sheet_idx], sourcerect, targetrect);
            }
            else if ((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_BEING_HIT) != 0)
            {
                short hit_text_num = _mapData[mapx, mapy].Layers.hit_tile;
                int mglyph = Math.Max(0, Math.Min((int)hit_tile_types.MAX_HIT_TILES - 1, (int)hit_text_num)) + GHApp.HitTileOff;
                int mtile = GHApp.Glyph2Tile[mglyph];
                int sheet_idx = GHApp.TileSheetIdx(mtile);
                int tile_x = GHApp.TileSheetX(mtile);
                int tile_y = GHApp.TileSheetY(mtile);

                SKRect targetrect = new SKRect(tx, ty, tx + width, ty + height);
                SKRect sourcerect = new SKRect(tile_x, tile_y, tile_x + GHConstants.TileWidth, tile_y + GHConstants.TileHeight);
                GHApp.MaybeFixRects(ref sourcerect, ref targetrect, targetscale, usingGL, fixRects);
                canvas.DrawImage(TileMap[sheet_idx], sourcerect, targetrect);
            }
        }


        private void PaintMapTile(SKCanvas canvas, bool delayedDraw, GHSkiaFontPaint textPaint, SKPaint paint, int layer_idx, int mapx, int mapy, int draw_map_x, int draw_map_y, int dx, int dy, int ntile, float width, float height, 
            float offsetX, float offsetY, float usedOffsetX, float usedOffsetY, float base_move_offset_x, float base_move_offset_y, float object_move_offset_x, float object_move_offset_y,
            float scaled_y_height_change, float pit_border,
            float targetscale, long generalcountervalue, float usedFontSize, float mapFontAscent, int monster_height, 
            bool is_monster_like_layer, bool is_object_like_layer, bool obj_in_pit, int obj_height, bool is_missile_layer, int missile_height,
            bool loc_is_you, bool canspotself, bool tileflag_halfsize, bool tileflag_normalobjmissile, bool tileflag_fullsizeditem, bool tileflag_floortile, bool tileflag_height_is_clipping,
            bool hflip_glyph, bool vflip_glyph,
            ObjectDataItem otmp_round, int autodraw, bool drawwallends, bool breatheanimations, long generalcounterdiff, float canvaswidth, float canvasheight, int enlargement, bool usingGL, bool usingMipMap, bool fixRects, 
            bool pointerIsHoveringOnTile, bool mapLookMode) //, ref float minDrawX, ref float maxDrawX, ref float minDrawY, ref float maxDrawY,
            //ref float enlMinDrawX, ref float enlMaxDrawX, ref float enlMinDrawY, ref float enlMaxDrawY)
        {
            if (!GHUtils.isok(draw_map_x, draw_map_y))
                return;

            float tx = 0, ty = 0;
            if(_draw_shadow != null)
            {
                if (dx != 0 || dy != 0)
                {
                    _draw_shadow[draw_map_x, draw_map_y] |= 1;
                }
            }

            int sheet_idx = GHApp.TileSheetIdx(ntile);
            int tile_x = GHApp.TileSheetX(ntile);
            int tile_y = GHApp.TileSheetY(ntile);

            SKRect sourcerect;
            float scaled_tile_width = width;
            float scaled_tile_height = tileflag_halfsize || (tileflag_normalobjmissile && !tileflag_fullsizeditem) ? height / 2 : height;
            float scaled_x_padding = 0;
            float scaled_y_padding = 0;
            int source_y_added = 0;
            int source_height_deducted = 0;
            int source_height = tileflag_halfsize ? GHConstants.TileHeight / 2 : GHConstants.TileHeight;
            //float mapFontAscent = UsedMapFontAscent;

            float scale = 1.0f;
            if (tileflag_halfsize && !tileflag_normalobjmissile)
            {
                if ((layer_idx == (int)layer_types.LAYER_OBJECT || layer_idx == (int)layer_types.LAYER_COVER_OBJECT))
                {
                    if (obj_in_pit)
                        scale *= GHConstants.OBJECT_PIT_SCALING_FACTOR;
                }

                if (monster_height < 0 && is_monster_like_layer)
                {
                    scale *= Math.Min(1.0f, Math.Max(0.1f, 1.0f - (1.0f - (float)GHConstants.OBJECT_PIT_SCALING_FACTOR) * (float)monster_height / (float)GHConstants.SPECIAL_HEIGHT_IN_PIT));
                }

                if (tileflag_floortile || tileflag_height_is_clipping)
                {
                    if (layer_idx == (int)layer_types.LAYER_OBJECT || layer_idx == (int)layer_types.LAYER_OBJECT)
                    {
                        source_y_added = tileflag_floortile ? 0 : GHConstants.TileHeight / 2;
                        if (obj_height > 0 && obj_height < 48)
                        {
                            source_y_added += (GHConstants.TileHeight / 2 - obj_height) / 2;
                            source_height_deducted = GHConstants.TileHeight / 2 - obj_height;
                            source_height = GHConstants.TileHeight / 2 - source_height_deducted;
                            scaled_tile_width = scale * width;
                            scaled_x_padding = (width - scaled_tile_width) / 2;
                            scaled_tile_height = scale * (float)source_height * height / (float)GHConstants.TileHeight;
                            scaled_y_padding = Math.Max(0, scale * (float)source_height_deducted * height / (float)GHConstants.TileHeight - pit_border);
                        }
                    }
                    sourcerect = new SKRect(tile_x, tile_y + source_y_added, tile_x + GHConstants.TileWidth, tile_y + source_y_added + source_height);
                }
                else
                {
                    if ((layer_idx == (int)layer_types.LAYER_OBJECT || layer_idx == (int)layer_types.LAYER_COVER_OBJECT))
                    {
                        if (obj_height > 0 && obj_height < 48)
                            scale *= ((float)obj_height) / 48.0f;
                    }
                    scaled_tile_width = scale * width;
                    scaled_tile_height = scale * height / 2;
                    scaled_x_padding = (width - scaled_tile_width) / 2;
                    scaled_y_padding = Math.Max(0, height / 2 - scaled_tile_height - pit_border);
                    sourcerect = new SKRect(tile_x, tile_y + GHConstants.TileHeight / 2, tile_x + GHConstants.TileWidth, tile_y + GHConstants.TileHeight);
                }
            }
            else
            {
                if (tileflag_normalobjmissile && !tileflag_fullsizeditem)
                {
                    if (tileflag_floortile)
                    {
                        sourcerect = new SKRect(tile_x, tile_y, tile_x + GHConstants.TileWidth, tile_y + GHConstants.TileHeight / 2);
                    }
                    else if (tileflag_height_is_clipping)
                    {
                        sourcerect = new SKRect(tile_x, tile_y + GHConstants.TileHeight / 2, tile_x + GHConstants.TileWidth, tile_y + GHConstants.TileHeight);
                    }
                    else
                    {
                        if (missile_height > 0 && missile_height < 48)
                        {
                            scale = ((float)missile_height) / 48.0f;
                        }
                        scaled_tile_width = scale * width;
                        scaled_tile_height = scale * height / 2;
                        scaled_x_padding = (width - scaled_tile_width) / 2;
                        scaled_y_padding = (height / 2 - scaled_tile_height) / 2;

                        sourcerect = new SKRect(tile_x, tile_y + GHConstants.TileHeight / 2, tile_x + GHConstants.TileWidth, tile_y + GHConstants.TileHeight);
                    }
                }
                else
                {
                    if (monster_height < 0 && dy == 0 && is_monster_like_layer)
                    {
                        sourcerect = new SKRect(tile_x, tile_y, tile_x + GHConstants.TileWidth, tile_y + GHConstants.TileHeight + monster_height);
                        source_height_deducted = -monster_height;
                        source_height = GHConstants.TileHeight - source_height_deducted;
                        scaled_tile_height = (float)source_height * height / (float)GHConstants.TileHeight;
                    }
                    else
                    {
                        sourcerect = new SKRect(tile_x, tile_y, tile_x + GHConstants.TileWidth, tile_y + GHConstants.TileHeight);
                        if (is_missile_layer && !tileflag_floortile && !tileflag_height_is_clipping)
                        {
                            if (missile_height > 0 && missile_height < 48)
                            {
                                scale = ((float)missile_height) / 48.0f;
                            }
                            scaled_tile_width = scale * width;
                            scaled_tile_height = scale * height;
                            scaled_x_padding = (width - scaled_tile_width) / 2;
                            scaled_y_padding = (height - scaled_tile_height) / 2;
                        }
                    }
                }
            }

            float move_offset_x = 0, move_offset_y = 0;
            float opaqueness = 1.0f;
            bool supportsRadialTransparency = true; // !(GHApp.IsMaui && GHApp.IsAndroid && !GHApp.IsDebug); // Problem with LLVM
            if (is_monster_like_layer)
            {
                move_offset_x = base_move_offset_x;
                move_offset_y = base_move_offset_y;
                if (layer_idx == (int)layer_types.MAX_LAYERS)
                {
                    if((_draw_shadow[mapx, mapy] & 2) != 0)
                        opaqueness = (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_RADIAL_TRANSPARENCY) != 0 ? (supportsRadialTransparency ? 1.0f : 0.5f) : (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_GLASS_TRANSPARENCY) != 0 ? 0.65f : 0.5f;
                    else
                        opaqueness = 0.5f;
                }
                else if ((_mapData[mapx, mapy].Layers.monster_flags & (ulong)(LayerMonsterFlags.LMFLAGS_INVISIBLE_TRANSPARENT | LayerMonsterFlags.LMFLAGS_SEMI_TRANSPARENT | LayerMonsterFlags.LMFLAGS_RADIAL_TRANSPARENCY)) != 0)
                {
                    _draw_shadow[mapx, mapy] |= 2;
                    return; /* Draw only the transparent shadow in the max_layers shadow layer; otherwise, if drawn twice, the result will be nontransparent */
                }

                /* Death transparency */
                if ((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_KILLED) != 0 
                    && (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_STONED) == 0
                    && (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_FADES_UPON_DEATH) != 0)
                {
                    opaqueness = opaqueness * ((float)(20L - Math.Min(20L, generalcounterdiff))) / 20;
                }

                /* Hovering effect */
                if ((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_KILLED) == 0)
                {
                    if((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_LEVITATING) != 0)
                    {
                        long animationframe = generalcountervalue % _hoverAnimation.Length;
                        move_offset_x += _hoverAnimation[animationframe].X * scale * targetscale;
                        move_offset_y += (-2.5f + _hoverAnimation[animationframe].Y) * scale * targetscale;
                    }
                    else if ((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_FLYING) != 0)
                    {
                        long animationframe = generalcountervalue % _flyingAnimation.Length;
                        move_offset_x += _flyingAnimation[animationframe].X * scale * targetscale;
                        move_offset_y += (-5f + _flyingAnimation[animationframe].Y) * scale * targetscale;
                    }
                    else if ((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_SWIM_ANIMATION) != 0)
                    {
                        if ((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_SPECIAL_ANIMATION) != 0)
                        {
                            long animationframe = generalcountervalue % _sharkAnimation.Length;
                            float target_y_change = _sharkAnimation[animationframe].Y * scale * targetscale;
                            move_offset_x += _sharkAnimation[animationframe].X * scale * targetscale;
                            move_offset_y += target_y_change;
                            if (mapy == draw_map_y)
                            {
                                scaled_tile_height -= target_y_change;
                                sourcerect = new SKRect(sourcerect.Left, sourcerect.Top, sourcerect.Right, sourcerect.Bottom - _sharkAnimation[animationframe].Y);
                            }
                        }
                        else
                        {
                            long animationframe = generalcountervalue % _swimAnimation.Length;
                            move_offset_x += _swimAnimation[animationframe].X * scale * targetscale;
                            move_offset_y += _swimAnimation[animationframe].Y * scale * targetscale;
                        }
                    }
                }
            }
            else if (is_object_like_layer && otmp_round != null)
            {
                move_offset_x = object_move_offset_x;
                move_offset_y = object_move_offset_y;
                /* Object transparency */
                if (otmp_round.OtypData.semitransparent != 0)
                    opaqueness = 0.5f;
            }
            else if (layer_idx == (int)layer_types.LAYER_COVER_TRAP)
            {
                opaqueness = 0.5f;
            }
            else if (layer_idx == (int)layer_types.LAYER_BACKGROUND_EFFECT)
            {
                if((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_E_BKG_FADE_IN) != 0)
                {
                    opaqueness = opaqueness * ((float)(Math.Min(20L, generalcounterdiff))) / 20;
                }
                else if ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_E_BKG_FADE_OUT) != 0)
                {
                    opaqueness = opaqueness * ((float)(20L - Math.Min(20L, generalcounterdiff))) / 20;
                }
            }
            else if (layer_idx == (int)layer_types.LAYER_GENERAL_EFFECT)
            {
                if ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_E_GEN_FADE_OUT) != 0)
                {
                    opaqueness = opaqueness * ((float)(20L - Math.Min(20L, generalcounterdiff))) / 20;
                }
            }

            if (pointerIsHoveringOnTile)
            {
                if (mapLookMode && layer_idx > (int)layer_types.LAYER_CARPET && layer_idx < (int)layer_types.LAYER_ZAP)
                    paint.ColorFilter = UIUtils.LookHighlightColorFilter;
                else if (is_monster_like_layer || is_object_like_layer || layer_idx == (int)layer_types.LAYER_TRAP || layer_idx == (int)layer_types.LAYER_COVER_TRAP)
                    paint.ColorFilter = UIUtils.MapHighlightColorFilter;
            }

            float dscalex = 1.0f;
            float dscaley = 1.0f;
            float correction_x = 0f;
            float correction_y = 0f;
            if (is_monster_like_layer)
            {
                if ((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_KILLED) != 0
                    && (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_STONED) == 0
                    && (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_FADES_UPON_DEATH) == 0)
                {
                    if (enlargement > 0)
                    {
                        int enlarea = GHApp._enlargementDefs[enlargement].width_in_tiles * GHApp._enlargementDefs[enlargement].height_in_tiles;
                        int maxenltiles = Math.Max(GHApp._enlargementDefs[enlargement].width_in_tiles, GHApp._enlargementDefs[enlargement].height_in_tiles);
                        long param = Math.Max(1L, enlarea > 0 ? 180L / enlarea : 60L);
                        long param2 = (param * (maxenltiles - 1)) / maxenltiles;
                        dscalex = dscaley = ((float)(param - Math.Min(param2 - 1, generalcounterdiff))) / (float)param;
                    }
                    else
                        dscalex = dscaley = ((float)(90 - Math.Min(44L, generalcounterdiff))) / 90;
                }

                if ((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_KILLED) == 0)                   
                {
                    if((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_BLOBBY_ANIMATION) != 0)
                    {
                        long animationframe = generalcountervalue % _blobAnimation.Length;
                        dscalex *= _blobAnimation[animationframe].X;
                        dscaley *= _blobAnimation[animationframe].Y;
                    }
                    else if(breatheanimations)
                    {
                        if ((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_HUMAN_BREATHE_ANIMATION) != 0)
                        {
                            long animationframe = generalcountervalue % _humanBreatheAnimation.Length;
                            dscalex *= _humanBreatheAnimation[animationframe].X;
                            dscaley *= _humanBreatheAnimation[animationframe].Y;
                        }
                        else if ((_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_ANIMAL_BREATHE_ANIMATION) != 0)
                        {
                            long animationframe = generalcountervalue % _animalBreatheAnimation.Length;
                            dscalex *= _animalBreatheAnimation[animationframe].X;
                            dscaley *= _animalBreatheAnimation[animationframe].Y;
                        }
                    }
                }

                correction_x = width * (mapx - draw_map_x) + width * dscalex * (draw_map_x - mapx) + width * (1.0f - dscalex) / 2;
                correction_y = height * (mapy - draw_map_y) + height * dscaley * (draw_map_y - mapy) + height * (1.0f - dscaley);
            }

            tx = (offsetX + usedOffsetX + move_offset_x + width * (float)draw_map_x + correction_x);
            ty = (offsetY + usedOffsetY + move_offset_y + scaled_y_height_change + mapFontAscent + height * (float)draw_map_y + correction_y);
            float splitY = -(move_offset_y + scaled_y_height_change + correction_y);
            float dx2 = dx * (hflip_glyph ? -1 : 1) * width * dscalex;
            float dy2 = dy * (vflip_glyph ? -1 : 1) * height * dscaley;
            using (new SKAutoCanvasRestore(canvas, true))
            {
                float tr_x = tx + (hflip_glyph ? width * dscalex : 0);
                float tr_y = ty + (vflip_glyph ? height * dscaley : 0);
                float sc_x = hflip_glyph ? -1 : 1;
                float sc_y = vflip_glyph ? -1 : 1;
                TranslateAndScaleCanvas(canvas, tr_x, tr_y, sc_x, sc_y, is_monster_like_layer, ref _mapData[mapx, mapy].Layers,
                    dx2, dy2, dscalex, dscaley, width, height, generalcounterdiff);
                //SKAutoCanvasRestore enlRestore = null;
                //if (enlCanvas != canvas)
                //{
                //    enlRestore = new SKAutoCanvasRestore(enlCanvas, true);
                //    TranslateAndScaleCanvas(enlCanvas, tr_x, tr_y, sc_x, sc_y, is_monster_like_layer, _mapData[mapx, mapy].Layers,
                //        dx2, dy2, dscalex, dscaley, width, height, generalcounterdiff);
                //}
                SKRect targetrect;
                if (tileflag_halfsize && !tileflag_normalobjmissile)
                {
                    targetrect = new SKRect(scaled_x_padding, height / 2 + scaled_y_padding, scaled_x_padding + scaled_tile_width, height / 2 + scaled_y_padding + scaled_tile_height);
                }
                else
                {
                    if (tileflag_normalobjmissile && !tileflag_fullsizeditem)
                        targetrect = new SKRect(scaled_x_padding, height / 4 + scaled_y_padding, scaled_x_padding + scaled_tile_width, height / 4 + scaled_y_padding + scaled_tile_height);
                    else
                        targetrect = new SKRect(scaled_x_padding, scaled_y_padding, scaled_x_padding + scaled_tile_width, scaled_y_padding + scaled_tile_height);
                }

                //SKRect baseUpdateRect = new SKRect();
                //SKRect enlUpdateRect = new SKRect();
                paint.Color = paint.Color.WithAlpha((byte)(0xFF * opaqueness));
                if (supportsRadialTransparency && is_monster_like_layer && (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_RADIAL_TRANSPARENCY) != 0)
                {
                    DrawTileWithRadialTransparency(canvas, delayedDraw, TileMap[sheet_idx], sourcerect, targetrect, ref _mapData[mapx, mapy].Layers, splitY, opaqueness, paint, mapx, mapy, canvaswidth, canvasheight, targetscale, usingGL, usingMipMap, fixRects);
                }
                else
                {
#if GNH_MAP_PROFILING && DEBUG
                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                    DrawSplitBitmap(canvas, delayedDraw, splitY, TileMap[sheet_idx], sourcerect, targetrect, paint, mapx, mapy, canvaswidth, canvasheight, targetscale, usingGL, usingMipMap, fixRects); //, ref baseUpdateRect, ref enlUpdateRect);
#if GNH_MAP_PROFILING && DEBUG
                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                }

                //SKRect mBaseUpdateRect = canvas.TotalMatrix.MapRect(baseUpdateRect);
                //SKRect mEnlUpdateRect = enlCanvas.TotalMatrix.MapRect(enlUpdateRect);
                //UpdateDrawBounds(mBaseUpdateRect, ref minDrawX, ref maxDrawX, ref minDrawY, ref maxDrawY);
                //if(canvas != enlCanvas)
                //    UpdateDrawBounds(mEnlUpdateRect, ref enlMinDrawX, ref enlMaxDrawX, ref enlMinDrawY, ref enlMaxDrawY);

                //if (enlRestore != null)
                //    enlRestore.Dispose();
            }

            DrawAutoDraw(autodraw, canvas, delayedDraw, paint, otmp_round,
                layer_idx, mapx, mapy,
                tileflag_halfsize, tileflag_normalobjmissile, tileflag_fullsizeditem,
                tx, ty, width, height,
                scale, targetscale, scaled_x_padding, scaled_y_padding, scaled_tile_height,
                false, drawwallends, usingGL, false, fixRects);

            if (pointerIsHoveringOnTile && paint.ColorFilter != null)
            {
                paint.ColorFilter = null;
            }
        }

        public void UpdateDrawBounds(SKRect mUpdateRect, ref float minDrawX, ref float maxDrawX, ref float minDrawY, ref float maxDrawY)
        {
            if (mUpdateRect.Left < minDrawX)
                minDrawX = mUpdateRect.Left;
            if (mUpdateRect.Right > maxDrawX)
                maxDrawX = mUpdateRect.Right;
            if (mUpdateRect.Top < minDrawY)
                minDrawY = mUpdateRect.Top;
            if (mUpdateRect.Bottom > maxDrawY)
                maxDrawY = mUpdateRect.Bottom;
        }

        struct SavedRect
        {
            public SKImage Bitmap;
            public SKRect Rect;
            public SavedRect(SKImage bitmap, SKRect rect)
            {
                Bitmap = bitmap;
                Rect = rect;
            }
        }

        //private readonly object _saveRectLock = new object();
        Dictionary<SavedRect, SKImage> _savedRects = new Dictionary<SavedRect, SKImage>();
        public void DrawTileWithRadialTransparency(SKCanvas canvas, bool delayedDraw, SKImage tileSheet, SKRect sourcerect, SKRect targetrect, ref LayerInfo layers, float destSplitY, float opaqueness, SKPaint paint, int mapX, int mapY, float canvaswidth, float canvasheight, float targetscale, bool usingGL, bool usingMipMap, bool fixRects)
        {
            bool cache = false;
            if (sourcerect.Left % GHConstants.TileWidth == 0 && sourcerect.Top % GHConstants.TileHeight == 0
                && sourcerect.Width == GHConstants.TileWidth && sourcerect.Height == GHConstants.TileHeight)
                cache = true;

            if (cache && RetrieveCachedRadialTile(canvas, delayedDraw, tileSheet, sourcerect, targetrect, ref layers, destSplitY, opaqueness, paint, mapX, mapY, canvaswidth, canvasheight, targetscale, usingGL, usingMipMap, fixRects))
                return;

            int copywidth, copyheight;
            if (!ProcessRadialTile(canvas, delayedDraw, tileSheet, sourcerect, targetrect, ref layers, destSplitY, opaqueness, paint, mapX, mapY, canvaswidth, canvasheight, targetscale, usingGL, usingMipMap, fixRects, out copywidth, out copyheight))
                return;

            SetRadialTileExtraTransparency(ref layers, paint, opaqueness);

            SKRect tempsourcerect = new SKRect(0, 0, copywidth, copyheight);
            if (cache)
                CacheRadialTileAndDraw(canvas, delayedDraw, tileSheet, sourcerect, targetrect, ref layers, destSplitY, opaqueness, paint, mapX, mapY, canvaswidth, canvasheight, targetscale, usingGL, usingMipMap, fixRects, tempsourcerect);
            else
                DrawSplitBitmap(canvas, delayedDraw, destSplitY, SKImage.FromBitmap(_tempBitmap), tempsourcerect, targetrect, paint, mapX, mapY, canvaswidth, canvasheight, targetscale, usingGL, usingMipMap, fixRects);
        }

        private void SetRadialTileExtraTransparency(ref LayerInfo layers, SKPaint paint, float opaqueness)
        {
            if ((layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_INVISIBLE_TRANSPARENT) != 0)
                paint.Color = paint.Color.WithAlpha((byte)(0xFF * opaqueness));
        }

        private bool RetrieveCachedRadialTile(SKCanvas canvas, bool delayedDraw, SKImage tileSheet, SKRect sourcerect, SKRect targetrect, ref LayerInfo layers, float destSplitY, float opaqueness, SKPaint paint, int mapX, int mapY, float canvaswidth, float canvasheight, float targetscale, bool usingGL, bool usingMipMap, bool fixRects)
        {
            SavedRect sr = new SavedRect(tileSheet, sourcerect);
            SKImage bmp = null;
            bool getsuccessful;
            //lock (_saveRectLock)
            {
                getsuccessful = _savedRects.TryGetValue(sr, out bmp);
            }
            if (getsuccessful && bmp != null)
            {
                SKRect bmpsourcerect = new SKRect(0, 0, (float)bmp.Width, (float)bmp.Height);
                DrawSplitBitmap(canvas, delayedDraw, destSplitY, bmp, bmpsourcerect, targetrect, paint, mapX, mapY, canvaswidth, canvasheight, targetscale, usingGL, usingMipMap, fixRects);
                return true;
            }
            return false;
        }

        private void CacheRadialTileAndDraw(SKCanvas canvas, bool delayedDraw, SKImage tileSheet, SKRect sourcerect, SKRect targetrect, ref LayerInfo layers, float destSplitY, float opaqueness, SKPaint paint, int mapX, int mapY, float canvaswidth, float canvasheight, float targetscale, bool usingGL, bool usingMipMap, bool fixRects, SKRect tempsourcerect)
        {
            SavedRect sr = new SavedRect(tileSheet, sourcerect);
            bool containskey;
            //lock (_saveRectLock)
            {
                containskey = _savedRects.ContainsKey(sr);
            }
            if (!containskey)
            {
                try
                {
                    SKBitmap newbmp = new SKBitmap(GHConstants.TileWidth, GHConstants.TileHeight, _tempBitmap.ColorType, _tempBitmap.AlphaType);
                    _tempBitmap.CopyTo(newbmp);
                    newbmp.SetImmutable();
                    SKImage newimg = SKImage.FromBitmap(newbmp);
                    //lock (_saveRectLock)
                    {
                        if (_savedRects.Count >= GHConstants.MaxBitmapCacheSize)
                        {
                            foreach (SKImage bmp in _savedRects.Values)
                                bmp.Dispose();
                            _savedRects.Clear(); /* Clear the whole dictionary for the sake of ease; should almost never happen normally anyway */
                        }
                        _savedRects.Add(sr, newimg);
                    }
                    DrawSplitBitmap(canvas, delayedDraw, destSplitY, newimg, tempsourcerect, targetrect, paint, mapX, mapY, canvaswidth, canvasheight, targetscale, usingGL, usingMipMap, fixRects); //, ref baseUpdateRect, ref enlUpdateRect);
                }
                catch (Exception ex)
                {
                    Debug.WriteLine(ex.Message);
                }
            }
        }

        private bool ProcessRadialTile(SKCanvas canvas, bool delayedDraw, SKImage tileSheet, SKRect sourcerect, SKRect targetrect, ref LayerInfo layers, float destSplitY, float opaqueness, SKPaint paint, int mapX, int mapY, float canvaswidth, float canvasheight, float targetscale, bool usingGL, bool usingMipMap, bool fixRects, out int copywidth, out int copyheight)
        {
            SKPixmap pixmapTile = tileSheet.PeekPixels();
            if (pixmapTile == null)
            {
                copywidth = 0;
                copyheight = 0;
                return false;
            }
            IntPtr tempptraddr = _tempBitmap.GetPixels();
            IntPtr tileptraddr = pixmapTile.GetPixels();
            double mid_x = (double)GHConstants.TileWidth / 2.0 - 0.5;
            double mid_y = (double)GHConstants.TileHeight / 2.0 - 0.5;
            double r = 0, semi_transparency = 0;
            byte radial_opacity = 0x00;
            //int bytesperpixel = tileSheet.BytesPerPixel;
            int bytesperpixel = pixmapTile.BytesPerPixel;
            copywidth = Math.Min((int)sourcerect.Width, _tempBitmap.Width);
            copyheight = Math.Min((int)sourcerect.Height, _tempBitmap.Height);
            int tilemapwidth = tileSheet.Width;
            unsafe
            {
                byte* tempptr = (byte*)tempptraddr.ToPointer();
                byte* tileptr = (byte*)tileptraddr.ToPointer();
                tileptr += ((int)sourcerect.Left + (int)sourcerect.Top * tilemapwidth) * bytesperpixel;

                for (int row = 0; row < copyheight; row++)
                {
                    for (int col = 0; col < copywidth; col++)
                    {
                        r = Math.Sqrt(Math.Pow((double)col - mid_x, 2.0) + Math.Pow((double)row - mid_y, 2.0));
                        semi_transparency = r * 0.0375; //r_constant
                        if (semi_transparency > 0.98)
                            semi_transparency = 0.98;

                        *tempptr++ = *tileptr;       // red
                        tileptr++;
                        *tempptr++ = *tileptr;       // green
                        tileptr++;
                        *tempptr++ = *tileptr;       // blue
                        tileptr++;
                        radial_opacity = (byte)((double)0xFF * (1.0 - semi_transparency) * ((double)(*tileptr) / (double)0xFF));
                        *tempptr++ = radial_opacity; // alpha
                        tileptr++;
                    }
                    tileptr += (tilemapwidth - copywidth) * bytesperpixel;
                }
            }
            return true;
        }

        private List<GHDrawCommand> _drawCommandList = new List<GHDrawCommand>();

        public void DrawSplitBitmap(SKCanvas canvas, bool delayedDraw, float destSplitY, SKImage bitmap, SKRect source, SKRect dest, SKPaint paint, int mapX, int mapY, float canvaswidth, float canvasheight, float targetscale, bool usingGL, bool usingMipMap, bool fixRects) //, ref SKRect baseUpdateRect, ref SKRect enlUpdateRect)
        {
            if (dest.Bottom <= 0 || dest.Top >= canvasheight || dest.Right < 0 || dest.Left >= canvaswidth)
                return;

            if (destSplitY <= dest.Top || delayedDraw)
            {
                if (delayedDraw)
                    _drawCommandList.Add(new GHDrawCommand(canvas.TotalMatrix, source, dest, bitmap, paint.Color, paint.ColorFilter, mapX, mapY));
                else
                {
                    GHApp.MaybeFixRects(ref source, ref dest, targetscale, usingGL, fixRects);
                    canvas.DrawImage(bitmap, source, dest,
#if GNH_MAUI
                        new SKSamplingOptions(SKFilterMode.Nearest, usingGL && usingMipMap ? SKMipmapMode.Nearest: SKMipmapMode.None),
#endif
                        paint);
                }
            }
            else if (destSplitY >= dest.Bottom)
            {
                _drawCommandList.Add(new GHDrawCommand(canvas.TotalMatrix, source, dest, bitmap, paint.Color, paint.ColorFilter, mapX, mapY));
            }
            else
            {
                float destHeight = dest.Bottom - dest.Top;
                if (destHeight <= 0)
                    return;
                SKRect enlDest = new SKRect(dest.Left, dest.Top, dest.Right, destSplitY);
                SKRect baseDest = new SKRect(dest.Left, destSplitY, dest.Right, dest.Bottom);
                float topDestScale = (destSplitY - dest.Top) / destHeight;
                float sourceSplitY = source.Top + (source.Bottom - source.Top) * topDestScale;
                SKRect enlSource = new SKRect(source.Left, source.Top, source.Right, sourceSplitY);
                SKRect baseSource = new SKRect(source.Left, sourceSplitY, source.Right, source.Bottom);
                GHApp.MaybeFixRects(ref baseSource, ref baseDest, targetscale, usingGL, fixRects);
                canvas.DrawImage(bitmap, baseSource, baseDest,
#if GNH_MAUI
                    new SKSamplingOptions(SKFilterMode.Nearest, usingGL && usingMipMap ? SKMipmapMode.Nearest : SKMipmapMode.None),
#endif
                    paint);
                _drawCommandList.Add(new GHDrawCommand(canvas.TotalMatrix, enlSource, enlDest, bitmap, paint.Color, paint.ColorFilter, mapX, mapY));
            }
        }

        public void TranslateAndScaleCanvas(SKCanvas canvas, float tr_x, float tr_y, float sc_x, float sc_y, bool is_monster_like_layer, ref LayerInfo layers,
                    float dx2, float dy2, float dscalex, float dscaley, float width, float height, long generalcounterdiff)
        {
            canvas.Translate(tr_x, tr_y);
            canvas.Scale(sc_x, sc_y, 0, 0);
            if (is_monster_like_layer)
            {
                if ((layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_KILLED) != 0
                    && (layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_STONED) == 0
                    && (layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_FADES_UPON_DEATH) == 0)
                {
                    /* Death rotation */
                    float rotateheight = 0.5f * height * dscaley; //((float)(enlargement > 0 ? GHApp._enlargementDefs[enlargement].height_in_tiles - 1 : 0) * -0.5f + 0.75f)
                    canvas.Translate(-dx2 + 0.5f * width * dscalex, -dy2 + rotateheight);
                    canvas.RotateDegrees(generalcounterdiff * 15);
                    canvas.Translate(dx2 - 0.5f * width * dscalex, dy2 - rotateheight);
                }
                if (dscalex != 1.0f || dscaley != 1.0f)
                    canvas.Scale(dscalex, dscaley, 0, 0);
            }
        }
    
        private int GetSubLayerCount(int mapx, int mapy, int layer_idx, out bool is_source_dir)
        {
            int sub_layer_cnt = 1;
            switch (layer_idx)
            {
                case (int)layer_types.LAYER_OBJECT:
                    if ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_SHOWING_MEMORY) != 0)
                        sub_layer_cnt = _objectData[mapx, mapy].MemoryObjectList == null ? 0 : Math.Min(GHConstants.MaxObjectsDrawn, _objectData[mapx, mapy].MemoryObjectList.Count);
                    else if ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_CAN_SEE) != 0)
                        sub_layer_cnt = _objectData[mapx, mapy].FloorObjectList == null ? 0 : Math.Min(GHConstants.MaxObjectsDrawn, _objectData[mapx, mapy].FloorObjectList.Count);
                    else
                        sub_layer_cnt = 1; /* As a backup, show layer glyph (probably often NoGlyph) */
                    is_source_dir = false;
                    break;
                case (int)layer_types.LAYER_COVER_OBJECT:
                    if ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_SHOWING_MEMORY) != 0)
                        sub_layer_cnt = _objectData[mapx, mapy].CoverMemoryObjectList == null ? 0 : Math.Min(GHConstants.MaxObjectsDrawn, _objectData[mapx, mapy].CoverMemoryObjectList.Count);
                    else if ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_CAN_SEE) != 0)
                        sub_layer_cnt = _objectData[mapx, mapy].CoverFloorObjectList == null ? 0 : Math.Min(GHConstants.MaxObjectsDrawn, _objectData[mapx, mapy].CoverFloorObjectList.Count);
                    else
                        sub_layer_cnt = 1; /* As a backup, show layer glyph (probably often NoGlyph) */
                    is_source_dir = false;
                    break;
                case (int)layer_types.LAYER_MONSTER:
                    sub_layer_cnt = GHConstants.NUM_WORM_SOURCE_DIRS + 1;
                    is_source_dir = true;
                    break;
                case (int)layer_types.LAYER_CHAIN:
                    sub_layer_cnt = GHConstants.NUM_CHAIN_SOURCE_DIRS + 1;
                    is_source_dir = true;
                    break;
                case (int)layer_types.LAYER_ZAP:
                    sub_layer_cnt = GHConstants.NUM_ZAP_SOURCE_DIRS + 1;
                    is_source_dir = true;
                    break;
                default:
                    is_source_dir = false;
                    break;
            }
            return sub_layer_cnt;
        }

        int GetSourceDirIndex(int layer_idx, int source_dir_main_idx)
        {
            int source_dir_idx = source_dir_main_idx;
            switch (layer_idx)
            {
                case (int)layer_types.LAYER_CHAIN:
                case (int)layer_types.LAYER_MONSTER:
                    source_dir_idx = source_dir_main_idx * 2;
                    break;
            }
            return source_dir_idx;
        }

        int GetUsedEnlargementIndex(int enlarg_idx)
        {
            int used_enl_idx = -1;
            switch(enlarg_idx)
            {
                default:
                case -1:
                    break;
                case 0:
                    used_enl_idx = 4;
                    break;
                case 1:
                    used_enl_idx = 3;
                    break;
                case 2:
                    used_enl_idx = 2;
                    break;
                case 3:
                    used_enl_idx = 1;
                    break;
                case 4:
                    used_enl_idx = 0;
                    break;
            }
            return used_enl_idx;
        }

        private bool GetEnlargementTile(int enlargement, int enlarg_idx, bool hflip_glyph, bool vflip_glyph, int main_tile_idx, int anim_frame_idx, ref int ntile, ref int autodraw, ref int dx, ref int dy)
        {
            if (enlargement == 0 && enlarg_idx >= 0)
                return false;

            int position_index = -1;
            int orig_position_index = -1;
            if (enlargement > 0)
            {
                orig_position_index = -1;
                /* Set position_index */
                if (enlarg_idx == -1)
                {
                    if (vflip_glyph)
                        position_index = 1;
                    else
                        position_index = -1;
                }
                else if (enlarg_idx == 0)
                {
                    orig_position_index = 4;
                    if (vflip_glyph)
                        position_index = hflip_glyph ? 0 : 2;
                    else
                        position_index = hflip_glyph ? 3 : 4;
                }
                else if (enlarg_idx == 1)
                {
                    orig_position_index = 3;
                    if (vflip_glyph)
                        position_index = hflip_glyph ? 2 : 0;
                    else
                        position_index = hflip_glyph ? 4 : 3;
                }
                else if (enlarg_idx == 2)
                {
                    orig_position_index = 2;
                    if (vflip_glyph)
                        position_index = hflip_glyph ? 3 : 4;
                    else
                        position_index = hflip_glyph ? 0 : 2;
                }
                else if (enlarg_idx == 3)
                {
                    orig_position_index = 1;
                    if (vflip_glyph)
                        position_index = -1;
                    else
                        position_index = 1;
                }
                else if (enlarg_idx == 4)
                {
                    orig_position_index = 0;
                    if (vflip_glyph)
                        position_index = hflip_glyph ? 4 : 3;
                    else
                        position_index = hflip_glyph ? 2 : 0;
                }

            }

            if (enlargement > 0 && orig_position_index >= 0)
            {
                int enl_tile_idx = GHApp._enlargementDefs[enlargement].position2tile[orig_position_index];
                if (enl_tile_idx >= 0)
                {
                    int addedindex = 0;
                    if (GHApp._enlargementDefs[enlargement].number_of_animation_frames > 0)
                    {
                        if (main_tile_idx == -1
                            && anim_frame_idx >= 0
                            && anim_frame_idx < GHApp._enlargementDefs[enlargement].number_of_animation_frames
                            )
                        {
                            addedindex = anim_frame_idx * GHApp._enlargementDefs[enlargement].number_of_enlargement_tiles;
                        }
                        else if (main_tile_idx == 0
                            && anim_frame_idx > 0
                            && anim_frame_idx <= GHApp._enlargementDefs[enlargement].number_of_animation_frames)
                        {
                            addedindex = (anim_frame_idx - 1) * GHApp._enlargementDefs[enlargement].number_of_enlargement_tiles;
                        }
                        else if (main_tile_idx == GHApp._enlargementDefs[enlargement].number_of_animation_frames
                            && anim_frame_idx >= 0
                            && anim_frame_idx < GHApp._enlargementDefs[enlargement].number_of_animation_frames
                            )
                        {
                            addedindex = anim_frame_idx * GHApp._enlargementDefs[enlargement].number_of_enlargement_tiles;
                        }
                    }
                    int enl_glyph = enl_tile_idx + addedindex + GHApp.EnlargementOffsets[enlargement] + GHApp.EnlargementOff;
                    ntile = GHApp.Glyph2Tile[enl_glyph]; /* replace */
                    autodraw = GHApp.Tile2Autodraw[ntile];
                }
                else
                    return false;
            }

            switch (position_index)
            {
                case 0:
                    dx = -1;
                    dy = -1;
                    break;
                case 1:
                    dx = 0;
                    dy = -1;
                    break;
                case 2:
                    dx = 1;
                    dy = -1;
                    break;
                case 3:
                    dx = -1;
                    dy = 0;
                    break;
                case 4:
                    dx = 1;
                    dy = 0;
                    break;
            }
            return true;
        }

        private bool GetEnlargementTileB(int enlargement, int enlarg_idx, bool hflip_glyph, bool vflip_glyph, int main_tile_idx, int anim_frame_idx, ref int ntile, ref int autodraw, ref int dx, ref int dy)
        {
            if (enlargement == 0 && enlarg_idx >= 0)
                return false;

            int position_index = -1;
            if (enlargement > 0)
            {
                /* Set position_index */
                switch(enlarg_idx)
                {
                    default:
                    case -1:
                        if (vflip_glyph)
                            position_index = 1;
                        else
                            position_index = -1;
                        break;
                    case 0:
                        if (vflip_glyph)
                            position_index = hflip_glyph ? 4 : 3;
                        else
                            position_index = hflip_glyph ? 2 : 0;
                        break;
                    case 1:
                        if (vflip_glyph)
                            position_index = -1;
                        else
                            position_index = 1;
                        break;
                    case 2:
                        if (vflip_glyph)
                            position_index = hflip_glyph ? 3 : 4;
                        else
                            position_index = hflip_glyph ? 0 : 2;

                        break;
                    case 3:
                        if (vflip_glyph)
                            position_index = hflip_glyph ? 2 : 0;
                        else
                            position_index = hflip_glyph ? 4 : 3;
                        break;
                    case 4:
                        if (vflip_glyph)
                            position_index = hflip_glyph ? 0 : 2;
                        else
                            position_index = hflip_glyph ? 3 : 4;
                        break;
                }
            }

            if (enlargement > 0 && position_index >= 0)
            {
                int enl_tile_idx = GHApp._enlargementDefs[enlargement].position2tile[position_index];
                if (enl_tile_idx >= 0)
                {
                    int addedindex = 0;
                    if (GHApp._enlargementDefs[enlargement].number_of_animation_frames > 0)
                    {
                        if (main_tile_idx == -1
                            && anim_frame_idx >= 0
                            && anim_frame_idx < GHApp._enlargementDefs[enlargement].number_of_animation_frames
                            )
                        {
                            addedindex = anim_frame_idx * GHApp._enlargementDefs[enlargement].number_of_enlargement_tiles;
                        }
                        else if (main_tile_idx == 0
                            && anim_frame_idx > 0
                            && anim_frame_idx <= GHApp._enlargementDefs[enlargement].number_of_animation_frames)
                        {
                            addedindex = (anim_frame_idx - 1) * GHApp._enlargementDefs[enlargement].number_of_enlargement_tiles;
                        }
                        else if (main_tile_idx == GHApp._enlargementDefs[enlargement].number_of_animation_frames
                            && anim_frame_idx >= 0
                            && anim_frame_idx < GHApp._enlargementDefs[enlargement].number_of_animation_frames
                            )
                        {
                            addedindex = anim_frame_idx * GHApp._enlargementDefs[enlargement].number_of_enlargement_tiles;
                        }
                    }
                    int enl_glyph = enl_tile_idx + addedindex + GHApp.EnlargementOffsets[enlargement] + GHApp.EnlargementOff;
                    ntile = GHApp.Glyph2Tile[enl_glyph]; /* replace */
                    autodraw = GHApp.Tile2Autodraw[ntile];
                }
                else
                    return false;
            }

            switch (enlarg_idx)
            {
                case 0:
                    dx = -1;
                    dy = -1;
                    break;
                case 1:
                    dx = 0;
                    dy = -1;
                    break;
                case 2:
                    dx = 1;
                    dy = -1;
                    break;
                case 3:
                    dx = -1;
                    dy = 0;
                    break;
                case 4:
                    dx = 1;
                    dy = 0;
                    break;
            }
            return true;
        }

        private bool GetLayerGlyph(int mapx, int mapy, int layer_idx, int sub_layer_idx, int source_dir_idx,
            ref int signed_glyph, ref int adj_x, ref int adj_y, ref bool manual_hflip, ref bool manual_vflip,
            ref ObjectDataItem otmp_round, ref short obj_height, ref sbyte object_origin_x, ref sbyte object_origin_y, ref bool foundthisturn)
        {
            if (layer_idx == (int)layer_types.LAYER_OBJECT)
            {
                if ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_SHOWING_MEMORY) != 0)
                {
                    otmp_round = _objectData[mapx, mapy].MemoryObjectList[sub_layer_idx];
                    signed_glyph = _objectData[mapx, mapy].MemoryObjectList[sub_layer_idx].ObjData.gui_glyph;
                    obj_height = _objectData[mapx, mapy].MemoryObjectList[sub_layer_idx].TileHeight;
                    object_origin_x = _objectData[mapx, mapy].MemoryObjectList[sub_layer_idx].ObjData.ox0;
                    object_origin_y = _objectData[mapx, mapy].MemoryObjectList[sub_layer_idx].ObjData.oy0;
                    foundthisturn = _objectData[mapx, mapy].MemoryObjectList[sub_layer_idx].FoundThisTurn;
                }
                else if ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_CAN_SEE) != 0)
                {
                    otmp_round = _objectData[mapx, mapy].FloorObjectList[sub_layer_idx];
                    signed_glyph = _objectData[mapx, mapy].FloorObjectList[sub_layer_idx].ObjData.gui_glyph;
                    obj_height = _objectData[mapx, mapy].FloorObjectList[sub_layer_idx].TileHeight;
                    object_origin_x = _objectData[mapx, mapy].FloorObjectList[sub_layer_idx].ObjData.ox0;
                    object_origin_y = _objectData[mapx, mapy].FloorObjectList[sub_layer_idx].ObjData.oy0;
                    foundthisturn = _objectData[mapx, mapy].FloorObjectList[sub_layer_idx].FoundThisTurn;
                }
                else
                {
                    signed_glyph = _mapData[mapx, mapy].Layers.layer_gui_glyphs == null ? GHApp.NoGlyph : _mapData[mapx, mapy].Layers.layer_gui_glyphs[layer_idx];
                }
            }
            else if (layer_idx == (int)layer_types.LAYER_COVER_OBJECT)
            {
                if ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_SHOWING_MEMORY) != 0)
                {
                    otmp_round = _objectData[mapx, mapy].CoverMemoryObjectList[sub_layer_idx];
                    signed_glyph = _objectData[mapx, mapy].CoverMemoryObjectList[sub_layer_idx].ObjData.gui_glyph;
                    obj_height = _objectData[mapx, mapy].CoverMemoryObjectList[sub_layer_idx].TileHeight;
                    object_origin_x = _objectData[mapx, mapy].CoverMemoryObjectList[sub_layer_idx].ObjData.ox0;
                    object_origin_y = _objectData[mapx, mapy].CoverMemoryObjectList[sub_layer_idx].ObjData.oy0;
                }
                else if ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_CAN_SEE) != 0)
                {
                    otmp_round = _objectData[mapx, mapy].CoverFloorObjectList[sub_layer_idx];
                    signed_glyph = _objectData[mapx, mapy].CoverFloorObjectList[sub_layer_idx].ObjData.gui_glyph;
                    obj_height = _objectData[mapx, mapy].CoverFloorObjectList[sub_layer_idx].TileHeight;
                    object_origin_x = _objectData[mapx, mapy].CoverFloorObjectList[sub_layer_idx].ObjData.ox0;
                    object_origin_y = _objectData[mapx, mapy].CoverFloorObjectList[sub_layer_idx].ObjData.oy0;
                }
                else
                {
                    signed_glyph = _mapData[mapx, mapy].Layers.layer_gui_glyphs == null ? GHApp.NoGlyph : _mapData[mapx, mapy].Layers.layer_gui_glyphs[layer_idx];
                }
            }
            else if (source_dir_idx > 0)
            {
                switch ((source_dir_idx - 1) % GHConstants.NUM_ZAP_SOURCE_BASE_DIRS + 1)
                {
                    case 1:
                        adj_x = mapx + 1;
                        adj_y = mapy + 1;
                        break;
                    case 2:
                        adj_x = mapx;
                        adj_y = mapy + 1;
                        break;
                    case 3:
                        adj_x = mapx - 1;
                        adj_y = mapy + 1;
                        break;
                    case 4:
                        adj_x = mapx - 1;
                        adj_y = mapy;
                        break;
                    case 5:
                        adj_x = mapx - 1;
                        adj_y = mapy - 1;
                        break;
                    case 6:
                        adj_x = mapx;
                        adj_y = mapy - 1;
                        break;
                    case 7:
                        adj_x = mapx + 1;
                        adj_y = mapy - 1;
                        break;
                    case 8:
                        adj_x = mapx + 1;
                        adj_y = mapy;
                        break;
                    default:
                        break;

                }

                switch (layer_idx)
                {
                    case (int)layer_types.LAYER_ZAP:
                        {
                            int adjacent_zap_glyph = _mapData[mapx, mapy].Layers.layer_gui_glyphs[(int)layer_types.LAYER_ZAP];
                            ulong adjacent_layer_flags = (ulong)_mapData[mapx, mapy].Layers.layer_flags;

                            if (adjacent_zap_glyph == GHApp.NoGlyph) // || !glyph_is_zap(adjacent_zap_glyph))
                                signed_glyph = GHApp.NoGlyph;
                            else
                                signed_glyph = _gnollHackService.ZapGlyphToCornerGlyph(adjacent_zap_glyph, adjacent_layer_flags, source_dir_idx);
                            break;
                        }
                    case (int)layer_types.LAYER_MONSTER:
                        {
                            /* Worm */
                            uint worm_id_stored = _mapData[mapx, mapy].Layers.m_id;
                            if (worm_id_stored == 0)
                                return false;

                            bool is_long_worm_with_tail = (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_LONG_WORM_WITH_TAIL) != 0;
                            bool is_long_worm_tail = (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_LONG_WORM_TAIL) != 0;
                            bool is_adj_worm_tail = (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_WORM_TAIL) != 0;
                            bool is_adj_worm_seen = (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_WORM_SEEN) != 0;
                            bool worm = !is_adj_worm_tail ? false : is_adj_worm_seen ? (worm_id_stored > 0 ? true : false) : true;
                            signed_glyph = GHApp.NoGlyph;

                            if (worm && (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_WORM_SEEN) != 0
                                && ((
                                _mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_CAN_SEE) != 0
                                || is_adj_worm_seen || (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_WORM_SEEN) != 0))
                            {
                                if (is_long_worm_with_tail && !is_adj_worm_tail)
                                {
                                    signed_glyph = GHApp.NoGlyph;
                                }
                                else if (is_long_worm_tail || (is_long_worm_with_tail && is_adj_worm_tail))
                                {
                                    int signed_main_glyph = _mapData[mapx, mapy].Layers.layer_gui_glyphs[layer_idx];
                                    int main_glyph = Math.Abs(signed_main_glyph);
                                    //int tile_animation_index = _gnollHackService.GetTileAnimationIndexFromGlyph(main_glyph);
                                    int main_tile = GHApp.Glyph2Tile[main_glyph];
                                    int wormautodraw = GHApp.Tile2Autodraw[main_tile];
                                    int base_source_glyph = GHApp.NoGlyph;
                                    if (wormautodraw > 0)
                                    {
                                        base_source_glyph = GHApp._autodraws[wormautodraw].source_glyph4;
                                    }

                                    int wdir = _mapData[mapx, mapy].Layers.wsegdir;
                                    int tilenum = -1;
                                    if (wdir % 2 == 1)
                                    {
                                        switch (source_dir_idx)
                                        {
                                            case 2:
                                                if (wdir == 7)
                                                {
                                                    //tilenum = GENERAL_TILE_WORM_IS_UP_GOING_DOWN_LEFT;
                                                    tilenum = 1; //GENERAL_TILE_WORM_IS_DOWN_GOING_UP_LEFT;
                                                    manual_vflip = true;
                                                }
                                                else if (wdir == 5)
                                                {
                                                    //tilenum = GENERAL_TILE_WORM_IS_UP_GOING_DOWN_RIGHT;
                                                    tilenum = 3; // GENERAL_TILE_WORM_IS_UP_GOING_DOWN_RIGHT;
                                                    manual_hflip = false;
                                                    manual_vflip = false;
                                                }
                                                break;
                                            case 4:
                                                if (wdir == 1)
                                                {
                                                    //tilenum = GENERAL_TILE_WORM_IS_RIGHT_GOING_UP_LEFT;
                                                    tilenum = 0;  //GENERAL_TILE_WORM_IS_RIGHT_GOING_UP_LEFT;
                                                    manual_hflip = false;
                                                    manual_vflip = false;
                                                }
                                                else if (wdir == 7)
                                                {
                                                    //tilenum = GENERAL_TILE_WORM_IS_RIGHT_GOING_DOWN_LEFT;
                                                    tilenum = 0; // GENERAL_TILE_WORM_IS_RIGHT_GOING_UP_LEFT;
                                                    manual_hflip = false;
                                                    manual_vflip = true;
                                                }
                                                break;
                                            case 6:
                                                if (wdir == 1)
                                                {
                                                    //tilenum = GENERAL_TILE_WORM_IS_DOWN_GOING_UP_LEFT;
                                                    tilenum = 1; // GENERAL_TILE_WORM_IS_DOWN_GOING_UP_LEFT;
                                                    manual_hflip = false;
                                                    manual_vflip = false;
                                                }
                                                else if (wdir == 3)
                                                {
                                                    //tilenum = GENERAL_TILE_WORM_IS_DOWN_GOING_UP_RIGHT;
                                                    tilenum = 3; // GENERAL_TILE_WORM_IS_UP_GOING_DOWN_RIGHT;
                                                    manual_hflip = false;
                                                    manual_vflip = true;
                                                }
                                                break;
                                            case 8:
                                                if (wdir == 3)
                                                {
                                                    //tilenum = GENERAL_TILE_WORM_IS_LEFT_GOING_UP_RIGHT;
                                                    tilenum = 2; // GENERAL_TILE_WORM_IS_LEFT_GOING_DOWN_RIGHT;
                                                    manual_hflip = false;
                                                    manual_vflip = true;
                                                }
                                                else if (wdir == 5)
                                                {
                                                    //tilenum = GENERAL_TILE_WORM_IS_LEFT_GOING_DOWN_RIGHT;
                                                    tilenum = 2; // GENERAL_TILE_WORM_IS_LEFT_GOING_DOWN_RIGHT;
                                                    manual_hflip = false;
                                                    manual_vflip = false;
                                                }
                                                break;
                                            default:
                                                break;
                                        }
                                        if (tilenum > -1)
                                            signed_glyph = tilenum + base_source_glyph;
                                    }
                                }
                            }
                            break;
                        }
                    case (int)layer_types.LAYER_CHAIN:
                        {
                            /* Chain */
                            if ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_O_CHAIN) != 0)
                            {
                                signed_glyph = (source_dir_idx / 2 - 1) + (int)general_tile_types.GENERAL_TILE_CHAIN_IS_UP + GHApp.GeneralTileOff;
                            }
                            else
                                signed_glyph = GHApp.NoGlyph;
                            break;
                        }
                }
            }
            else
            {
                int used_layer_idx = layer_idx;
                if (layer_idx == (int)layer_types.MAX_LAYERS)
                    used_layer_idx = (int)layer_types.LAYER_MONSTER;
                signed_glyph = _mapData[mapx, mapy].Layers.layer_gui_glyphs == null ? GHApp.NoGlyph : _mapData[mapx, mapy].Layers.layer_gui_glyphs[used_layer_idx];
            }

            if (signed_glyph == GHApp.NoGlyph)
                return false;

            return true;
        }

        float GetScaledYHeightChange(int layer_idx, int sub_layer_idx, int sub_layer_cnt, float height, int monster_height, int feature_doodad_height, float targetscale, bool is_monster_like_layer, bool tileflag_halfsize, ObjectDataItem otmp_round)
        {
            float scaled_y_height_change = 0;
            if ((!tileflag_halfsize || monster_height > 0) && is_monster_like_layer)
            {
                scaled_y_height_change = (float)-monster_height * height / (float)GHConstants.TileHeight;
                if (monster_height < 0)
                    scaled_y_height_change -= GHConstants.PIT_BOTTOM_BORDER * targetscale;
            }
            else if (tileflag_halfsize && (layer_idx == (int)layer_types.LAYER_OBJECT || layer_idx == (int)layer_types.LAYER_COVER_OBJECT))
            {
                if(otmp_round != null && (otmp_round.OtypData.is_uball != 0 || otmp_round.OtypData.is_uchain != 0))
                    scaled_y_height_change = 0;
                else
                    scaled_y_height_change = (float)(-(sub_layer_cnt - 1 - sub_layer_idx) * GHConstants.OBJECT_PILE_HEIGHT_DIFFERENCE - GHConstants.OBJECT_PILE_START_HEIGHT) * targetscale;
            }
            else if (feature_doodad_height != 0 && layer_idx == (int)layer_types.LAYER_FEATURE_DOODAD)
            {
                scaled_y_height_change = (float)-feature_doodad_height * height / (float)GHConstants.TileHeight;
            }
            return scaled_y_height_change;
        }

        void GetFlips(int signed_glyph, bool manual_hflip, bool manual_vflip, ref bool hflip_glyph, ref bool vflip_glyph)
        {
            int glyph = Math.Abs(signed_glyph);
            /* Tile flips */
            bool tileflag_hflip = (GHApp.GlyphTileFlags[glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_FLIP_HORIZONTALLY) != 0;
            bool tileflag_vflip = (GHApp.GlyphTileFlags[glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_FLIP_VERTICALLY) != 0;

            /* Base flips */
            bool hflip = (signed_glyph < 0);

            /* Final glyph flips */
            if ((hflip != tileflag_hflip) != manual_hflip) /* XOR */
                hflip_glyph = true;
            else
                hflip_glyph = false;

            if (tileflag_vflip != manual_vflip) /* XOR */
                vflip_glyph = true;
            else
                vflip_glyph = false;
        }

        void CheckShowingDetection(bool showing_detection, ref short obj_height, ref bool tileflag_floortile, ref bool tileflag_height_is_clipping)
        {
            if (showing_detection)
            {
                obj_height = 0;
                tileflag_floortile = false;
                tileflag_height_is_clipping = false;
            }
        }

        SKColor _dustColor = new SKColor(64, 64, 64, 127);
        SKColor _engraveOutlineColor = new SKColor(96, 96, 96, 63);
        SKColor _engraveFillColor = new SKColor(64, 64, 64, 191);
        SKColor _burnOutlineColor = SKColors.Black.WithAlpha(63);
        SKColor _burnFillColor = SKColors.Black.WithAlpha(191);
        SKColor _bloodOutlineColor = SKColors.Red.WithAlpha(63);
        SKColor _bloodFillColor = SKColors.Red.WithAlpha(191);
        SKColor _headStoneFillColor = new SKColor(96, 96, 96, 191);
        SKColor _headStoneOutlineColor = new SKColor(160, 160, 160, 191);
        SKColor _signPostFillColor = SKColors.Brown.WithAlpha(191);
        SKColor _signPostOutlineColor = SKColors.SandyBrown.WithAlpha(191);
        SKColor _magicShineOutlineColor = SKColors.Cyan;
        float[] _shineAnimation = new float[]
        {
            0.0f,
            0.0f,
            0.0f,
            0.0f,
            0.0025f,
            0.005f,
            0.0075f,
            0.01f,
            0.0125f,
            0.015f,
            0.0175f,
            0.02f,
            0.0275f,
            0.035f,
            0.0425f,
            0.05f,
            0.0625f,
            0.0750f,
            0.0875f,
            0.1f,
            0.125f,
            0.15f,
            0.175f,
            0.2f,
            0.225f,
            0.25f,
            0.275f,
            0.3f,
            0.325f,
            0.35f,
            0.375f,
            0.4f,
            0.425f,
            0.45f,
            0.475f,
            0.5f,
            0.525f,
            0.55f,
            0.575f,
            0.6f,
            0.625f,
            0.65f,
            0.675f,
            0.7f,
            0.725f,
            0.75f,
            0.775f,
            0.8f,
            0.825f,
            0.875f,
            0.875f,
            0.9f,
            0.9125f,
            0.925f,
            0.9375f,
            0.95f,
            0.9575f,
            0.965f,
            0.9725f,
            0.98f,
            0.9825f,
            0.985f,
            0.9875f,
            0.99f,
            0.9925f,
            0.995f,
            0.9975f,
            1.0f,
            0.9975f,
            0.995f,
            0.9925f,
            0.99f,
            0.9875f,
            0.985f,
            0.9825f,
            0.98f,
            0.9725f,
            0.965f,
            0.9575f,
            0.95f,
            0.9375f,
            0.925f,
            0.9125f,
            0.9f,
            0.875f,
            0.875f,
            0.825f,
            0.8f,
            0.775f,
            0.775f,
            0.725f,
            0.7f,
            0.675f,
            0.675f,
            0.625f,
            0.6f,
            0.575f,
            0.575f,
            0.525f,
            0.5f,
            0.475f,
            0.475f,
            0.425f,
            0.4f,
            0.375f,
            0.375f,
            0.325f,
            0.3f,
            0.275f,
            0.275f,
            0.225f,
            0.2f,
            0.175f,
            0.175f,
            0.125f,
            0.1f,
            0.0875f,
            0.0750f,
            0.0625f,
            0.05f,
            0.0425f,
            0.035f,
            0.0275f,
            0.02f,
            0.0175f,
            0.015f,
            0.0125f,
            0.01f,
            0.0075f,
            0.005f,
            0.0025f,
            0.0f,
            0.0f,
            0.0f,
            0.0f,
        };

        void DrawEngraving(SKCanvas canvas, GHSkiaFontPaint textPaint, int mapx, int mapy, float offsetX, float offsetY, float usedOffsetX, float usedOffsetY, float mapFontAscent,
            float width, float height, long generalcountervalue)
        {
            /* Skip drawing certain engravings */
            switch (_mapData[mapx, mapy].Engraving.EngrType)
            {
                case (int)EngravingType.ENGR_HEADSTONE:
                case (int)EngravingType.ENGR_SIGNPOST:
                    return;
                default:
                    break;
            }

            /* Draw engraving */
            if (_mapData[mapx, mapy].Engraving.Text != null && _mapData[mapx, mapy].Engraving.Text != "" && _mapData[mapx, mapy].Engraving.RowSplit != null)
            {
                int len = _mapData[mapx, mapy].Engraving.Text.Length;
                SKColor oldcolor = textPaint.Color;
                SKTypeface oldtypeface = textPaint.Typeface;
                float oldtextsize = textPaint.TextSize;
                textPaint.TextSize = 10;
                if ((_mapData[mapx, mapy].Engraving.GeneralFlags & 1) != 0)
                    textPaint.Typeface = GHApp.EndorTypeface;
                else
                    textPaint.Typeface = GHApp.EndorTypeface;

                SKColor outlineColor = SKColors.Black;
                SKColor fillColor = SKColors.Black;
                bool hasOutline = false;
                switch (_mapData[mapx, mapy].Engraving.EngrType)
                {
                    case (int)EngravingType.DUST:
                        fillColor = _dustColor;
                        break;
                    case (int)EngravingType.ENGRAVE:
                        hasOutline = true;
                        fillColor = _engraveFillColor;
                        outlineColor = _engraveOutlineColor;
                        break;
                    case (int)EngravingType.BURN:
                        hasOutline = true;
                        fillColor = _burnFillColor;
                        outlineColor = _burnOutlineColor;
                        break;
                    case (int)EngravingType.ENGR_BLOOD:
                        hasOutline = true;
                        fillColor = _bloodFillColor;
                        outlineColor = _bloodOutlineColor;
                        break;
                    case (int)EngravingType.ENGR_HEADSTONE:
                        hasOutline = true;
                        fillColor = _headStoneFillColor;
                        outlineColor = _headStoneOutlineColor;
                        break;
                    case (int)EngravingType.ENGR_SIGNPOST:
                        hasOutline = true;
                        fillColor = _signPostFillColor;
                        outlineColor = _signPostOutlineColor;
                        break;
                    default:
                        textPaint.Color = SKColors.Black;
                        break;
                }

                float atwidth = textPaint.MeasureText("A");
                if (atwidth > 0)
                {
                    float wpadding = width / 32;
                    float stwidth = atwidth * 4;
                    int rowcnt = _mapData[mapx, mapy].Engraving.RowSplit.Length;
                    float rscale = (width - 2 * wpadding) / stwidth;
                    float prerowheight = textPaint.FontSpacing * rscale;
                    float rowhscale = prerowheight * rowcnt > height ? height / (prerowheight * rowcnt) : 1.0f;
                    float rowheight = prerowheight * rowhscale;
                    for (int rowidx = 0, num_s = _mapData[mapx, mapy].Engraving.RowSplit.Length; rowidx < num_s; rowidx++)
                    {
                        string str = _mapData[mapx, mapy].Engraving.RowSplit[rowidx];
                        textPaint.TextSize = 10;
                        float twidth = textPaint.MeasureText(str);
                        float usedtwidth = twidth > stwidth ? twidth : stwidth;
                        float tscale = rowhscale * (width - 2 * wpadding) / usedtwidth;
                        textPaint.TextSize = tscale * 10;
                        float act_text_width = twidth * tscale;
                        float tx = offsetX + usedOffsetX + width * (float)mapx + wpadding + (width - act_text_width) / 2;
                        float ty = offsetY + usedOffsetY + height * (float)mapy + mapFontAscent - textPaint.FontMetrics.Ascent
                            + (height - rowheight * rowcnt) / 2 + rowidx * rowheight + (rowheight - textPaint.FontSpacing) / 2;
                        textPaint.Style = SKPaintStyle.Fill;
                        textPaint.Color = fillColor;
                        //canvas.DrawText(str, tx, ty, textPaint);
                        textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
                        if (hasOutline)
                        {
                            textPaint.Style = SKPaintStyle.Stroke;
                            textPaint.Color = outlineColor;
                            textPaint.StrokeWidth = textPaint.TextSize / 5;
                            //canvas.DrawText(str, tx, ty, textPaint);
                            textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
                        }
                        if ((_mapData[mapx, mapy].Engraving.GeneralFlags & 1) != 0)
                        {
                            textPaint.Style = SKPaintStyle.Fill;
                            int alen = _shineAnimation.Length;
                            textPaint.Color = _magicShineOutlineColor.WithAlpha((byte)(_shineAnimation[generalcountervalue % alen] * 255));
                            //canvas.DrawText(str, tx, ty, textPaint);
                            textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
                        }
                    }
                }
                textPaint.Color = oldcolor;
                textPaint.Typeface = oldtypeface;
                textPaint.TextSize = oldtextsize;
                textPaint.Style = SKPaintStyle.Fill;
            }
        }

        void GetBaseMoveOffsets(int mapx, int mapy, sbyte monster_origin_x, sbyte monster_origin_y, float width, float height, long maincounterdiff, long moveIntervals, ref float base_move_offset_x, ref float base_move_offset_y)
        {
            int movediffx = (int)monster_origin_x - mapx;
            int movediffy = (int)monster_origin_y - mapy;
            if (GHUtils.isok(monster_origin_x, monster_origin_y)
                && (movediffx != 0 || movediffy != 0)
                && maincounterdiff >= 0 && maincounterdiff < moveIntervals)
            {
                base_move_offset_x = width * (float)movediffx * (float)(moveIntervals - maincounterdiff) / (float)moveIntervals;
                base_move_offset_y = height * (float)movediffy * (float)(moveIntervals - maincounterdiff) / (float)moveIntervals;
            }

        }

        //private float[] _foundAnimationNormal = { 10f, 20f, 30f, 40f, 45f, 50f, 55f, 57.5f, 60f, 57.5f, 55f, 50f, 45f, 40f, 30f, 20f, 10f, 0f };
        //private float[] _foundAnimationHigh = { 10f, 20f, 30f, 40f, 50f, 60f, 70f, 80f, 88f, 96f, 102f, 108f, 114f, 118f, 120f, 118f, 114f, 108f, 102f, 96f, 88f, 80f, 70f, 60f, 50f, 40f, 30f, 20f, 10f, 0f };
        private float[] _foundAnimationFactor = { 0.10f, 0.20f, 0.30f, 0.40f, 0.50f, 0.60f, 0.70f, 0.80f, 0.88f, 0.94f, 0.98f, 1.0f, 0.98f, 0.94f, 0.88f, 0.80f, 0.70f, 0.60f, 0.50f, 0.40f, 0.30f, 0.20f, 0.10f, 0f };

        void GetObjectMoveOffsets(int mapx, int mapy, sbyte object_origin_x, sbyte object_origin_y, float width, float height, long objectcounterdiff, long moveIntervals, long generalcounterdiff, bool foundthisturn, int sub_layer_idx, int sub_layer_cnt, float targetscale, bool loc_is_you, float obj_height, ObjectDataItem otmp_round, ref float object_move_offset_x, ref float object_move_offset_y)
        {
            if(GHUtils.isok(object_origin_x, object_origin_y))
            {
                int objectmovediffx = (int)object_origin_x - mapx;
                int objectmovediffy = (int)object_origin_y - mapy;

                if (objectmovediffx != 0 || objectmovediffy != 0)
                {
                    bool use_objcounter = otmp_round == null || (otmp_round.ObjData.o_id > 0 && otmp_round.ObjData.o_id == _mapData[mapx, mapy].Layers.o_id);
                    long usedcounterdiff = use_objcounter ? objectcounterdiff : generalcounterdiff;
                    if (usedcounterdiff >= 0 && usedcounterdiff < moveIntervals)
                    {
                        object_move_offset_x = width * (float)objectmovediffx * (float)(moveIntervals - usedcounterdiff) / (float)moveIntervals;
                        object_move_offset_y = height * (float)objectmovediffy * (float)(moveIntervals - usedcounterdiff) / (float)moveIntervals;
                    }
                }
            }
            if (foundthisturn)
            {
                long usedcounterdiff = generalcounterdiff - 3L * sub_layer_idx;
                float usedobjheight = obj_height == 0 ? GHConstants.TileHeight / 2 : obj_height;
                float highestpoint = (loc_is_you ? 1.5f : 1.0f) * GHConstants.TileHeight - usedobjheight - (sub_layer_cnt - 1 - sub_layer_idx) * GHConstants.OBJECT_PILE_HEIGHT_DIFFERENCE - GHConstants.OBJECT_PILE_START_HEIGHT;
                if (usedcounterdiff >= 0 && usedcounterdiff < _foundAnimationFactor.Length)
                    object_move_offset_y -= highestpoint * _foundAnimationFactor[usedcounterdiff] * targetscale;
            }
        }

        int GetTileFromAnimation(GHAnimationTimerList localTimers, int ntile, int glyph, int mapx, int mapy, int layer_idx, long generalcountervalue, bool is_monster_or_shadow_layer,
            ref int anim_frame_idx, ref int main_tile_idx, ref int autodraw)
        {
            sbyte mapAnimated = 0;
            int tile_animation_idx = _gnollHackService.GetTileAnimationIndexFromGlyph(glyph);
            bool is_dropping_piercer = (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_DROPPING_PIERCER) != 0;
            if (localTimers.u_action_animation_counter_on && is_monster_or_shadow_layer && ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_UXUY) != 0))
                ntile = _gnollHackService.GetAnimatedTile(ntile, tile_animation_idx, (int)animation_play_types.ANIMATION_PLAY_TYPE_PLAYED_SEPARATELY, localTimers.u_action_animation_counter, out anim_frame_idx, out main_tile_idx, out mapAnimated, ref autodraw);
            else if (localTimers.m_action_animation_counter_on && ((!is_dropping_piercer && is_monster_or_shadow_layer) || (is_dropping_piercer && layer_idx == (int)layer_types.LAYER_MISSILE)) && localTimers.m_action_animation_x == mapx && localTimers.m_action_animation_y == mapy)
                ntile = _gnollHackService.GetAnimatedTile(ntile, tile_animation_idx, (int)animation_play_types.ANIMATION_PLAY_TYPE_PLAYED_SEPARATELY, localTimers.m_action_animation_counter, out anim_frame_idx, out main_tile_idx, out mapAnimated, ref autodraw);
            else if (_gnollHackService.GlyphIsExplosion(glyph))
                ntile = _gnollHackService.GetAnimatedTile(ntile, tile_animation_idx, (int)animation_play_types.ANIMATION_PLAY_TYPE_PLAYED_SEPARATELY, localTimers.explosion_animation_counter, out anim_frame_idx, out main_tile_idx, out mapAnimated, ref autodraw);
            else if (_gnollHackService.GlyphIsZap(glyph))
            {
                for (int zap_anim_idx = 0; zap_anim_idx < GHConstants.MaxPlayedZapAnimations; zap_anim_idx++)
                {
                    if (localTimers.zap_animation_counter_on[zap_anim_idx]
                        && mapx == localTimers.zap_animation_x[zap_anim_idx]
                        && mapy == localTimers.zap_animation_y[zap_anim_idx])
                    {
                        ntile = _gnollHackService.GetAnimatedTile(ntile, tile_animation_idx, (int)animation_play_types.ANIMATION_PLAY_TYPE_PLAYED_SEPARATELY, localTimers.zap_animation_counter[zap_anim_idx], out anim_frame_idx, out main_tile_idx, out mapAnimated, ref autodraw);
                        break;
                    }
                }
            }
            else
            {
                /* Check for special effect animations */
                bool spef_found = false;
                for (int spef_idx = 0; spef_idx < GHConstants.MaxPlayedSpecialEffects; spef_idx++)
                {
                    if (localTimers.special_effect_animation_counter_on[spef_idx]
                        && layer_idx == (int)localTimers.spef_action_animation_layer[spef_idx]
                        && mapx == localTimers.spef_action_animation_x[spef_idx]
                        && mapy == localTimers.spef_action_animation_y[spef_idx])
                    {
                        ntile = _gnollHackService.GetAnimatedTile(ntile, tile_animation_idx, (int)animation_play_types.ANIMATION_PLAY_TYPE_PLAYED_SEPARATELY, localTimers.special_effect_animation_counter[spef_idx], out anim_frame_idx, out main_tile_idx, out mapAnimated, ref autodraw);
                        spef_found = true;
                        break;
                    }
                }

                /* Otherwise, normal animation check */
                if (!spef_found)
                    ntile = _gnollHackService.GetAnimatedTile(ntile, tile_animation_idx, (int)animation_play_types.ANIMATION_PLAY_TYPE_ALWAYS, generalcountervalue, out anim_frame_idx, out main_tile_idx, out mapAnimated, ref autodraw);
            }
            return ntile;
        }

        private void GetMapOffsetsLocal(float canvaswidth, float canvasheight, float mapwidth, float mapheight, float width, float height, out float offsetX, out float offsetY, out float usedOffsetX, out float usedOffsetY)
        {
            offsetX = (canvaswidth - mapwidth) / 2;
            offsetY = (canvasheight - mapheight) / 2;
            usedOffsetX = _localMapOffsetX;
            usedOffsetY = _localMapOffsetY;

            if (ZoomMiniMode)
            {
                usedOffsetX = _localMapMiniOffsetX;
                usedOffsetY = _localMapMiniOffsetY;
            }
            else
            {
                if (_localClipX > 0 && (mapwidth > canvaswidth || mapheight > canvasheight))
                {
                    offsetX -= (_localClipX - (GHConstants.MapCols - 1) / 2) * width;
                    offsetY -= (_localClipY - GHConstants.MapRows / 2) * height;
                }
            }
        }

        private void GetMapOffsets(float canvaswidth, float canvasheight, float mapwidth, float mapheight, float width, float height, out float offsetX, out float offsetY, out float usedOffsetX, out float usedOffsetY)
        {
            offsetX = (canvaswidth - mapwidth) / 2;
            offsetY = (canvasheight - mapheight) / 2;
            lock (_mapOffsetLock)
            {
                usedOffsetX = _mapOffsetX;
                usedOffsetY = _mapOffsetY;
            }
            if (ZoomMiniMode)
            {
                lock (_mapOffsetLock)
                {
                    usedOffsetX = _mapMiniOffsetX;
                    usedOffsetY = _mapMiniOffsetY;
                }
            }
            else
            {
                lock (_clipLock)
                {
                    if (_clipX > 0 && (mapwidth > canvaswidth || mapheight > canvasheight))
                    {
                        offsetX -= (_clipX - (GHConstants.MapCols - 1) / 2) * width;
                        offsetY -= (_clipY - GHConstants.MapRows / 2) * height;
                    }
                }
            }
        }

        //private SKBitmap _enlargementBitmap = null;

#if GNH_MAP_PROFILING && DEBUG
        long _totalFrames = 0L;
#endif
        private readonly StringBuilder _lineBuilder = new StringBuilder(GHConstants.LineBuilderInitialCapacity);
        private readonly string[] _attributeStrings = new string[6] { "Strength:", "Dexterity:", "Constitution:", "Intelligence:", "Wisdom:", "Charisma:" };
        private readonly short[,] _draw_shadow = new short[GHConstants.MapCols, GHConstants.MapRows];
        private readonly GHAnimationTimerList _localAnimationTimers = new GHAnimationTimerList();
        private readonly ObjectDataItem[] _localWeaponStyleObjDataItem = new ObjectDataItem[3];
        private readonly GHStatusField[] _localStatusFields = new GHStatusField[(int)NhStatusFields.MAXBLSTATS];
        private int _local_ux = 0;
        private int _local_uy = 0;
        private ulong _local_u_condition_bits = 0;
        private ulong _local_u_status_bits = 0;
        private ulong[] _local_u_buff_bits = new ulong[GHConstants.NUM_BUFF_BIT_ULONGS];

        private GHScreenText _localScreenText = null;
        private readonly List<GHFloatingText> _localFloatingTexts = new List<GHFloatingText>();
        private readonly List<GHConditionText> _localConditionTexts = new List<GHConditionText>();
        private readonly List<GHScreenFilter> _localScreenFilters = new List<GHScreenFilter>();
        private readonly List<GHGUIEffect> _localGuiEffects = new List<GHGUIEffect>();

        private GHMsgHistorySpan _localMsgHistory = null;
        private int _localClipX = 0;
        private int _localClipY = 0;
        private float _localMapOffsetX = 0;
        private float _localMapOffsetY = 0;
        private float _localMapMiniOffsetX = 0;
        private float _localMapMiniOffsetY = 0;
        private readonly List<GHPetDataItem> _localPetData = new List<GHPetDataItem>(8);
        private readonly List<SKRect> _localPetRects = new List<SKRect>(8);
        private readonly List<ContextMenuButton> _localContextMenuData = new List<ContextMenuButton>(10);
        private readonly List<SKRect> _localContextMenuRects = new List<SKRect>(10);
        private bool _localIsPointerHovering = false;
        private SKPoint _localPointerHoverLocation = new SKPoint();
#if WINDOWS
        GameCursorType _localCurrentCursorType = GameCursorType.Normal;
#endif
        private SKRect _localCanvasButtonRect = new SKRect(0, 0, 0, 0);
        private int _localQuickWandGlyph, _localQuickWandExceptinality, _localQuickSpellGlyph, _localQuickSpellOtyp;
        private string _localQuickWandName, _localQuickSpellName;
        //private double _localFps = 0.0;
        private long _localMemUsage = 0L;
        public float _localStatusOffsetY = 0;
        public float _localStatusLargestBottom = 0;
        public float _localStatusClipBottom = 0;
        private int _localMapCursorX;
        private int _localMapCursorY;

        private readonly object _savedCanvasLock = new object();
        private float _savedCanvasWidth = 0;
        private float _savedCanvasHeight = 0;

        private readonly SKColor[] _gridColorArray = new SKColor[21]
        {
            SKColors.Black,
            SKColors.Black.WithAlpha((255 * 5) / 100),
            SKColors.Black.WithAlpha((255 * 10) / 100),
            SKColors.Black.WithAlpha((255 * 15) / 100),
            SKColors.Black.WithAlpha((255 * 20) / 100),
            SKColors.Black.WithAlpha((255 * 25) / 100),
            SKColors.Black.WithAlpha((255 * 30) / 100),
            SKColors.Black.WithAlpha((255 * 35) / 100),
            SKColors.Black.WithAlpha((255 * 40) / 100),
            SKColors.Black.WithAlpha((255 * 45) / 100),
            SKColors.Black.WithAlpha((255 * 50) / 100),
            SKColors.Black.WithAlpha((255 * 55) / 100),
            SKColors.Black.WithAlpha((255 * 60) / 100),
            SKColors.Black.WithAlpha((255 * 65) / 100),
            SKColors.Black.WithAlpha((255 * 70) / 100),
            SKColors.Black.WithAlpha((255 * 75) / 100),
            SKColors.Black.WithAlpha((255 * 80) / 100),
            SKColors.Black.WithAlpha((255 * 85) / 100),
            SKColors.Black.WithAlpha((255 * 90) / 100),
            SKColors.Black.WithAlpha((255 * 95) / 100),
            SKColors.Black,
        };

        private void PaintMainGamePage(object sender, SKPaintSurfaceEventArgs e, bool isCanvasOnMainThread)
        {
            if (!IsMainCanvasOn || GHApp.IsReplaySearching)
                return;

            SKImageInfo info = e.Info;
            SKSurface surface = e.Surface;
            SKCanvas canvas = surface.Canvas;
            float canvaswidth = e.Info.Width; // MainCanvasView.CanvasSize.Width;
            float canvasheight = e.Info.Height; // MainCanvasView.CanvasSize.Height;

            canvas.Clear(SKColors.Black);
            if (canvaswidth <= 16 || canvasheight <= 16)
                return;

            bool lockTaken = false;
            try
            {
                Monitor.TryEnter(_savedCanvasLock, ref lockTaken);
                if (lockTaken)
                {
                    _savedCanvasWidth = canvaswidth;
                    _savedCanvasHeight = canvasheight;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_savedCanvasLock);
            }
            lockTaken = false;

            SKRect statusBarRect = new SKRect();
            SKRect healthRect = new SKRect();
            SKRect manaRect = new SKRect();
            SKRect skillRect = new SKRect();
            SKRect prevWepRect = new SKRect();
            SKRect youRect = new SKRect();
            //bool skillRectDrawn = false;
            //bool prevWepRectDrawn = false;
            //bool healthRectDrawn = false;
            //bool manaRectDrawn = false;
            //bool statusBarRectDrawn = false;
            //bool youRectDrawn = false;

            bool drawwallends = DrawWallEnds;
            bool breatheanimations = BreatheAnimations;
            bool fixRects = GHApp.FixRects;
            bool usingGL = UseMainGLCanvas;
            bool usingMipMap = UseMainMipMap;
            bool usingDesktopButtons = DesktopButtons;
            bool usingSimpleCmdLayout = UseSimpleCmdLayout;
            bool mapGrid = MapGrid;
            bool hitPointBars = HitPointBars;
            bool playerMark = PlayerMark;
            bool monsterTargeting = MonsterTargeting;
            bool forceAllMessages = ForceAllMessages;
            bool forceAscii = ForceAscii;
            bool mapLookMode = MapLookMode;
            bool zoomMiniMode = ZoomMiniMode;
            bool showDirections = ShowDirections;
            bool showNumberPad = ShowNumberPad;
            bool mapWalkMode = MapWalkMode;
            bool walkArrows = WalkArrows;
            GHGraphicsStyle graphicsStyle = GraphicsStyle;
            int gridOpacity = GridOpacity;
            if (gridOpacity < 0 || gridOpacity > 20)
                gridOpacity = 0;

            bool isLandscape = canvaswidth > canvasheight;

            _drawCommandList.Clear();

#if GNH_MAP_PROFILING && DEBUG
            _totalFrames++;
            if (_totalFrames <= 0)
                _totalFrames = 1;
#endif
            //if (_enlargementBitmap == null || _enlargementBitmap.Width != (int)canvaswidth || _enlargementBitmap.Height != (int)canvasheight)
            //    _enlargementBitmap = new SKBitmap(Math.Max(1, (int)canvaswidth), Math.Max(1, (int)canvasheight));

            //double canvas_scale = GetCanvasScale();
            //float inverse_canvas_scale = canvas_scale == 0 ? 0.0f : 1.0f / (float)canvas_scale;
            double stdButtonWidth = StandardMeasurementButton.ThreadSafeWidth;
            double stdButtonHeight = StandardMeasurementButton.ThreadSafeHeight;
            double stdButtonY = StandardMeasurementButton.ThreadSafeY;
            double canvasViewWidth = MainCanvasView.ThreadSafeWidth;
            double canvasViewHeight = MainCanvasView.ThreadSafeHeight;
            Thickness stdCmdLayoutMargin = StandardMeasurementCmdLayout.ThreadSafeMargin;
            double stdCmdLayoutHeight = StandardMeasurementCmdLayout.ThreadSafeHeight;
            double usedButtonRowStackHeight = UsedButtonRowStack.ThreadSafeHeight;
            double stdRefButtonWidth = StandardReferenceButton.ThreadSafeWidth;
            double stdRefButtonHeight = StandardReferenceButton.ThreadSafeHeight;
            double gamePageHeight = this.ThreadSafeHeight;

            float inverse_canvas_scale = GHApp.DisplayDensity;
            float customScale = GHApp.CustomScreenScale;
            float textscale = UIUtils.CalculateTextScale(inverse_canvas_scale, customScale);// GetTextScaleEx(MainCanvasView.Width, MainCanvasView.Height, usingDesktopButtons, usingSimpleCmdLayout, inverse_canvas_scale, customScale);
            float statusBarTextMultiplier = UIUtils.CalculateStatusBarFontSizeMultiplier(canvasViewWidth, canvasViewHeight);
            float statusBarTextScale = textscale * statusBarTextMultiplier;
            float statusBarSkiaHeight = UIUtils.CalculateStatusBarSkiaHeight(statusBarTextScale); // GetStatusBarSkiaHeightEx(textscale);
            float messageTextMultiplier = UIUtils.CalculateMessageFontSizeMultiplier(stdButtonWidth, stdButtonHeight, statusBarSkiaHeight, textscale * GHConstants.WindowMessageFontSize, 
                canvaswidth, canvasheight, canvasViewWidth, canvasViewHeight, usingDesktopButtons, usingSimpleCmdLayout, inverse_canvas_scale, customScale);
            float messageTextScale = textscale * messageTextMultiplier;
            MapRefreshRateStyle mapRefreshRate = MapRefreshRate;
            double mainCounter2AnimationMultiplier = GetMainCounterIncrementMultiplierForGUIAnimations(mapRefreshRate); /* Many animations using generalcounterdiff used to be benchmarked to 60 FPS */
            if (mainCounter2AnimationMultiplier <= 0.0)
                mainCounter2AnimationMultiplier = 1.0;

            bool clearDarkeningCaches = false;
            if (Interlocked.Exchange(ref _lighterDarkeningUpdated, 0) == 1) // Original value was 1, so clearing caches
                clearDarkeningCaches = true;

            //lock (_lighterDarkeningLock)
            //{
            //    if (_lighterDarkeningUpdated)
            //    {
            //        clearDarkeningCaches = true;
            //        _lighterDarkeningUpdated = false;
            //    }
            //}
            if (clearDarkeningCaches)
            {
                foreach (SKImage bmp in _darkenedBitmaps.Values)
                    bmp.Dispose();
                _darkenedBitmaps.Clear();
                foreach (SKImage bmp in _darkenedAutodrawBitmaps.Values)
                    bmp.Dispose();
                _darkenedAutodrawBitmaps.Clear();
            }

            GHGame curGame = GHApp.CurrentGHGame;
            if (curGame == null)
                return;

            long generalcountervalue, maincountervalue;
            maincountervalue = curGame.MainCounterValue; // Interlocked.CompareExchange(ref _mainCounterValue, 0L, 0L);
            /* Moved general_animation_counter outside of the lock to minimize the time spent in lock;  since InvalidateSurface is called after IncrementCounters and nothing else modifies general_animation_counter, generalcountervalue should be consistent of the copy result below */
            generalcountervalue = curGame.GeneralAnimationCounter; // Interlocked.CompareExchange(ref AnimationTimers.general_animation_counter, 0L, 0L);;
            //lock (AnimationTimerLock)
            //{
            //    /* Note that animation timer is updated too frequently so that it does not make sense to use TryEnter; however, since InvalidateSurface is called after IncrementCounters, there should practically never be a conflict here due to IncrementCounters */
            //    AnimationTimers.CopyTo(_localAnimationTimers, false);
            //}
            try
            {
                Monitor.TryEnter(curGame.AnimationTimerLock, ref lockTaken);
                if (lockTaken)
                {
                    curGame.AnimationTimers.CopyTo(_localAnimationTimers, false, false);
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(curGame.AnimationTimerLock);
            }
            lockTaken = false;

            _localAnimationTimers.CalculateCounterValues(generalcountervalue);

            //lock (_mainCounterLock)
            //{
            //    maincountervalue = Interlocked.CompareExchange(ref _mainCounterValue, 0L, 0L);
            //}

            try
            {
                Monitor.TryEnter(_clipLock, ref lockTaken);
                if (lockTaken)
                {
                    _localClipX = _clipX;
                    _localClipY = _clipY;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_clipLock);
            }
            lockTaken = false;

            try
            {
                Monitor.TryEnter(_mapOffsetLock, ref lockTaken);
                if (lockTaken)
                {
                    _localMapOffsetX = _mapOffsetX;
                    _localMapOffsetY = _mapOffsetY;
                    _localMapMiniOffsetX = _mapMiniOffsetX;
                    _localMapMiniOffsetY = _mapMiniOffsetY;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_mapOffsetLock);
            }
            lockTaken = false;

            //lock (_statusOffsetLock)
            try
            {
                Monitor.TryEnter(_statusOffsetLock, ref lockTaken);
                if (lockTaken)
                {
                    _localStatusOffsetY = _statusOffsetY;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_statusOffsetLock);
            }
            lockTaken = false;

            //lock (_weaponStyleObjDataItemLock)
            try
            {
                Monitor.TryEnter(curGame._weaponStyleObjDataItemLock, ref lockTaken);
                if (lockTaken)
                {
                    curGame._weaponStyleObjDataItem.CopyTo(_localWeaponStyleObjDataItem, 0);
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(curGame._weaponStyleObjDataItemLock);
            }
            lockTaken = false;

            //lock (StatusFieldLock)
            try
            {
                Monitor.TryEnter(curGame.StatusFieldLock, ref lockTaken);
                if (lockTaken)
                {
                    curGame.StatusFields.CopyTo(_localStatusFields, 0);
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(curGame.StatusFieldLock);
            }
            lockTaken = false;

            int u_x;
            int u_y;
            ulong status_bits;
            ulong condition_bits;

            int mapCursorX, mapCursorY;
            game_cursor_types cursorType;
            bool force_paint_at_cursor,show_cursor_on_u;
            MapData[,] mapBuffer;
            ObjectData[,] objectBuffer;
            ObjectDataItem uBall, uChain;
            if (curGame.GetMapDataBuffer(out mapBuffer, out objectBuffer, out uBall, out uChain, out u_x, out u_y, out condition_bits, out status_bits, ref _local_u_buff_bits,
                out mapCursorX, out mapCursorY, out cursorType, out force_paint_at_cursor, out show_cursor_on_u))
            {
                _mapData = mapBuffer;
                _objectData = objectBuffer;
                _uBall = uBall;
                _uChain = uChain;
                _local_u_condition_bits = condition_bits;
                _local_u_status_bits = status_bits;
                _local_ux = u_x;
                _local_uy = u_y;
                _localMapCursorX = mapCursorX;
                _localMapCursorY = mapCursorY;
                _cursorType = cursorType;
                _force_paint_at_cursor = force_paint_at_cursor;
                _show_cursor_on_u = show_cursor_on_u;
                lockTaken = false;
                //lock (_uLock)
                try
                {
                    Monitor.TryEnter(_uLock, ref lockTaken);
                    if (lockTaken)
                    {
                        _ux = u_x;
                        _uy = u_y;
                    }
                }
                finally
                {
                    if (lockTaken)
                        Monitor.Exit(_uLock);
                }
                lockTaken = false;
            }
            if (_mapData == null)
                return;

            lockTaken = false;
            //lock (_floatingTextLock)
            try
            {
                Monitor.TryEnter(_floatingTextLock, ref lockTaken);
                if (lockTaken)
                {
                    _localFloatingTexts.Clear();
                    _localFloatingTexts.AddRange(_floatingTexts);
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_floatingTextLock);
            }
            lockTaken = false;

            //lock (_screenTextLock)
            try
            {
                Monitor.TryEnter(_screenTextLock, ref lockTaken);
                if (lockTaken)
                {
                    _localScreenText = _screenText;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_screenTextLock);
            }
            lockTaken = false;

            //lock (_conditionTextLock)
            try
            {
                Monitor.TryEnter(_conditionTextLock, ref lockTaken);
                if (lockTaken)
                {
                    _localConditionTexts.Clear();
                    _localConditionTexts.AddRange(_conditionTexts);
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_conditionTextLock);
            }
            lockTaken = false;

            //lock (_screenFilterLock)
            try
            {
                Monitor.TryEnter(_screenFilterLock, ref lockTaken);
                if (lockTaken)
                {
                    _localScreenFilters.Clear();
                    _localScreenFilters.AddRange(_screenFilters);
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_screenFilterLock);
            }
            lockTaken = false;

            //lock (_guiEffectLock)
            try
            {
                Monitor.TryEnter(_guiEffectLock, ref lockTaken);
                if (lockTaken)
                {
                    _localGuiEffects.Clear();
                    _localGuiEffects.AddRange(_guiEffects);
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_guiEffectLock);
            }
            lockTaken = false;

            //lock (_petDataLock)
            try
            {
                Monitor.TryEnter(curGame._petDataLock, ref lockTaken);
                if (lockTaken)
                {
                    _localPetData.Clear();
                    _localPetData.AddRange(curGame._petData);
                    _localPetRects.Clear();
                    int petCnt = curGame._petData.Count;
                    for (int i = 0; i < petCnt; i++)
                        _localPetRects.Add(SKRect.Empty);
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(curGame._petDataLock);
            }
            lockTaken = false;

            //lock (_contextMenuDataLock)
            try
            {
                Monitor.TryEnter(curGame._contextMenuDataLock, ref lockTaken);
                if (lockTaken)
                {
                    _localContextMenuData.Clear();
                    _localContextMenuData.AddRange(curGame._contextMenuData);
                    _localContextMenuRects.Clear();
                    int cbCnt = curGame._contextMenuData.Count;
                    for (int i = 0; i < cbCnt; i++)
                        _localContextMenuRects.Add(SKRect.Empty);
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(curGame._contextMenuDataLock);
            }
            lockTaken = false;

            _localMsgHistory = Interlocked.CompareExchange(ref _msgHistory, null, null);
            ////lock (_msgHistoryLock)
            //try
            //{
            //    Monitor.TryEnter(_msgHistoryLock, ref lockTaken);
            //    if (lockTaken)
            //    {
            //        _localMsgHistory = _msgHistory;
            //    }
            //}
            //finally
            //{
            //    if (lockTaken)
            //        Monitor.Exit(_msgHistoryLock);
            //}
            //lockTaken = false;

            long moveIntervals = Math.Max(2, (long)Math.Ceiling((double)UIUtils.GetMainCanvasAnimationFrequency(mapRefreshRate) / 10.0));
            bool lighter_darkening = LighterDarkening;
#if WINDOWS
            //lock (_canvasPointerLock)
            try
            {
                Monitor.TryEnter(_canvasPointerLock, ref lockTaken);
                if (lockTaken)
                {
                    _localIsPointerHovering = _isCanvasHovering;
                    _localPointerHoverLocation = _canvasHoverLocation;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_canvasPointerLock);
            }
            lockTaken = false;

#endif
            using (GHSkiaFontPaint textPaint = new GHSkiaFontPaint())
            {
                string str = "";
                SKRect textBounds = new SKRect();
                SKPathEffect pathEffect = SKPathEffect.CreateDash(_gridIntervals, 0);

                textPaint.Color = SKColors.White;
                textPaint.Typeface = GHApp.LatoRegular;

                /* Map */
                float usedFontSize = ZoomAlternateMode ? MapFontAlternateSize : MapFontSize;
                textPaint.Typeface = GHApp.DejaVuSansMonoTypeface;
                textPaint.TextSize = usedFontSize;
                if (zoomMiniMode)
                {
                    float tmpwidth = textPaint.MeasureText("A"); //textPaint.FontMetrics.AverageCharacterWidth;
                    float tmpheight = textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent;
                    if (graphicsStyle == GHGraphicsStyle.Tiles && !forceAscii)
                    {
                        tmpwidth = GHConstants.TileWidth * usedFontSize / GHConstants.MapFontDefaultSize;
                        tmpheight = GHConstants.TileHeight * usedFontSize / GHConstants.MapFontDefaultSize;
                    }
                    float tmpmapwidth = tmpwidth * (GHConstants.MapCols - 1);
                    float tmpmapheight = tmpheight * GHConstants.MapRows;
                    float xscale = tmpmapwidth > 0 ? canvaswidth / tmpmapwidth : 0;
                    float yscale = tmpmapheight > 0 ? canvasheight / tmpmapheight : 0;
                    float cscale = Math.Min(xscale, yscale);
                    usedFontSize = Math.Max(2.0f, usedFontSize * cscale);
                    usedFontSize = usedFontSize * MapFontMiniRelativeSize;
                    textPaint.TextSize = usedFontSize;
                }

                float width = textPaint.MeasureText("A"); //textPaint.FontMetrics.AverageCharacterWidth;
                float height = textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent;

                if (graphicsStyle == GHGraphicsStyle.Tiles && !forceAscii)
                {
                    width = GHConstants.TileWidth * usedFontSize / GHConstants.MapFontDefaultSize * GHConstants.TileSizeAdjustmentModifier;
                    height = GHConstants.TileHeight * usedFontSize / GHConstants.MapFontDefaultSize * GHConstants.TileSizeAdjustmentModifier;
                }

                float mapwidth = width * (GHConstants.MapCols - 1);
                float mapheight = height * (GHConstants.MapRows);

                //lock (_tileSizeLock)
                try
                {
                    Monitor.TryEnter(_tileSizeLock, ref lockTaken);
                    if (lockTaken)
                    {
                        _usedTileWidth = width;
                        _usedTileHeight = height;
                        _mapWidth = mapwidth;
                        _mapHeight = mapheight;
                    }
                }
                finally
                {
                    if (lockTaken)
                        Monitor.Exit(_tileSizeLock);
                }
                lockTaken = false;

                float mapFontAscent = textPaint.FontMetrics.Ascent;
                UsedMapFontAscent = mapFontAscent;
                float targetscale = height / (float)GHConstants.TileHeight;

                int startX = 1;
                int endX = GHConstants.MapCols - 1;
                int startY = 0;
                int endY = GHConstants.MapRows - 1;

                float offsetX;
                float offsetY;
                float usedOffsetX;
                float usedOffsetY;
                GetMapOffsetsLocal(canvaswidth, canvasheight, mapwidth, mapheight, width, height, out offsetX, out offsetY, out usedOffsetX, out usedOffsetY);

                int mapHoverX = 0, mapHoverY = 0;
                bool hasMapHoverLocation = false;
                if (_localIsPointerHovering)
                {
                    hasMapHoverLocation = GetMapTileHoverLocation(_localPointerHoverLocation.X, _localPointerHoverLocation.Y, out mapHoverX, out mapHoverY, width, height,
                        mapwidth, mapheight, _localMapOffsetX, _localMapOffsetY, _localMapMiniOffsetX, _localMapMiniOffsetY, _localClipX, _localClipY, canvaswidth, canvasheight,
                        mapFontAscent, showDirections, showNumberPad, zoomMiniMode, mapWalkMode, walkArrows);
                }

                float tx = 0, ty = 0;
                float startx = 0, starty = 0;
                int mapWindowId = 0, messageWindowId = 0, statusWindowId = 0;
                if (curGame != null)
                {
                    GetWindowIds(out mapWindowId, out messageWindowId, out statusWindowId);
                    GHWindow win = null;
                    lock (_localWindowLock)
                    {
                        win = _localGHWindows[mapWindowId];
                    }
                    if (win != null)
                    {
                        startx = win.Left;
                        starty = win.Top;
                    }
                }

                if (!forceAllMessages || HasAllMessagesTransparentBackground)
                {
                    lock (GHApp.Glyph2TileLock)
                    {
                        //lock (_mapDataLock)
                        {
                            if (graphicsStyle == GHGraphicsStyle.ASCII || forceAscii)
                            {
                                for (int mapx = startX; mapx <= endX; mapx++)
                                {
                                    for (int mapy = startY; mapy <= endY; mapy++)
                                    {
                                        if (_mapData[mapx, mapy].Symbol != null && _mapData[mapx, mapy].Symbol != "")
                                        {
                                            str = _mapData[mapx, mapy].Symbol;
                                            textPaint.Color = _mapData[mapx, mapy].Color;
                                            tx = (offsetX + usedOffsetX + width * (float)mapx);
                                            ty = (offsetY + usedOffsetY + height * (float)mapy);
                                            if (CursorStyle == TTYCursorStyle.GreenBlock && _localMapCursorX == mapx && _localMapCursorY == mapy)
                                            {
                                                textPaint.Style = SKPaintStyle.Fill;
                                                textPaint.Color = _cursorDefaultGreen;
                                                SKRect winRect = new SKRect(tx, ty + textPaint.FontMetrics.Ascent, tx + width, ty + textPaint.FontMetrics.Ascent + height);
                                                canvas.DrawRect(winRect, textPaint.Paint);
                                                textPaint.Color = SKColors.Black;
                                            }
                                            else if ((_mapData[mapx, mapy].Special & (uint)MapSpecial.Inverse) != 0)
                                            {
                                                textPaint.Style = SKPaintStyle.Fill;
                                                SKRect winRect = new SKRect(tx, ty + textPaint.FontMetrics.Ascent, tx + width, ty + textPaint.FontMetrics.Ascent + height);
                                                canvas.DrawRect(winRect, textPaint.Paint);
                                                textPaint.Color = SKColors.Black;
                                            }

                                            //canvas.DrawText(str, tx, ty, textPaint);
                                            textPaint.DrawTextOnCanvas(canvas, str, tx, ty);

                                            if ((_mapData[mapx, mapy].Special & (uint)MapSpecial.Underline) != 0)
                                            {
                                                //canvas.DrawText("_", tx, ty, textPaint);
                                                textPaint.DrawTextOnCanvas(canvas, "_", tx, ty);
                                            }
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (GHApp.Glyph2Tile != null && GHApp._tilesPerRow[0] > 0 && GHApp.UsedTileSheets > 0)
                                {
                                    using (SKPaint paint = new SKPaint())
                                    {
                                        //paint.FilterQuality = SKFilterQuality.None;

                                        Array.Clear(_draw_shadow, 0, _draw_shadow.Length);
                                        float pit_border = (float)GHConstants.PIT_BOTTOM_BORDER * height / (float)GHConstants.TileHeight;
                                        long currentcountervalue = generalcountervalue;
                                        float altStartX = -(offsetX + usedOffsetX) / width - 1;
                                        float altEndX = (canvaswidth - (offsetX + usedOffsetX)) / width;
                                        float altStartY = -(offsetY + usedOffsetY) / height - 1;
                                        float altEndY = (canvasheight - (offsetY + usedOffsetY)) / height;
                                        altStartX -= 3;
                                        altEndX += 3;
                                        altStartY -= 1;
                                        altEndY += 3;
                                        startX = Math.Max(startX, (int)(Math.Sign(altStartX) * Math.Floor(Math.Abs(altStartX))));
                                        endX = Math.Min(endX, (int)Math.Ceiling(altEndX));
                                        startY = Math.Max(startY, (int)(Math.Sign(altStartY) * Math.Floor(Math.Abs(altStartY))));
                                        endY = Math.Min(endY, (int)Math.Ceiling(altEndY));

                                        if (AlternativeLayerDrawing)
                                        {
                                            lock (_drawOrderLock)
                                            {
                                                for (int mapy = startY; mapy <= endY; mapy++)
                                                {
                                                    for (int mapx = startX; mapx <= endX; mapx++)
                                                    {
                                                        if (_mapData[mapx, mapy].Layers.layer_glyphs == null || _mapData[mapx, mapy].Layers.layer_gui_glyphs == null)
                                                            continue;
                                                        int draw_cnt = _draw_order.Count;
                                                        for (int draw_idx = 0; draw_idx < draw_cnt; draw_idx++)
                                                        {
                                                            int enl_idx = _draw_order[draw_idx].enlargement_position;
                                                            int layer_idx = _draw_order[draw_idx].layer;
                                                            bool is_monster_or_shadow_layer = (layer_idx == (int)layer_types.LAYER_MONSTER || layer_idx == (int)layer_types.MAX_LAYERS);
                                                            bool is_monster_like_layer = (is_monster_or_shadow_layer || layer_idx == (int)layer_types.LAYER_MONSTER_EFFECT);
                                                            bool is_object_like_layer = (layer_idx == (int)layer_types.LAYER_OBJECT || layer_idx == (int)layer_types.LAYER_COVER_OBJECT);
                                                            bool is_missile_layer = (layer_idx == (int)layer_types.LAYER_MISSILE);

                                                            if (layer_idx == (int)layer_types.MAX_LAYERS && (_draw_shadow[mapx, mapy] == 0 || _mapData[mapx, mapy].Layers.layer_gui_glyphs[(int)layer_types.LAYER_MONSTER] == GHApp.NoGlyph))
                                                                continue;

                                                            int source_x = mapx, source_y = mapy;
                                                            switch(enl_idx)
                                                            {
                                                                default:
                                                                case -1:
                                                                    break;
                                                                case 0:
                                                                    source_x = mapx + 1;
                                                                    source_y = mapy + 1;
                                                                    break;
                                                                case 1:
                                                                    source_y = mapy + 1;
                                                                    break;
                                                                case 2:
                                                                    source_x = mapx - 1;
                                                                    source_y = mapy + 1;
                                                                    break;
                                                                case 3:
                                                                    source_x = mapx + 1;
                                                                    break;
                                                                case 4:
                                                                    source_x = mapx - 1;
                                                                    break;
                                                            }
                                                            if (!GHUtils.isok(source_x, source_y))
                                                                continue;

                                                            if (enl_idx >= 0 && !_mapData[source_x, source_y].HasEnlargementOrAnimationOrSpecialHeight)
                                                                continue;

                                                            bool loc_is_you = (_mapData[source_x, source_y].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_UXUY) != 0;
                                                            bool showing_detection = (_mapData[source_x, source_y].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_SHOWING_DETECTION) != 0;
                                                            bool canspotself = (_mapData[source_x, source_y].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_CAN_SPOT_SELF) != 0;
                                                            sbyte monster_height = _mapData[source_x, source_y].Layers.special_monster_layer_height;
                                                            sbyte feature_doodad_height = _mapData[source_x, source_y].Layers.special_feature_doodad_layer_height;
                                                            short missile_special_quality = _mapData[source_x, source_y].Layers.missile_special_quality;
                                                            sbyte monster_origin_x = _mapData[source_x, source_y].Layers.monster_origin_x;
                                                            sbyte monster_origin_y = _mapData[source_x, source_y].Layers.monster_origin_y;
                                                            long glyphprintmaincountervalue = _mapData[source_x, source_y].GlyphPrintMainCounterValue;
                                                            int movediffx = (int)monster_origin_x - source_x;
                                                            int movediffy = (int)monster_origin_y - source_y;
                                                            long maincounterdiff = maincountervalue - glyphprintmaincountervalue;
                                                            long glyphobjectprintmaincountervalue = _mapData[source_x, source_y].GlyphObjectPrintMainCounterValue;
                                                            long objectcounterdiff = maincountervalue - glyphobjectprintmaincountervalue;
                                                            long glyphgeneralprintmaincountervalue = _mapData[source_x, source_y].GlyphGeneralPrintMainCounterValue;
                                                            long generalcounterdiff = (long)((double)(maincountervalue - glyphgeneralprintmaincountervalue) * mainCounter2AnimationMultiplier);
                                                            short missile_height = _mapData[source_x, source_y].Layers.missile_height;
                                                            bool obj_in_pit = (_mapData[source_x, source_y].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_O_IN_PIT) != 0;
                                                            bool isPointerHoveringOnTile = hasMapHoverLocation && source_x == mapHoverX && source_y == mapHoverY;

                                                            float base_move_offset_x = 0, base_move_offset_y = 0;
                                                            //GetBaseMoveOffsets(source_x, source_y, monster_origin_x, monster_origin_y, width, height, maincounterdiff, moveIntervals, ref base_move_offset_x, ref base_move_offset_y);

                                                            //lock (_objectDataLock)
                                                            {
                                                                if (layer_idx == (int)layer_types.MAX_LAYERS + 1)
                                                                {
                                                                    PaintMapUIElements(canvas, textPaint, paint, pathEffect, mapx, mapy, width, height, offsetX, offsetY, usedOffsetX, usedOffsetY, base_move_offset_x, base_move_offset_y, targetscale, generalcountervalue, usedFontSize, mapFontAscent, monster_height, loc_is_you, canspotself, usingGL, fixRects, mapGrid, gridOpacity, hitPointBars, playerMark, monsterTargeting);
                                                                }
                                                                else
                                                                {
                                                                    bool is_source_dir;
                                                                    int sub_layer_cnt = GetSubLayerCount(source_x, source_y, layer_idx, out is_source_dir);
                                                                    for (int sub_layer_idx = sub_layer_cnt - 1; sub_layer_idx >= 0; sub_layer_idx--)
                                                                    {
                                                                        int signed_glyph = GHApp.NoGlyph; //Default
                                                                        short obj_height = _mapData[source_x, source_y].Layers.object_height; //Default
                                                                        sbyte object_origin_x = 0; //Default
                                                                        sbyte object_origin_y = 0; //Default
                                                                        ObjectDataItem otmp_round = null;

                                                                        int source_dir_main_idx = sub_layer_idx;
                                                                        int source_dir_idx = is_source_dir ? GetSourceDirIndex(layer_idx, source_dir_main_idx) : 0;

                                                                        bool manual_hflip = false;
                                                                        bool manual_vflip = false;
                                                                        int adj_x = source_x;
                                                                        int adj_y = source_y;
                                                                        bool foundthisturn = false;

                                                                        if (!GetLayerGlyph(source_x, source_y, layer_idx, sub_layer_idx, source_dir_idx, ref signed_glyph,
                                                                            ref adj_x, ref adj_y, ref manual_hflip, ref manual_vflip, ref otmp_round, ref obj_height,
                                                                            ref object_origin_x, ref object_origin_y, ref foundthisturn))
                                                                            continue;

                                                                        int glyph = Math.Abs(signed_glyph);
                                                                        if (glyph == 0 || glyph >= GHApp.Glyph2Tile.Length)
                                                                            continue;

                                                                        float object_move_offset_x = 0, object_move_offset_y = 0;
                                                                        //GetObjectMoveOffsets(source_x, source_y, object_origin_x, object_origin_y, width, height, objectcounterdiff, moveIntervals, ref object_move_offset_x, ref object_move_offset_y);

                                                                        bool vflip_glyph = false;
                                                                        bool hflip_glyph = false;
                                                                        GetFlips(signed_glyph, manual_hflip, manual_vflip, ref hflip_glyph, ref vflip_glyph);

                                                                        /* Tile flags */
                                                                        bool tileflag_halfsize = (GHApp.GlyphTileFlags[glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_HALF_SIZED_TILE) != 0;
                                                                        bool tileflag_floortile = (GHApp.GlyphTileFlags[glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_HAS_FLOOR_TILE) != 0;
                                                                        bool tileflag_normalobjmissile = (GHApp.GlyphTileFlags[glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_NORMAL_ITEM_AS_MISSILE) != 0 && layer_idx == (int)layer_types.LAYER_MISSILE;
                                                                        bool tileflag_fullsizeditem = (GHApp.GlyphTileFlags[glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_FULL_SIZED_ITEM) != 0;
                                                                        bool tileflag_height_is_clipping = (GHApp.GlyphTileFlags[glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_HEIGHT_IS_CLIPPING) != 0;

                                                                        /* All items are big when showing detection */
                                                                        CheckShowingDetection(showing_detection, ref obj_height, ref tileflag_floortile, ref tileflag_height_is_clipping);

                                                                        /*Determine y move for tiles */
                                                                        float scaled_y_height_change = GetScaledYHeightChange(layer_idx, sub_layer_idx, sub_layer_cnt, height, monster_height, feature_doodad_height, targetscale, is_monster_like_layer, tileflag_halfsize, otmp_round);

                                                                        int ntile = GHApp.Glyph2Tile[glyph];
                                                                        int autodraw = GHApp.Tile2Autodraw[ntile];

                                                                        /* Determine animation tile here */
                                                                        int anim_frame_idx = 0, main_tile_idx = 0;
                                                                        ntile = GetTileFromAnimation(_localAnimationTimers, ntile, glyph, source_x, source_y, layer_idx, generalcountervalue, is_monster_or_shadow_layer, ref anim_frame_idx, ref main_tile_idx, ref autodraw);

                                                                        /* Draw enlargement tiles */
                                                                        int enlargement = GHApp.Tile2Enlargement[ntile];
                                                                        int dx = 0, dy = 0;
                                                                        if (!GetEnlargementTileB(enlargement, enl_idx, hflip_glyph, vflip_glyph, main_tile_idx, anim_frame_idx, ref ntile, ref autodraw, ref dx, ref dy))
                                                                            continue;

                                                                        int draw_map_x = source_x + dx + (adj_x - source_x);
                                                                        int draw_map_y = source_y + dy + (adj_y - source_y);

                                                                        //float minDrawX = 0, maxDrawX = 0, minDrawY = 0, maxDrawY = 0;
                                                                        //float enlMinDrawX = 0, enlMaxDrawX = 0, enlMinDrawY = 0, enlMaxDrawY = 0;

                                                                        PaintMapTile(canvas, false, textPaint, paint, layer_idx, source_x, source_y, draw_map_x, draw_map_y, dx, dy, ntile, width, height,
                                                                            offsetX, offsetY, usedOffsetX, usedOffsetY, base_move_offset_x, base_move_offset_y, object_move_offset_x, object_move_offset_y,
                                                                            scaled_y_height_change, pit_border, targetscale, generalcountervalue, usedFontSize, mapFontAscent,
                                                                            monster_height, is_monster_like_layer, is_object_like_layer, obj_in_pit, obj_height, is_missile_layer, missile_height,
                                                                            loc_is_you, canspotself, tileflag_halfsize, tileflag_normalobjmissile, tileflag_fullsizeditem, tileflag_floortile, tileflag_height_is_clipping,
                                                                            hflip_glyph, vflip_glyph, otmp_round, autodraw, drawwallends, breatheanimations, generalcounterdiff, canvaswidth, canvasheight, enlargement, usingGL, usingMipMap, fixRects,
                                                                            isPointerHoveringOnTile, mapLookMode); //, ref minDrawX, ref maxDrawX, ref minDrawY, ref maxDrawY, ref enlMinDrawX, ref enlMaxDrawX, ref enlMinDrawY, ref enlMaxDrawY);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {
                                            for (int layer_idx = 0; layer_idx < (int)layer_types.MAX_LAYERS + 2; layer_idx++)
                                            {
                                                bool is_monster_or_shadow_layer = (layer_idx == (int)layer_types.LAYER_MONSTER || layer_idx == (int)layer_types.MAX_LAYERS);
                                                bool is_monster_like_layer = (is_monster_or_shadow_layer || layer_idx == (int)layer_types.LAYER_MONSTER_EFFECT);
                                                bool is_object_like_layer = (layer_idx == (int)layer_types.LAYER_OBJECT || layer_idx == (int)layer_types.LAYER_COVER_OBJECT);
                                                bool is_missile_layer = (layer_idx == (int)layer_types.LAYER_MISSILE);
                                                for (int mapy = startY; mapy <= endY; mapy++)
                                                {
                                                    for (int mapx = startX; mapx <= endX; mapx++)
                                                    {
                                                        if (layer_idx == (int)layer_types.LAYER_FEATURE_DOODAD && _mapData[mapx, mapy].Engraving.HasEngraving)
                                                            DrawEngraving(canvas, textPaint, mapx, mapy, offsetX, offsetY, usedOffsetX, usedOffsetY, mapFontAscent, width, height, generalcountervalue);

                                                        if (_mapData[mapx, mapy].Layers.layer_glyphs == null || _mapData[mapx, mapy].Layers.layer_gui_glyphs == null)
                                                            continue;

                                                        if (layer_idx == (int)layer_types.MAX_LAYERS
                                                            && (_draw_shadow[mapx, mapy] == 0 || _mapData[mapx, mapy].Layers.layer_gui_glyphs[(int)layer_types.LAYER_MONSTER] == GHApp.NoGlyph)
                                                            )
                                                            continue;

                                                        bool loc_is_you = (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_UXUY) != 0;
                                                        bool showing_detection = (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_SHOWING_DETECTION) != 0;
                                                        bool canspotself = (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_CAN_SPOT_SELF) != 0;
                                                        sbyte monster_height = _mapData[mapx, mapy].Layers.special_monster_layer_height;
                                                        sbyte feature_doodad_height = _mapData[mapx, mapy].Layers.special_feature_doodad_layer_height;
                                                        short missile_special_quality = _mapData[mapx, mapy].Layers.missile_special_quality;
                                                        sbyte monster_origin_x = _mapData[mapx, mapy].Layers.monster_origin_x;
                                                        sbyte monster_origin_y = _mapData[mapx, mapy].Layers.monster_origin_y;
                                                        long glyphprintmaincountervalue = _mapData[mapx, mapy].GlyphPrintMainCounterValue;
                                                        long maincounterdiff = maincountervalue - glyphprintmaincountervalue;
                                                        long glyphobjectprintmaincountervalue = _mapData[mapx, mapy].GlyphObjectPrintMainCounterValue;
                                                        long objectcounterdiff = maincountervalue - glyphobjectprintmaincountervalue;
                                                        long glyphgeneralprintmaincountervalue = _mapData[mapx, mapy].GlyphGeneralPrintMainCounterValue;
                                                        long generalcounterdiff = (long)((maincountervalue - glyphgeneralprintmaincountervalue) * mainCounter2AnimationMultiplier);
                                                        short missile_height = _mapData[mapx, mapy].Layers.missile_height;
                                                        bool obj_in_pit = (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_O_IN_PIT) != 0;
                                                        bool isPointerHoveringOnTile = hasMapHoverLocation && mapx == mapHoverX && mapy == mapHoverY;

                                                        float base_move_offset_x = 0, base_move_offset_y = 0;
                                                        GetBaseMoveOffsets(mapx, mapy, monster_origin_x, monster_origin_y, width, height, maincounterdiff, moveIntervals, ref base_move_offset_x, ref base_move_offset_y);

                                                        //lock (_objectDataLock)
                                                        {
                                                            if (layer_idx == (int)layer_types.MAX_LAYERS + 1)
                                                            {
                                                                PaintMapUIElements(canvas, textPaint, paint, pathEffect, mapx, mapy, width, height, offsetX, offsetY, usedOffsetX, usedOffsetY, base_move_offset_x, base_move_offset_y, targetscale, generalcountervalue, usedFontSize, mapFontAscent, monster_height, loc_is_you, canspotself, usingGL, fixRects, mapGrid, gridOpacity, hitPointBars, playerMark, monsterTargeting);
                                                            }
                                                            else
                                                            {
                                                                bool is_source_dir;
                                                                int sub_layer_cnt = GetSubLayerCount(mapx, mapy, layer_idx, out is_source_dir);
                                                                for (int sub_layer_idx = sub_layer_cnt - 1; sub_layer_idx >= 0; sub_layer_idx--)
                                                                {
                                                                    int signed_glyph = GHApp.NoGlyph; //Default
                                                                    short obj_height = _mapData[mapx, mapy].Layers.object_height; //Default
                                                                    sbyte object_origin_x = 0; //Default
                                                                    sbyte object_origin_y = 0; //Default
                                                                    ObjectDataItem otmp_round = null;

                                                                    int source_dir_main_idx = sub_layer_idx;
                                                                    int source_dir_idx = is_source_dir ? GetSourceDirIndex(layer_idx, source_dir_main_idx) : 0;

                                                                    bool manual_hflip = false;
                                                                    bool manual_vflip = false;
                                                                    int adj_x = mapx;
                                                                    int adj_y = mapy;
                                                                    bool foundthisturn = false;

                                                                    if (!GetLayerGlyph(mapx, mapy, layer_idx, sub_layer_idx, source_dir_idx, ref signed_glyph,
                                                                        ref adj_x, ref adj_y, ref manual_hflip, ref manual_vflip, ref otmp_round, ref obj_height,
                                                                        ref object_origin_x, ref object_origin_y, ref foundthisturn))
                                                                        continue;

                                                                    int glyph = Math.Abs(signed_glyph);
                                                                    if (glyph == 0 || glyph >= GHApp.Glyph2Tile.Length)
                                                                        continue;

                                                                    float object_move_offset_x = 0, object_move_offset_y = 0;
                                                                    GetObjectMoveOffsets(mapx, mapy, object_origin_x, object_origin_y, width, height, objectcounterdiff, moveIntervals, generalcounterdiff,
                                                                        foundthisturn, sub_layer_idx, sub_layer_cnt, targetscale, loc_is_you, obj_height, otmp_round, ref object_move_offset_x, ref object_move_offset_y);

                                                                    bool vflip_glyph = false;
                                                                    bool hflip_glyph = false;
                                                                    GetFlips(signed_glyph, manual_hflip, manual_vflip, ref hflip_glyph, ref vflip_glyph);

                                                                    /* Tile flags */
                                                                    bool tileflag_halfsize = (GHApp.GlyphTileFlags[glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_HALF_SIZED_TILE) != 0;
                                                                    bool tileflag_floortile = (GHApp.GlyphTileFlags[glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_HAS_FLOOR_TILE) != 0;
                                                                    bool tileflag_normalobjmissile = (GHApp.GlyphTileFlags[glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_NORMAL_ITEM_AS_MISSILE) != 0 && layer_idx == (int)layer_types.LAYER_MISSILE;
                                                                    bool tileflag_fullsizeditem = (GHApp.GlyphTileFlags[glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_FULL_SIZED_ITEM) != 0;
                                                                    bool tileflag_height_is_clipping = (GHApp.GlyphTileFlags[glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_HEIGHT_IS_CLIPPING) != 0;

                                                                    /* All items are big when showing detection */
                                                                    CheckShowingDetection(showing_detection, ref obj_height, ref tileflag_floortile, ref tileflag_height_is_clipping);

                                                                    /*Determine y move for tiles */
                                                                    float scaled_y_height_change = GetScaledYHeightChange(layer_idx, sub_layer_idx, sub_layer_cnt, height, monster_height, feature_doodad_height, targetscale, is_monster_like_layer, tileflag_halfsize, otmp_round);

                                                                    int ntile = GHApp.Glyph2Tile[glyph];
                                                                    int autodraw = GHApp.Tile2Autodraw[ntile];

                                                                    /* Determine animation tile here */
                                                                    int anim_frame_idx = 0, main_tile_idx = 0;
                                                                    ntile = GetTileFromAnimation(_localAnimationTimers, ntile, glyph, mapx, mapy, layer_idx, generalcountervalue, is_monster_or_shadow_layer, ref anim_frame_idx, ref main_tile_idx, ref autodraw);

                                                                    /* Draw enlargement tiles */
                                                                    int enlargement = GHApp.Tile2Enlargement[ntile];
                                                                    for (int order_idx = -1; order_idx < 5; order_idx++)
                                                                    {
                                                                        if (enlargement == 0 && order_idx >= 0)
                                                                            break;
                                                                        int enl_idx = GetUsedEnlargementIndex(order_idx);
                                                                        int dx = 0, dy = 0;
                                                                        if (!GetEnlargementTileB(enlargement, enl_idx, hflip_glyph, vflip_glyph, main_tile_idx, anim_frame_idx, ref ntile, ref autodraw, ref dx, ref dy))
                                                                            continue;

                                                                        int draw_map_x = mapx + dx + (adj_x - mapx);
                                                                        int draw_map_y = mapy + dy + (adj_y - mapy);

                                                                        if ((enlargement > 0 && enl_idx >= 0 && enl_idx <= 2) || layer_idx == (int)layer_types.MAX_LAYERS)
                                                                        {
                                                                            PaintMapTile(canvas, true, textPaint, paint, layer_idx, mapx, mapy, draw_map_x, draw_map_y, dx, dy, ntile, width, height,
                                                                                offsetX, offsetY, usedOffsetX, usedOffsetY, base_move_offset_x, base_move_offset_y, object_move_offset_x, object_move_offset_y,
                                                                                scaled_y_height_change, pit_border, targetscale, generalcountervalue, usedFontSize, mapFontAscent,
                                                                                monster_height, is_monster_like_layer, is_object_like_layer, obj_in_pit, obj_height, is_missile_layer, missile_height,
                                                                                loc_is_you, canspotself, tileflag_halfsize, tileflag_normalobjmissile, tileflag_fullsizeditem, tileflag_floortile, tileflag_height_is_clipping,
                                                                                hflip_glyph, vflip_glyph, otmp_round, autodraw, drawwallends, breatheanimations, generalcounterdiff, canvaswidth, canvasheight, enlargement, usingGL, usingMipMap, fixRects,
                                                                                isPointerHoveringOnTile, mapLookMode); //, ref _enlBmpMinX, ref _enlBmpMaxX, ref _enlBmpMinY, ref _enlBmpMaxY, ref _enlBmpMinX, ref _enlBmpMaxX, ref _enlBmpMinY, ref _enlBmpMaxY);
                                                                        }
                                                                        else
                                                                        {
                                                                            //float minDrawX = 0, maxDrawX = 0, minDrawY = 0, maxDrawY = 0;
                                                                            PaintMapTile(canvas, false, textPaint, paint, layer_idx, mapx, mapy, draw_map_x, draw_map_y, dx, dy, ntile, width, height,
                                                                                offsetX, offsetY, usedOffsetX, usedOffsetY, base_move_offset_x, base_move_offset_y, object_move_offset_x, object_move_offset_y,
                                                                                scaled_y_height_change, pit_border, targetscale, generalcountervalue, usedFontSize, mapFontAscent,
                                                                                monster_height, is_monster_like_layer, is_object_like_layer, obj_in_pit, obj_height, is_missile_layer, missile_height,
                                                                                loc_is_you, canspotself, tileflag_halfsize, tileflag_normalobjmissile, tileflag_fullsizeditem, tileflag_floortile, tileflag_height_is_clipping,
                                                                                hflip_glyph, vflip_glyph, otmp_round, autodraw, drawwallends, breatheanimations, generalcounterdiff, canvaswidth, canvasheight, enlargement, usingGL, usingMipMap, fixRects,
                                                                                isPointerHoveringOnTile, mapLookMode); //, ref minDrawX, ref maxDrawX, ref minDrawY, ref maxDrawY, ref _enlBmpMinX, ref _enlBmpMaxX, ref _enlBmpMinY, ref _enlBmpMaxY);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                                switch (layer_idx)
                                                {
                                                    /* Darkening at the end of layers */
                                                    case (int)layer_types.LAYER_OBJECT:
                                                    {
                                                        _drawCommandList.Add(new GHDrawCommand(true));
                                                        for (int mapx = startX; mapx <= endX; mapx++)
                                                        {
                                                            for (int mapy = startY; mapy <= endY; mapy++)
                                                            {
                                                                bool darken = DarkenedPos(mapx, mapy);
                                                                bool validpos = (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_L_LEGAL) != 0 && (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_CAN_SEE) != 0;
                                                                bool invalidpos = (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_L_ILLEGAL) != 0 && (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_CAN_SEE) != 0;

                                                                // Draw rectangle with blend mode in bottom half
                                                                if (darken)
                                                                {
                                                                    tx = (offsetX + usedOffsetX + width * (float)mapx);
                                                                    ty = (offsetY + usedOffsetY + mapFontAscent + height * (float)mapy);
                                                                    DoDarkening(canvas, paint, tx, ty, width, height, GetDarkenPercentage(mapx, mapy, lighter_darkening));
                                                                }
                                                                if (validpos)
                                                                {
                                                                    paint.Color = new SKColor((byte)0, (byte)255, (byte)0, (byte)72);
                                                                    SKBlendMode old_bm = paint.BlendMode;
                                                                    paint.BlendMode = SKBlendMode.SrcOver;
                                                                    tx = (offsetX + usedOffsetX + width * (float)mapx);
                                                                    ty = (offsetY + usedOffsetY + mapFontAscent + height * (float)mapy);
                                                                    SKRect targetrect = new SKRect(tx, ty, tx + width, ty + height);
#if GNH_MAP_PROFILING && DEBUG
                                                                    StartProfiling(GHProfilingStyle.Rect);
#endif
                                                                    canvas.DrawRect(targetrect, paint);
                                                                    //enlCanvas.DrawRect(targetrect, paint);
#if GNH_MAP_PROFILING && DEBUG
                                                                    StopProfiling(GHProfilingStyle.Rect);
#endif
                                                                    paint.BlendMode = old_bm;
                                                                }
                                                                if (invalidpos)
                                                                {
                                                                    paint.Color = new SKColor((byte)255, (byte)0, (byte)0, (byte)72);
                                                                    SKBlendMode old_bm = paint.BlendMode;
                                                                    paint.BlendMode = SKBlendMode.SrcOver;
                                                                    tx = (offsetX + usedOffsetX + width * (float)mapx);
                                                                    ty = (offsetY + usedOffsetY + mapFontAscent + height * (float)mapy);
                                                                    SKRect targetrect = new SKRect(tx, ty, tx + width, ty + height);
#if GNH_MAP_PROFILING && DEBUG
                                                                    StartProfiling(GHProfilingStyle.Rect);
#endif
                                                                    canvas.DrawRect(targetrect, paint);
                                                                    //enlCanvas.DrawRect(targetrect, paint);
#if GNH_MAP_PROFILING && DEBUG
                                                                    StopProfiling(GHProfilingStyle.Rect);
#endif
                                                                    paint.BlendMode = old_bm;
                                                                }
                                                            }
                                                        }
                                                        break;
                                                    }
                                                    /* Enlargement bitmaps */
                                                    case (int)layer_types.MAX_LAYERS:
                                                    using (new SKAutoCanvasRestore(canvas))
                                                    {
                                                        bool dodarkening = true;
                                                        using (SKCanvas darkeningCanvas = new SKCanvas(_paintBitmap))
                                                        {
                                                            foreach (GHDrawCommand dc in _drawCommandList)
                                                            {
                                                                if (dc.EndDarkening)
                                                                {
                                                                    dodarkening = false;
                                                                    continue;
                                                                }
                                                                if (dodarkening && DarkenedPos(dc.MapX, dc.MapY))
                                                                {
                                                                    darkeningCanvas.Clear(SKColors.Transparent);
                                                                    if (dc.IsAutoDraw)
                                                                    {
                                                                        SKImage usedDarkenedBitmap = null;
                                                                        int darken_percentage = GetDarkenPercentage(dc.MapX, dc.MapY, lighter_darkening);
                                                                        AutoDrawParameterDefinition modadparams = dc.AutoDrawParameters;
                                                                        modadparams.tx = 0;
                                                                        modadparams.ty = 0;
                                                                        modadparams.scaled_x_padding = 0;
                                                                        modadparams.scaled_y_padding = 0;
                                                                        modadparams.scale = 1;
                                                                        modadparams.targetscale = 1;
                                                                        SavedDarkenedAutodrawBitmap cachekey = new SavedDarkenedAutodrawBitmap(modadparams, darken_percentage);
                                                                        SKRect sourceRect = new SKRect(0, 0, dc.AutoDrawParameters.width, dc.AutoDrawParameters.height);
                                                                        SKRect destRect = new SKRect(dc.AutoDrawParameters.tx + dc.AutoDrawParameters.scaled_x_padding,
                                                                            dc.AutoDrawParameters.ty + dc.AutoDrawParameters.scaled_y_padding,
                                                                            dc.AutoDrawParameters.tx + dc.AutoDrawParameters.scaled_x_padding + dc.AutoDrawParameters.width * dc.AutoDrawParameters.scale * dc.AutoDrawParameters.targetscale,
                                                                            dc.AutoDrawParameters.ty + dc.AutoDrawParameters.scaled_y_padding + dc.AutoDrawParameters.height * dc.AutoDrawParameters.scale * dc.AutoDrawParameters.targetscale);

                                                                        bool getsuccessful;
                                                                        //lock (_darkenedAutoDrawBitmapLock)
                                                                        {
                                                                            getsuccessful = _darkenedAutodrawBitmaps.ContainsKey(cachekey) && _darkenedAutodrawBitmaps.TryGetValue(cachekey, out usedDarkenedBitmap);
                                                                        }
                                                                        if (getsuccessful && usedDarkenedBitmap != null)
                                                                        {
                                                                            paint.Color = dc.PaintColor;
                                                                            paint.ColorFilter = dc.PaintColorFilter;
                                                                            canvas.SetMatrix(dc.Matrix);
                                                                            GHApp.MaybeFixRects(ref sourceRect, ref destRect, targetscale, usingGL, fixRects);
                                                                            canvas.DrawImage(usedDarkenedBitmap, sourceRect, destRect, paint);
                                                                            paint.ColorFilter = null;
                                                                        }
                                                                        else
                                                                        {
                                                                            paint.Color = dc.PaintColor;
                                                                            canvas.SetMatrix(dc.Matrix);
                                                                            DrawAutoDraw(dc.AutoDrawParameters.autodraw, darkeningCanvas, false, paint, dc.AutoDrawParameters.otmp_round,
                                                                                dc.AutoDrawParameters.layer_idx, dc.MapX, dc.MapY, dc.AutoDrawParameters.tileflag_halfsize,
                                                                                dc.AutoDrawParameters.tileflag_normalobjmissile, dc.AutoDrawParameters.tileflag_fullsizeditem, 0, 0,
                                                                                dc.AutoDrawParameters.width, dc.AutoDrawParameters.height, 1, 1,
                                                                                0, 0, height, dc.AutoDrawParameters.is_inventory,
                                                                                dc.AutoDrawParameters.drawwallends, usingGL, false, fixRects);
                                                                            DoDarkening(darkeningCanvas, paint, 0, 0, dc.AutoDrawParameters.width, dc.AutoDrawParameters.height, darken_percentage);

                                                                            /* Save to cache as immutable */
                                                                            bool doDisposeImage = false;
                                                                            try
                                                                            {
                                                                                SKBitmap newbmp = new SKBitmap(GHConstants.TileWidth, GHConstants.TileHeight);
                                                                                _paintBitmap.CopyTo(newbmp);
                                                                                newbmp.SetImmutable();
                                                                                SKImage newImage = SKImage.FromBitmap(newbmp);
                                                                                usedDarkenedBitmap = newImage;
                                                                                //lock (_darkenedAutoDrawBitmapLock)
                                                                                {
                                                                                    if (_darkenedAutodrawBitmaps.Count >= GHConstants.MaxDarkenedAutodrawBitmapCacheSize)
                                                                                    {
                                                                                        foreach (SKImage bmp in _darkenedAutodrawBitmaps.Values)
                                                                                            bmp.Dispose();
                                                                                        _darkenedAutodrawBitmaps.Clear(); /* Clear the whole dictionary for the sake of ease; should almost never happen normally anyway */
                                                                                    }
                                                                                    _darkenedAutodrawBitmaps.Add(cachekey, newImage);
                                                                                }
                                                                            }
                                                                            catch (Exception ex)
                                                                            {
                                                                                Debug.WriteLine(ex.Message);
                                                                                usedDarkenedBitmap = SKImage.FromBitmap(_paintBitmap);
                                                                                doDisposeImage = true;
                                                                            }

                                                                            paint.ColorFilter = dc.PaintColorFilter;
                                                                            GHApp.MaybeFixRects(ref sourceRect, ref destRect, targetscale, usingGL, fixRects);
                                                                            canvas.DrawImage(usedDarkenedBitmap, sourceRect, destRect, paint);
                                                                            if (doDisposeImage)
                                                                                usedDarkenedBitmap.Dispose();
                                                                            paint.ColorFilter = null;
                                                                        }
                                                                    }
                                                                    else
                                                                    {
                                                                        SKImage usedDarkenedBitmap = null;
                                                                        int darken_percentage = GetDarkenPercentage(dc.MapX, dc.MapY, lighter_darkening);
                                                                        SavedDarkenedBitmap cachekey = new SavedDarkenedBitmap(dc.SourceBitmap, dc.SourceRect, darken_percentage);
                                                                        SKRect cacheRect = new SKRect(0, 0, dc.SourceRect.Width, dc.SourceRect.Height);
                                                                        bool getsuccessful;
                                                                        //lock (_darkenedBitmapLock)
                                                                        {
                                                                            getsuccessful = _darkenedBitmaps.ContainsKey(cachekey) && _darkenedBitmaps.TryGetValue(cachekey, out usedDarkenedBitmap);
                                                                        }
                                                                        if (getsuccessful && usedDarkenedBitmap != null)
                                                                        {
                                                                            paint.Color = dc.PaintColor;
                                                                            paint.ColorFilter = dc.PaintColorFilter;
                                                                            canvas.SetMatrix(dc.Matrix);
                                                                            GHApp.MaybeFixRects(ref cacheRect, ref dc.DestinationRect, targetscale, usingGL, fixRects);
                                                                            canvas.DrawImage(usedDarkenedBitmap, cacheRect, dc.DestinationRect, paint);
                                                                            paint.ColorFilter = null;
                                                                        }
                                                                        else
                                                                        {
                                                                            /* Copy source bitmap to _paintCanvas and darken it */
                                                                            paint.Color = SKColors.Black;
                                                                            darkeningCanvas.DrawImage(dc.SourceBitmap, dc.SourceRect, cacheRect, paint);
                                                                            DoDarkening(darkeningCanvas, paint, cacheRect.Left, cacheRect.Top, cacheRect.Width, cacheRect.Height, darken_percentage);

                                                                            /* Save to cache as immutable */
                                                                            bool doDisposeImage = false;
                                                                            try
                                                                            {
                                                                                SKBitmap newbmp = new SKBitmap(GHConstants.TileWidth, GHConstants.TileHeight);
                                                                                _paintBitmap.CopyTo(newbmp);
                                                                                newbmp.SetImmutable();
                                                                                SKImage newImage = SKImage.FromBitmap(newbmp);
                                                                                usedDarkenedBitmap = newImage;
                                                                                //lock (_darkenedBitmapLock)
                                                                                {
                                                                                    if (_darkenedBitmaps.Count >= GHConstants.MaxDarkenedBitmapCacheSize)
                                                                                    {
                                                                                        foreach (SKImage bmp in _darkenedBitmaps.Values)
                                                                                            bmp.Dispose();
                                                                                        _darkenedBitmaps.Clear(); /* Clear the whole dictionary for the sake of ease; should almost never happen normally anyway */
                                                                                    }
                                                                                    _darkenedBitmaps.Add(cachekey, newImage);
                                                                                }
                                                                            }
                                                                            catch (Exception ex)
                                                                            {
                                                                                Debug.WriteLine(ex.Message);
                                                                                usedDarkenedBitmap = SKImage.FromBitmap(_paintBitmap);
                                                                                doDisposeImage = true;
                                                                            }

                                                                            paint.Color = dc.PaintColor;
                                                                            paint.ColorFilter = dc.PaintColorFilter;
                                                                            canvas.SetMatrix(dc.Matrix);
                                                                            GHApp.MaybeFixRects(ref cacheRect, ref dc.DestinationRect, targetscale, usingGL, fixRects);
                                                                            canvas.DrawImage(usedDarkenedBitmap, cacheRect, dc.DestinationRect, paint);
                                                                            if (doDisposeImage)
                                                                                usedDarkenedBitmap.Dispose();
                                                                            paint.ColorFilter = null;
                                                                        }
                                                                    }
                                                                }
                                                                else
                                                                {
                                                                    paint.Color = dc.PaintColor;
                                                                    paint.ColorFilter = dc.PaintColorFilter;
                                                                    canvas.SetMatrix(dc.Matrix);
                                                                    if(dc.IsAutoDraw)
                                                                    {
                                                                            DrawAutoDraw(dc.AutoDrawParameters.autodraw, canvas, false, paint, dc.AutoDrawParameters.otmp_round,
                                                                                dc.AutoDrawParameters.layer_idx, dc.MapX, dc.MapY, dc.AutoDrawParameters.tileflag_halfsize,
                                                                                dc.AutoDrawParameters.tileflag_normalobjmissile, dc.AutoDrawParameters.tileflag_fullsizeditem, dc.AutoDrawParameters.tx, dc.AutoDrawParameters.ty,
                                                                                dc.AutoDrawParameters.width, dc.AutoDrawParameters.height, dc.AutoDrawParameters.scale, dc.AutoDrawParameters.targetscale,
                                                                                dc.AutoDrawParameters.scaled_x_padding, dc.AutoDrawParameters.scaled_y_padding, dc.AutoDrawParameters.scaled_tile_height, dc.AutoDrawParameters.is_inventory,
                                                                                dc.AutoDrawParameters.drawwallends, usingGL, false, fixRects);
                                                                    }
                                                                    else
                                                                    {
                                                                        GHApp.MaybeFixRects(ref dc.SourceRect, ref dc.DestinationRect, targetscale, usingGL, fixRects);
                                                                        canvas.DrawImage(dc.SourceBitmap, dc.SourceRect, dc.DestinationRect, paint);
                                                                    }
                                                                    paint.ColorFilter = null;
                                                                }
                                                            }
                                                        }
                                                        _drawCommandList.Clear();

                                                        paint.Color = SKColors.Black;
                                                        for (int mapx = startX; mapx <= endX; mapx++)
                                                        {
                                                            for (int mapy = startY; mapy <= endY; mapy++)
                                                            {
                                                                bool ascension_radiance = (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_ASCENSION_RADIANCE) != 0
                                                                    && (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_CAN_SEE) != 0;
                                                                if (ascension_radiance)
                                                                {
                                                                    float multiplier = 1.0f - Math.Min(1.0f, 0.3f + (float)Math.Sqrt(Math.Pow(mapx - _local_ux, 2) + Math.Pow(mapy - _local_uy, 2)) / 6.0f);
                                                                    int val = (int)(multiplier * 255);
                                                                    SKColor color = new SKColor((byte)val, (byte)val, (byte)val);

                                                                    paint.Color = color;
                                                                    SKBlendMode old_bm = paint.BlendMode;
                                                                    paint.BlendMode = SKBlendMode.Screen;
                                                                    tx = (offsetX + usedOffsetX + width * (float)mapx);
                                                                    ty = (offsetY + usedOffsetY + mapFontAscent + height * (float)mapy);
                                                                    SKRect targetrect = new SKRect(tx, ty, tx + width, ty + height);
#if GNH_MAP_PROFILING && DEBUG
                                                                        StartProfiling(GHProfilingStyle.Rect);
#endif
                                                                    canvas.DrawRect(targetrect, paint);
                                                                    //enlCanvas.DrawRect(targetrect, paint);
#if GNH_MAP_PROFILING && DEBUG
                                                                        StopProfiling(GHProfilingStyle.Rect);
#endif
                                                                    paint.BlendMode = old_bm;
                                                                    if ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_UXUY) != 0)
                                                                    {
                                                                        UIUtils.DrawSparkle(canvas, paint, tx + 0.5f * width, ty + 0.5f * height, 15f * targetscale, generalcountervalue, true);
                                                                        UIUtils.DrawSparkle(canvas, paint, tx + 0.25f * width, ty + 0.25f * height, 10f * targetscale, generalcountervalue - 10, true);
                                                                        UIUtils.DrawSparkle(canvas, paint, tx + 0.75f * width, ty + 0.25f * height, 10f * targetscale, generalcountervalue - 20, true);
                                                                        UIUtils.DrawSparkle(canvas, paint, tx + 0.25f * width, ty + 0.75f * height, 10f * targetscale, generalcountervalue - 30, true);
                                                                        UIUtils.DrawSparkle(canvas, paint, tx + 0.75f * width, ty + 0.75f * height, 10f * targetscale, generalcountervalue - 40, true);
                                                                        UIUtils.DrawSparkle(canvas, paint, tx + 0.5f * width, ty, 7f * targetscale, generalcountervalue - 50, true);
                                                                        UIUtils.DrawSparkle(canvas, paint, tx + 0.5f * width, ty + height, 7f * targetscale, generalcountervalue - 60, true);
                                                                        UIUtils.DrawSparkle(canvas, paint, tx, ty + 0.5f * height, 7f * targetscale, generalcountervalue - 70, true);
                                                                        UIUtils.DrawSparkle(canvas, paint, tx + width, ty + 0.5f * height, 7f * targetscale, generalcountervalue - 80, true);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        /* Cursor */
                        if ((graphicsStyle == GHGraphicsStyle.ASCII || forceAscii) && CursorStyle == TTYCursorStyle.BlinkingUnderline && CursorIsOn && _localMapCursorX >= 1 && _localMapCursorY >= 0)
                        {
                            int cx = _localMapCursorX, cy = _localMapCursorY;
                            str = "_";
                            textPaint.Color = SKColors.White;
                            tx = (offsetX + usedOffsetX + width * (float)cx);
                            ty = (offsetY + usedOffsetY + height * (float)cy);
                            //canvas.DrawText(str, tx, ty, textPaint);
                            textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
                        }
                    }

                    /* Screen Filter */
                    foreach (GHScreenFilter ft in _localScreenFilters)
                    {
                        SKColor fillcolor = SKColors.White;
                        fillcolor = ft.GetColor(generalcountervalue);
                        textPaint.Style = SKPaintStyle.Fill;
                        textPaint.Color = fillcolor;
                        SKRect filterrect = new SKRect(0, 0, canvaswidth, canvasheight);
#if GNH_MAP_PROFILING && DEBUG
                            StartProfiling(GHProfilingStyle.Rect);
#endif
                        canvas.DrawRect(filterrect, textPaint.Paint);
#if GNH_MAP_PROFILING && DEBUG
                            StopProfiling(GHProfilingStyle.Rect);
#endif
                    }

                    /* Floating Texts */
                    if (graphicsStyle != GHGraphicsStyle.ASCII && !forceAscii)
                    {
                        foreach (GHFloatingText ft in _localFloatingTexts)
                        {
                            SKPoint p;
                            float relativestrokewidth = 0.0f;
                            SKColor strokecolor = SKColors.White;
                            SKColor fillcolor = SKColors.White;
                            p = ft.GetPosition(maincountervalue);
                            fillcolor = ft.GetColor(maincountervalue);
                            textPaint.Typeface = ft.GetTypeface(maincountervalue);
                            textPaint.TextSize = usedFontSize * ft.GetRelativeTextSize(maincountervalue);
                            relativestrokewidth = ft.GetRelativeOutlineWidth(maincountervalue);
                            strokecolor = ft.GetOutlineColor(maincountervalue);
                            str = ft.GetText(maincountervalue);
                            textPaint.MeasureText(str, ref textBounds);
                            tx = (offsetX + usedOffsetX + width * p.X - textBounds.Width / 2);
                            ty = (offsetY + usedOffsetY + height * p.Y - textBounds.Height / 2);
                            if (relativestrokewidth > 0)
                            {
                                textPaint.Style = SKPaintStyle.Stroke;
                                textPaint.StrokeWidth = textPaint.TextSize * relativestrokewidth;
                                textPaint.Color = strokecolor;
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                //canvas.DrawText(str, tx, ty, textPaint);
                                textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Text);
#endif
                            }
                            textPaint.Style = SKPaintStyle.Fill;
                            textPaint.Color = fillcolor;
#if GNH_MAP_PROFILING && DEBUG
                                StartProfiling(GHProfilingStyle.Bitmap);
#endif
                            //canvas.DrawText(str, tx, ty, textPaint);
                            textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
#if GNH_MAP_PROFILING && DEBUG
                                StopProfiling(GHProfilingStyle.Bitmap);
#endif
                        }
                        if (_localScreenText != null)
                        {
                            float targetwidth = 0, yoffsetpct = 0, relativestrokewidth = 0, relativesuperstrokewidth = 0, relativesubstrokewidth = 0;
                            SKColor strokecolor = SKColors.White, superstrokecolor = SKColors.White, substrokecolor = SKColors.White;
                            SKColor fillcolor = SKColors.White;
                            float maxfontsize = 9999.0f;
                            double canvasheightscale = gamePageHeight / Math.Max(1.0, canvasViewHeight);
                            fillcolor = _localScreenText.GetTextColor(maincountervalue);
                            textPaint.Typeface = _localScreenText.GetTextTypeface(maincountervalue);
                            targetwidth = Math.Min(canvaswidth, canvasheight * (float)canvasheightscale) * _localScreenText.GetMainTextSizeRelativeToScreenWidth(maincountervalue);
                            maxfontsize = _localScreenText.GetMainTextMaxFontSize(maincountervalue);
                            yoffsetpct = _localScreenText.GetYOffsetPctOfScreen(maincountervalue);
                            relativestrokewidth = _localScreenText.GetRelativeTextOutlineWidth(maincountervalue);
                            strokecolor = _localScreenText.GetTextOutlineColor(maincountervalue);
                            str = _localScreenText.GetText(maincountervalue);
                            bool useFontSizeStr = str == null || str.Length < 5;
                            textPaint.TextSize = usedFontSize;
                            textPaint.MeasureText(useFontSizeStr ? _fontSizeString : str, ref textBounds);
                            if (textBounds.Width > 0)
                            {
                                float relativesize = targetwidth / Math.Max(1.0f, textBounds.Width);
                                //if (relativesize > maxfontsize)
                                //    relativesize = maxfontsize;
                                textPaint.TextSize = usedFontSize * relativesize;
                            }

                            textPaint.MeasureText(str, ref textBounds);
                            float maintextascent = textPaint.FontMetrics.Ascent;
                            float maintextdescent = textPaint.FontMetrics.Descent;

                            tx = (canvaswidth / 2 - textBounds.Width / 2);
                            ty = (canvasheight / 2 - textBounds.Height / 2 - (maintextascent + maintextdescent) / 2) + yoffsetpct * canvasheight;
#if GNH_MAP_PROFILING && DEBUG
                                StartProfiling(GHProfilingStyle.Text);
#endif
                            /* Shadow first */
                            {
                                textPaint.Color = SKColors.Black.WithAlpha(fillcolor.Alpha);
                                textPaint.MaskFilter = _blur;
                                float offset = textPaint.TextSize / 15;
                                //canvas.DrawText(str, tx + offset, ty + offset, textPaint);
                                textPaint.DrawTextOnCanvas(canvas, str, tx + offset, ty + offset);
                                textPaint.MaskFilter = null;
                            }

                            if (relativestrokewidth > 0)
                            {
                                textPaint.Style = SKPaintStyle.Stroke;
                                textPaint.StrokeWidth = textPaint.TextSize * relativestrokewidth;
                                textPaint.Color = strokecolor;
                                //canvas.DrawText(str, tx, ty, textPaint);
                                textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
                            }

                            textPaint.Style = SKPaintStyle.Fill;
                            textPaint.Color = fillcolor;
                            //canvas.DrawText(str, tx, ty, textPaint);
                            textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
#if GNH_MAP_PROFILING && DEBUG
                                StopProfiling(GHProfilingStyle.Text);
#endif

                            float maintextsize = textPaint.TextSize;
                            float maintextspacing = textPaint.FontSpacing;
                            float maintexty = ty;

                            if (_localScreenText.HasSuperText)
                            {
                                fillcolor = _localScreenText.GetSuperTextColor(maincountervalue);
                                textPaint.Typeface = _localScreenText.GetSuperTextTypeface(maincountervalue);
                                textPaint.TextSize = maintextsize * _localScreenText.GetSuperTextSizeRelativeToMainText(maincountervalue);
                                relativesuperstrokewidth = _localScreenText.GetRelativeSuperTextOutlineWidth(maincountervalue);
                                superstrokecolor = _localScreenText.GetSuperTextOutlineColor(maincountervalue);
                                str = _localScreenText.GetSuperText(maincountervalue);
                                textPaint.MeasureText(str, ref textBounds);
                                tx = (canvaswidth / 2 - textBounds.Width / 2);
                                ty = maintexty + maintextascent - textPaint.FontMetrics.Descent;

#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                /* Shadow first */
                                {
                                    SKMaskFilter oldfilter = textPaint.MaskFilter;
                                    textPaint.Color = SKColors.Black.WithAlpha(fillcolor.Alpha);
                                    textPaint.MaskFilter = _blur;
                                    float offset = textPaint.TextSize / 15;
                                    //canvas.DrawText(str, tx + offset, ty + offset, textPaint);
                                    textPaint.DrawTextOnCanvas(canvas, str, tx + offset, ty + offset);
                                    textPaint.MaskFilter = null;
                                }

                                if (relativesuperstrokewidth > 0)
                                {
                                    textPaint.Style = SKPaintStyle.Stroke;
                                    textPaint.StrokeWidth = textPaint.TextSize * relativesuperstrokewidth;
                                    textPaint.Color = superstrokecolor;
                                    //canvas.DrawText(str, tx, ty, textPaint);
                                    textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
                                }

                                textPaint.Style = SKPaintStyle.Fill;
                                textPaint.Color = fillcolor;
                                //canvas.DrawText(str, tx, ty, textPaint);
                                textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Text);
#endif
                            }

                            if (_localScreenText.HasSubText)
                            {
                                fillcolor = _localScreenText.GetSubTextColor(maincountervalue);
                                textPaint.Typeface = _localScreenText.GetSubTextTypeface(maincountervalue);
                                textPaint.TextSize = maintextsize * _localScreenText.GetSubTextSizeRelativeToMainText(maincountervalue);
                                relativesubstrokewidth = _localScreenText.GetRelativeSubTextOutlineWidth(maincountervalue);
                                substrokecolor = _localScreenText.GetSubTextOutlineColor(maincountervalue);
                                str = _localScreenText.GetSubText(maincountervalue);
                                textPaint.MeasureText(str, ref textBounds);
                                tx = (canvaswidth / 2 - textBounds.Width / 2);
                                ty = maintexty + maintextdescent - textPaint.FontMetrics.Ascent;

#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                /* Shadow first */
                                {
                                    SKMaskFilter oldfilter = textPaint.MaskFilter;
                                    textPaint.Color = SKColors.Black.WithAlpha(fillcolor.Alpha);
                                    textPaint.MaskFilter = _blur;
                                    float offset = textPaint.TextSize / 15;
                                    //canvas.DrawText(str, tx + offset, ty + offset, textPaint);
                                    textPaint.DrawTextOnCanvas(canvas, str, tx + offset, ty + offset);
                                    textPaint.MaskFilter = null;
                                }

                                if (relativesubstrokewidth > 0)
                                {
                                    textPaint.Style = SKPaintStyle.Stroke;
                                    textPaint.StrokeWidth = textPaint.TextSize * relativesubstrokewidth;
                                    textPaint.Color = substrokecolor;
                                    //canvas.DrawText(str, tx, ty, textPaint);
                                    textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
                                    textPaint.Style = SKPaintStyle.Fill;
                                }

                                textPaint.Style = SKPaintStyle.Fill;
                                textPaint.Color = fillcolor;
                                //canvas.DrawText(str, tx, ty, textPaint);
                                textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Text);
#endif
                            }
                        }
                        foreach (GHConditionText ft in _localConditionTexts)
                        {
                            float relativestrokewidth = 0.0f;
                            SKColor strokecolor = SKColors.White;
                            SKColor fillcolor = SKColors.White;
                            float relativetoscreenwidth = 0.0f;
                            string sampletext = "";
                            fillcolor = ft.GetColor(maincountervalue);
                            textPaint.Typeface = ft.GetTypeface(maincountervalue);
                            relativetoscreenwidth = ft.GetRelativeSampleTextSize(maincountervalue);
                            relativestrokewidth = ft.GetRelativeOutlineWidth(maincountervalue);
                            strokecolor = ft.GetOutlineColor(maincountervalue);
                            str = ft.GetText(maincountervalue);

                            textPaint.TextSize = usedFontSize;
                            sampletext = ft.GetSampleText();
                            textPaint.MeasureText(sampletext, ref textBounds);
                            if (textBounds.Width > 0)
                            {
                                float relativesize = relativetoscreenwidth * Math.Min(canvaswidth, canvasheight) / textBounds.Width;
                                textPaint.TextSize = usedFontSize * relativesize;
                            }

                            //textPaint.TextAlign = SKTextAlign.Center;
                            tx = canvaswidth / 2;
                            ty = statusBarSkiaHeight + 1.5f * inverse_canvas_scale * (float)stdButtonHeight - textPaint.FontMetrics.Ascent;
#if GNH_MAP_PROFILING && DEBUG
                                StartProfiling(GHProfilingStyle.Text);
#endif
                            if (relativestrokewidth > 0)
                            {
                                textPaint.Style = SKPaintStyle.Stroke;
                                textPaint.StrokeWidth = textPaint.TextSize * relativestrokewidth;
                                textPaint.Color = strokecolor;
                                //canvas.DrawText(str, tx, ty, textPaint);
                                textPaint.DrawTextOnCanvas(canvas, str, tx, ty, SKTextAlign.Center);
                            }
                            textPaint.Style = SKPaintStyle.Fill;
                            textPaint.Color = fillcolor;
                            //canvas.DrawText(str, tx, ty, textPaint);
                            textPaint.DrawTextOnCanvas(canvas, str, tx, ty, SKTextAlign.Center);
#if GNH_MAP_PROFILING && DEBUG
                                StopProfiling(GHProfilingStyle.Text);
#endif
                            //textPaint.TextAlign = SKTextAlign.Left;
                        }
                        foreach (GHGUIEffect eff in _localGuiEffects)
                        {
                            SKPoint p;
                            SKColor effcolor;
                            p = eff.GetPosition(maincountervalue);
                            effcolor = eff.GetColor(maincountervalue);
                            tx = offsetX + usedOffsetX + width * p.X;
                            ty = offsetY + usedOffsetY + height * p.Y + mapFontAscent;
                            textPaint.Color = effcolor;
#if GNH_MAP_PROFILING && DEBUG
                                StartProfiling(GHProfilingStyle.Bitmap);
#endif
                            switch (eff.Style)
                            {
                                case (int)gui_effect_types.GUI_EFFECT_SEARCH:
                                    for (int search_x = -1; search_x <= 1; search_x++)
                                    {
                                        for (int search_y = -1; search_y <= 1; search_y++)
                                        {
                                            if (search_x == 0 && search_y == 0)
                                                continue;
                                            if (p.X + search_x < 1 || p.X + search_x >= GHConstants.MapCols
                                                || p.Y + search_y < 0 || p.Y + search_y >= GHConstants.MapRows)
                                                continue;
                                            float rectsize = Math.Min(width, height);
                                            float rectxmargin = (width - rectsize) / 2;
                                            float rectymargin = (height - rectsize) / 2;
                                            float rectleft = tx + search_x * width + rectxmargin;
                                            float recttop = ty + search_y * height + rectymargin;
                                            SKRect effRect = new SKRect(rectleft, recttop, rectleft + rectsize, recttop + rectsize);
                                            SKRect sourcerect = new SKRect(0, 0, GHApp._searchBitmap.Width, GHApp._searchBitmap.Height);
                                            GHApp.MaybeFixRects(ref sourcerect, ref effRect, targetscale, usingGL, fixRects);
                                            canvas.DrawImage(GHApp._searchBitmap, sourcerect, effRect, textPaint.Paint);
                                        }
                                    }
                                    break;
                                case (int)gui_effect_types.GUI_EFFECT_WAIT:
                                    {
                                        float rectsize = Math.Min(width, height);
                                        float rectxmargin = (width - rectsize) / 2;
                                        float rectymargin = (height - rectsize) / 2;
                                        float rectleft = tx + rectxmargin;
                                        float recttop = ty + rectymargin;
                                        SKRect effRect = new SKRect(rectleft, recttop, rectleft + rectsize, recttop + rectsize);
                                        SKRect sourcerect = new SKRect(0, 0, GHApp._waitBitmap.Width, GHApp._waitBitmap.Height);
                                        GHApp.MaybeFixRects(ref sourcerect, ref effRect, targetscale, usingGL, fixRects);
                                        canvas.DrawImage(GHApp._waitBitmap, effRect, textPaint.Paint);
                                    }
                                    break;
                                case (int)gui_effect_types.GUI_EFFECT_POLEARM:
                                    {
                                        using (new SKAutoCanvasRestore(canvas))
                                        {
                                            int dx = eff.X2 - eff.X1;
                                            int dy = eff.Y2 - eff.Y1;
                                            if (dx == 0 && dy == 0)
                                                break;

                                            float length;
                                            canvas.Translate(tx + width / 2, ty + height / 2);
                                            if (dx == 0)
                                            {
                                                canvas.RotateDegrees(dy < 0 ? 0f : 180f);
                                                length = Math.Abs(dy * height);
                                            }
                                            else if (dy == 0)
                                            {
                                                canvas.RotateDegrees(dx < 0 ? -90f : 90f);
                                                length = Math.Abs(dx * width);
                                            }
                                            else
                                            {
                                                canvas.RotateRadians((float)Math.Atan2(-dx * width, dy * height) + (float)Math.PI);
                                                length = (float)Math.Sqrt(Math.Pow(dx * width, 2) + Math.Pow(dy * height, 2));
                                            }
                                            /* Secondary drawing first */
                                            using (SKPath path = new SKPath())
                                            {
                                                switch (eff.SubType)
                                                {
                                                    case (int)gui_polearm_types.GUI_POLEARM_LANCE: /* Handle */
                                                        path.MoveTo(-0.04f * width, 0f);
                                                        path.LineTo(0.04f * width, 0f);
                                                        path.LineTo(0.04f * width, -0.52f * width);
                                                        path.LineTo(-0.04f * width, -0.52f * width);
                                                        path.LineTo(-0.04f * width, 0f);
                                                        path.Close();
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        textPaint.Color = eff.GetSecondaryColor(maincountervalue);
                                                        canvas.DrawPath(path, textPaint.Paint);
                                                        textPaint.Style = SKPaintStyle.Stroke;
                                                        textPaint.StrokeWidth = width * 0.02f;
                                                        textPaint.Color = eff.GetSecondaryOutlineColor(maincountervalue);
                                                        canvas.DrawPath(path, textPaint.Paint);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            path2.MoveTo(-0.015f * width, -0.05f * width);
                                                            path2.LineTo(0.015f * width, -0.05f * width);
                                                            path2.LineTo(0.015f * width, -0.47f * width);
                                                            path2.LineTo(-0.015f * width, -0.47f * width);
                                                            path2.LineTo(-0.015f * width, -0.05f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                            textPaint.Color = eff.GetSecondaryInnerColor(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                        }
                                                        break;
                                                    default:
                                                        break;
                                                }
                                            }
                                            /* Primary drawing */
                                            using (SKPath path = new SKPath())
                                            {
                                                switch (eff.SubType)
                                                {
                                                    case (int)gui_polearm_types.GUI_POLEARM_SPEAR:
                                                        path.MoveTo(-0.04f * width, 0f);
                                                        path.LineTo(0.04f * width, 0f);
                                                        path.LineTo(0.04f * width, -length + 0.4f * width);
                                                        path.LineTo(-0.04f * width, -length + 0.4f * width);
                                                        path.LineTo(-0.04f * width, 0f);
                                                        path.Close();
                                                        textPaint.Color = eff.GetColor(maincountervalue);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        canvas.DrawPath(path, textPaint.Paint);
                                                        textPaint.Style = SKPaintStyle.Stroke;
                                                        textPaint.StrokeWidth = width * 0.02f;
                                                        textPaint.Color = eff.GetOutlineColor(maincountervalue);
                                                        canvas.DrawPath(path, textPaint.Paint);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            path2.MoveTo(-0.015f * width, -0.05f * width);
                                                            path2.LineTo(0.015f * width, -0.05f * width);
                                                            path2.LineTo(0.015f * width, -length + 0.35f * width);
                                                            path2.LineTo(-0.015f * width, -length + 0.35f * width);
                                                            path2.LineTo(-0.015f * width, -0.05f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                            textPaint.Color = eff.GetInnerColor(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                        }
                                                        break;
                                                    case (int)gui_polearm_types.GUI_POLEARM_LANCE:
                                                        path.MoveTo(-0.12f * width, -0.52f * width);
                                                        path.LineTo(0.12f * width, -0.52f * width);
                                                        path.LineTo(0.05f * width, -0.68f * width);
                                                        path.LineTo(0f, -length - 0.2f * width);
                                                        path.LineTo(-0.05f * width, -0.68f * width);
                                                        path.LineTo(-0.12f * width, -0.52f * width);
                                                        path.Close();
                                                        textPaint.Color = eff.GetColor(maincountervalue);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        canvas.DrawPath(path, textPaint.Paint);
                                                        textPaint.Style = SKPaintStyle.Stroke;
                                                        textPaint.StrokeWidth = width * 0.02f;
                                                        textPaint.Color = eff.GetOutlineColor(maincountervalue);
                                                        canvas.DrawPath(path, textPaint.Paint);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            path2.MoveTo(-0.08f * width, -0.58f * width);
                                                            path2.LineTo(0.08f * width, -0.58f * width);
                                                            path2.LineTo(0.02f * width, -0.74f * width);
                                                            path2.LineTo(0f, -length - 0.14f * width);
                                                            path2.LineTo(-0.02f * width, -0.74f * width);
                                                            path2.LineTo(-0.08f * width, -0.58f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                            textPaint.Color = eff.GetInnerColor(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                        }
                                                        break;
                                                    case (int)gui_polearm_types.GUI_POLEARM_THRUSTED:
                                                    case (int)gui_polearm_types.GUI_POLEARM_POLEAXE:
                                                    default:
                                                        path.MoveTo(-0.05f * width, 0f);
                                                        path.LineTo(0.05f * width, 0f);
                                                        path.LineTo(0.05f * width, -length);
                                                        path.LineTo(-0.05f * width, -length);
                                                        path.LineTo(-0.05f * width, 0f);
                                                        path.Close();
                                                        textPaint.Color = eff.GetColor(maincountervalue);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        canvas.DrawPath(path, textPaint.Paint);
                                                        textPaint.Style = SKPaintStyle.Stroke;
                                                        textPaint.StrokeWidth = width * 0.02f;
                                                        textPaint.Color = eff.GetOutlineColor(maincountervalue);
                                                        canvas.DrawPath(path, textPaint.Paint);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            path2.MoveTo(-0.02f * width, -0.05f * width);
                                                            path2.LineTo(0.02f * width, -0.05f * width);
                                                            path2.LineTo(0.02f * width, -length - 0.05f * width);
                                                            path2.LineTo(-0.02f * width, -length - 0.05f * width);
                                                            path2.LineTo(-0.02f * width, -0.05f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                            textPaint.Color = eff.GetInnerColor(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                        }
                                                        break;
                                                }
                                            }
                                            /* Secondary drawing last */
                                            using (SKPath path = new SKPath())
                                            {
                                                switch (eff.SubType)
                                                {
                                                    case (int)gui_polearm_types.GUI_POLEARM_SPEAR: /* Spearhead */
                                                        path.MoveTo(-0.06f * width, -length + 0.4f * width);
                                                        path.LineTo(0.06f * width, -length + 0.4f * width);
                                                        path.LineTo(0f, -length);
                                                        path.LineTo(-0.06f * width, -length + 0.4f * width);
                                                        path.Close();
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        textPaint.Color = eff.GetSecondaryColor(maincountervalue);
                                                        canvas.DrawPath(path, textPaint.Paint);
                                                        textPaint.Style = SKPaintStyle.Stroke;
                                                        textPaint.StrokeWidth = width * 0.02f;
                                                        textPaint.Color = eff.GetSecondaryOutlineColor(maincountervalue);
                                                        canvas.DrawPath(path, textPaint.Paint);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            path2.MoveTo(-0.025f * width, -length + 0.35f * width);
                                                            path2.LineTo(0.025f * width, -length + 0.35f * width);
                                                            path2.LineTo(0f, -length + 0.05f * width);
                                                            path2.LineTo(-0.025f * width, -length + 0.35f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                            textPaint.Color = eff.GetSecondaryInnerColor(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                        }
                                                        break;
                                                    case (int)gui_polearm_types.GUI_POLEARM_POLEAXE: /* Polearm head */
                                                    case (int)gui_polearm_types.GUI_POLEARM_THRUSTED: /* Polearm head */
                                                        /* Tip */
                                                        path.MoveTo(-0.04f * width, -length);
                                                        path.LineTo(0.04f * width, -length);
                                                        path.LineTo(0f, -length - 0.4f * width);
                                                        path.LineTo(-0.04f * width, -length);
                                                        path.Close();
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        textPaint.Color = eff.GetSecondaryColor(maincountervalue);
                                                        canvas.DrawPath(path, textPaint.Paint);
                                                        textPaint.Style = SKPaintStyle.Stroke;
                                                        textPaint.StrokeWidth = width * 0.02f;
                                                        textPaint.Color = eff.GetSecondaryOutlineColor(maincountervalue);
                                                        canvas.DrawPath(path, textPaint.Paint);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            path2.MoveTo(-0.02f * width, -length - 0.05f * width);
                                                            path2.LineTo(0.02f * width, -length - 0.05f * width);
                                                            path2.LineTo(0f, -length - 0.35f * width);
                                                            path2.LineTo(-0.02f * width, -length - 0.05f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                            textPaint.Color = eff.GetSecondaryInnerColor(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                        }
                                                        /* Left side */
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            /* Middle color part 1 */
                                                            path2.MoveTo(-0.04f * width, -length - 0.4f * width + 0.5f * width);
                                                            path2.LineTo(-0.1f * width, -length - 0.4f * width + 0.5f * width);
                                                            path2.LineTo(-0.1f * width, -length - 0.4f * width + 0.65f * width);
                                                            path2.LineTo(-0.16f * width, -length - 0.4f * width + 0.60f * width);
                                                            path2.LineTo(-0.16f * width, -length - 0.4f * width + 0.30f * width);
                                                            path2.LineTo(-0.1f * width, -length - 0.4f * width + 0.25f * width);
                                                            path2.LineTo(-0.1f * width, -length - 0.4f * width + 0.4f * width);
                                                            path2.LineTo(-0.04f * width, -length - 0.4f * width + 0.4f * width);
                                                            path2.LineTo(-0.04f * width, -length - 0.4f * width + 0.5f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                            textPaint.Color = eff.GetSecondaryInner2Color(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                        }
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            /* Middle color part 2 */
                                                            path2.MoveTo(-0.1f * width, -length - 0.4f * width + 0.65f * width);
                                                            path2.LineTo(-0.1f * width, -length - 0.4f * width + 0.75f * width);
                                                            path2.LineTo(-0.3f * width, -length - 0.4f * width + 0.45f * width);
                                                            path2.LineTo(-0.1f * width, -length - 0.4f * width + 0.15f * width);
                                                            path2.LineTo(-0.1f * width, -length - 0.4f * width + 0.25f * width);
                                                            path2.LineTo(-0.16f * width, -length - 0.4f * width + 0.30f * width);
                                                            path2.LineTo(-0.24f * width, -length - 0.4f * width + 0.45f * width);
                                                            path2.LineTo(-0.16f * width, -length - 0.4f * width + 0.60f * width);
                                                            path2.LineTo(-0.1f * width, -length - 0.4f * width + 0.65f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                            textPaint.Color = eff.GetSecondaryColor(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                        }
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            /* Outline */
                                                            path2.MoveTo(-0.04f * width, -length - 0.4f * width + 0.5f * width);
                                                            path2.LineTo(-0.1f * width, -length - 0.4f * width + 0.5f * width);
                                                            path2.LineTo(-0.1f * width, -length - 0.4f * width + 0.75f * width);
                                                            path2.LineTo(-0.3f * width, -length - 0.4f * width + 0.45f * width);
                                                            path2.LineTo(-0.1f * width, -length - 0.4f * width + 0.15f * width);
                                                            path2.LineTo(-0.1f * width, -length - 0.4f * width + 0.4f * width);
                                                            path2.LineTo(-0.04f * width, -length - 0.4f * width + 0.4f * width);
                                                            path2.LineTo(-0.04f * width, -length - 0.4f * width + 0.5f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Stroke;
                                                            textPaint.StrokeWidth = width * 0.03f;
                                                            textPaint.Color = eff.GetSecondaryOutlineColor(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                        }
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            /* Inner color */
                                                            path2.MoveTo(-0.16f * width, -length - 0.4f * width + 0.60f * width);
                                                            path2.LineTo(-0.24f * width, -length - 0.4f * width + 0.45f * width);
                                                            path2.LineTo(-0.16f * width, -length - 0.4f * width + 0.30f * width);
                                                            path2.LineTo(-0.16f * width, -length - 0.4f * width + 0.60f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                            textPaint.Color = eff.GetSecondaryInnerColor(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                        }
                                                        /* Right side */
                                                        //using (SKPath path2 = new SKPath())
                                                        //{
                                                        //    /* Middle color */
                                                        //    path2.MoveTo(0.04f * width, -length - 0.4f * width + 0.5f * width);
                                                        //    path2.LineTo(0.1f * width, -length - 0.4f * width + 0.5f * width);
                                                        //    path2.LineTo(0.1f * width, -length - 0.4f * width + 0.75f * width);
                                                        //    path2.LineTo(0.3f * width, -length - 0.4f * width + 0.45f * width);
                                                        //    path2.LineTo(0.1f * width, -length - 0.4f * width + 0.15f * width);
                                                        //    path2.LineTo(0.1f * width, -length - 0.4f * width + 0.4f * width);
                                                        //    path2.LineTo(0.04f * width, -length - 0.4f * width + 0.4f * width);
                                                        //    path2.LineTo(0.04f * width, -length - 0.4f * width + 0.5f * width);
                                                        //    path2.Close();
                                                        //    textPaint.Style = SKPaintStyle.Fill;
                                                        //    textPaint.Color = eff.GetSecondaryColor(maincountervalue);
                                                        //    canvas.DrawPath(path2, textPaint);
                                                        //    textPaint.Style = SKPaintStyle.Stroke;
                                                        //    textPaint.StrokeWidth = width * 0.03f;
                                                        //    textPaint.Color = eff.GetSecondaryOutlineColor(maincountervalue);
                                                        //    canvas.DrawPath(path2, textPaint);
                                                        //    textPaint.Style = SKPaintStyle.Fill;
                                                        //}
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            /* Middle color part 1 */
                                                            path2.MoveTo(0.04f * width, -length - 0.4f * width + 0.5f * width);
                                                            path2.LineTo(0.1f * width, -length - 0.4f * width + 0.5f * width);
                                                            path2.LineTo(0.1f * width, -length - 0.4f * width + 0.65f * width);
                                                            path2.LineTo(0.16f * width, -length - 0.4f * width + 0.60f * width);
                                                            path2.LineTo(0.16f * width, -length - 0.4f * width + 0.30f * width);
                                                            path2.LineTo(0.1f * width, -length - 0.4f * width + 0.25f * width);
                                                            path2.LineTo(0.1f * width, -length - 0.4f * width + 0.4f * width);
                                                            path2.LineTo(0.04f * width, -length - 0.4f * width + 0.4f * width);
                                                            path2.LineTo(0.04f * width, -length - 0.4f * width + 0.5f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                            textPaint.Color = eff.GetSecondaryInner2Color(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                        }
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            /* Middle color part 2 */
                                                            path2.MoveTo(0.1f * width, -length - 0.4f * width + 0.65f * width);
                                                            path2.LineTo(0.1f * width, -length - 0.4f * width + 0.75f * width);
                                                            path2.LineTo(0.3f * width, -length - 0.4f * width + 0.45f * width);
                                                            path2.LineTo(0.1f * width, -length - 0.4f * width + 0.15f * width);
                                                            path2.LineTo(0.1f * width, -length - 0.4f * width + 0.25f * width);
                                                            path2.LineTo(0.16f * width, -length - 0.4f * width + 0.30f * width);
                                                            path2.LineTo(0.24f * width, -length - 0.4f * width + 0.45f * width);
                                                            path2.LineTo(0.16f * width, -length - 0.4f * width + 0.60f * width);
                                                            path2.LineTo(0.1f * width, -length - 0.4f * width + 0.65f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                            textPaint.Color = eff.GetSecondaryColor(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                        }
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            /* Outline */
                                                            path2.MoveTo(0.04f * width, -length - 0.4f * width + 0.5f * width);
                                                            path2.LineTo(0.1f * width, -length - 0.4f * width + 0.5f * width);
                                                            path2.LineTo(0.1f * width, -length - 0.4f * width + 0.75f * width);
                                                            path2.LineTo(0.3f * width, -length - 0.4f * width + 0.45f * width);
                                                            path2.LineTo(0.1f * width, -length - 0.4f * width + 0.15f * width);
                                                            path2.LineTo(0.1f * width, -length - 0.4f * width + 0.4f * width);
                                                            path2.LineTo(0.04f * width, -length - 0.4f * width + 0.4f * width);
                                                            path2.LineTo(0.04f * width, -length - 0.4f * width + 0.5f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Stroke;
                                                            textPaint.StrokeWidth = width * 0.03f;
                                                            textPaint.Color = eff.GetSecondaryOutlineColor(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                        }
                                                        using (SKPath path2 = new SKPath())
                                                        {
                                                            /* Inner color */
                                                            path2.MoveTo(0.16f * width, -length - 0.4f * width + 0.60f * width);
                                                            path2.LineTo(0.24f * width, -length - 0.4f * width + 0.45f * width);
                                                            path2.LineTo(0.16f * width, -length - 0.4f * width + 0.30f * width);
                                                            path2.LineTo(0.16f * width, -length - 0.4f * width + 0.60f * width);
                                                            path2.Close();
                                                            textPaint.Style = SKPaintStyle.Fill;
                                                            textPaint.Color = eff.GetSecondaryInnerColor(maincountervalue);
                                                            canvas.DrawPath(path2, textPaint.Paint);
                                                        }
                                                        break;
                                                    default:
                                                        break;
                                                }
                                            }
                                        }
                                    }
                                    break;
                                default:
                                    break;
                            }
#if GNH_MAP_PROFILING && DEBUG
                                StopProfiling(GHProfilingStyle.Bitmap);
#endif

                        }
                    }

                    /* Look mode rectangle */
                    if (mapLookMode)
                    {
                        SKColor oldcolor = textPaint.Color;
                        SKMaskFilter oldfilter = textPaint.MaskFilter;
                        SKPaintStyle oldstyle = textPaint.Style;
                        textPaint.MaskFilter = _lookBlur;
                        textPaint.Style = SKPaintStyle.Stroke;
                        textPaint.StrokeWidth = Math.Max(3, Math.Min(canvasheight, canvaswidth) / 15);
                        textPaint.Color = SKColors.Purple.WithAlpha(128);
#if GNH_MAP_PROFILING && DEBUG
                        StartProfiling(GHProfilingStyle.Rect);
#endif
                        canvas.DrawRect(0, 0, canvaswidth, canvasheight, textPaint.Paint);
#if GNH_MAP_PROFILING && DEBUG
                        StopProfiling(GHProfilingStyle.Rect);
#endif
                        textPaint.Style = oldstyle;
                        textPaint.Color = oldcolor;
                        textPaint.MaskFilter = oldfilter;
                    }
                }

                /* Darkening background */
                if (forceAllMessages || showNumberPad || ShownTip >= 0)
                {
                    textPaint.Style = SKPaintStyle.Fill;
                    textPaint.Color = forceAllMessages && !HasAllMessagesTransparentBackground ? SKColors.Black : SKColors.Black.WithAlpha(128);
#if GNH_MAP_PROFILING && DEBUG
                    StartProfiling(GHProfilingStyle.Rect);
#endif
                    canvas.DrawRect(0, 0, canvaswidth, canvasheight, textPaint.Paint);
#if GNH_MAP_PROFILING && DEBUG
                    StopProfiling(GHProfilingStyle.Rect);
#endif
                }

                /* Window strings */
                float lastStatusRowPrintY = 0.0f;
                float lastStatusRowFontSpacing = 0.0f;
                float herewindowtop = canvasheight;
                float messagewindowtop = canvasheight;

                //lock (_canvasButtonLock)
                {
                    _localCanvasButtonRect.Top = 0; /* Maybe overrwritten below */
                    _localCanvasButtonRect.Bottom = canvasheight; /* Maybe overrwritten below */
                    GHWindow ghWindow = null;
                    GHWindow messageWindow = null;
                    GHSubstring substr = new GHSubstring("");
                    for (int i = 0; i < GHConstants.MaxGHWindows; i++)
                    {
                        if (curGame == null)
                            break;
                        lock (_localWindowLock)
                        {
                            ghWindow = _localGHWindows[i];
                            messageWindow = _localGHWindows[messageWindowId];
                        }
                        if (ghWindow == null || messageWindow == null)
                            break;

                        if (ghWindow.Visible && (
                            ghWindow.WindowPrintStyle == GHWindowPrintLocations.PrintToMap
                            || ghWindow.WindowPrintStyle == GHWindowPrintLocations.RawPrint))
                        {
                            if (ghWindow.WindowType == GHWinType.Status && !ClassicStatusBar)
                                continue;

                            textPaint.Typeface = ghWindow.Typeface;
                            textPaint.TextSize = ghWindow.TextSize * (ghWindow.WindowType == GHWinType.Status ? statusBarTextScale : messageTextScale);
                            textPaint.Color = ghWindow.TextColor;
                            width = textPaint.MeasureText("A"); // textPaint.FontMetrics.AverageCharacterWidth;
                            height = textPaint.FontSpacing; // textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent;

                            if (ghWindow.AutoPlacement)
                            {
                                if (ghWindow.WindowType == GHWinType.Message)
                                {
                                    float newleft = 0;
                                    float newtop = canvasheight - height * ActualDisplayedMessages - (float)usedButtonRowStackHeight * inverse_canvas_scale - GHConstants.ContextButtonBottomStartMargin;
                                    ghWindow.Left = newleft;
                                    ghWindow.Top = newtop;
                                }
                                else if (ghWindow.WindowType == GHWinType.Here)
                                {
                                    float newleft = 0;
                                    float messagetop = messageWindow.Top;
                                    float newtop = messagetop - height * ghWindow.HeightInChars - ghWindow.Padding.Top - ghWindow.Padding.Bottom - 10f * messageTextScale;
                                    ghWindow.Left = newleft;
                                    ghWindow.Top = newtop;
                                }
                            }

                            SKRect winRect = ghWindow.GetWindowRect(ghWindow.WindowType == GHWinType.Status ? statusBarTextMultiplier : messageTextMultiplier);

                            if (ghWindow.CenterHorizontally && winRect.Right - winRect.Left < canvaswidth)
                            {
                                float newleft = (canvaswidth - (winRect.Right - winRect.Left)) / 2;
                                float addition = newleft - winRect.Left;
                                winRect.Left += addition;
                                winRect.Right += addition;
                            }

                            switch (ghWindow.WindowType)
                            {
                                case GHWinType.Here:
                                    herewindowtop = winRect.Top;
                                    break;
                                case GHWinType.Message:
                                    messagewindowtop = winRect.Top;
                                    break;
                                default:
                                    break;
                            }

                            using (SKPaint winPaint = new SKPaint())
                            {
                                //winPaint.FilterQuality = SKFilterQuality.None;

                                winPaint.Color = ghWindow.BackgroundColor;
                                winPaint.Style = SKPaintStyle.Fill;

                                if (winPaint.Color != SKColors.Transparent)
                                {
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Rect);
#endif
                                    canvas.DrawRect(winRect, winPaint);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Rect);
#endif
                                }

                                if (i == statusWindowId && ClassicStatusBar)
                                    _localCanvasButtonRect.Top = winRect.Bottom;
                                else if (i == messageWindowId)
                                    _localCanvasButtonRect.Bottom = winRect.Top;
                            }

                            if (ghWindow.WindowType != GHWinType.Message && !forceAllMessages)
                            {
                                //lock (_localPutStrLock)
                                {
                                    int j = -1;
                                    if (ghWindow.PutStrs != null)
                                    {
                                        List<GHPutStrItem> putStrs = ghWindow.PutStrs;
                                        foreach (GHPutStrItem putstritem in putStrs)
                                        {
                                            if (putstritem == null)
                                                break;
                                            j++;
                                            int pos = 0;
                                            float xpos = 0;
                                            float totwidth = 0;
                                            foreach (GHPutStrInstructions instr in putstritem.InstructionList)
                                            {
                                                if (putstritem.Text == null)
                                                    substr.SetValue("");
                                                else if (pos + instr.PrintLength <= putstritem.Text.Length)
                                                    substr.SetValue(putstritem.Text, pos, instr.PrintLength);
                                                else if (putstritem.Text.Length - pos > 0)
                                                    substr.SetValue(putstritem.Text, pos, putstritem.Text.Length - pos);
                                                else
                                                    substr.SetValue("");
                                                pos += substr.Length;
                                                totwidth = textPaint.MeasureText(substr.Value, ref textBounds);

                                                /* attributes */
                                                tx = xpos + winRect.Left + ghWindow.Padding.Left;
                                                ty = winRect.Top + ghWindow.Padding.Top - textPaint.FontMetrics.Ascent + j * height;

#if GNH_MAP_PROFILING && DEBUG
                                            StartProfiling(GHProfilingStyle.Text);
#endif
                                                if (ghWindow.HasShadow)
                                                {
                                                    textPaint.Style = SKPaintStyle.Fill;
                                                    textPaint.Color = SKColors.Black;
                                                    textPaint.MaskFilter = _blur;
                                                    float shadow_offset = 0.15f * textPaint.TextSize;
                                                    textPaint.DrawTextOnCanvas(canvas, substr.Value, tx + shadow_offset, ty + shadow_offset);
                                                    textPaint.MaskFilter = null;
                                                }
                                                if (ghWindow.StrokeWidth > 0)
                                                {
                                                    textPaint.Style = SKPaintStyle.Stroke;
                                                    textPaint.StrokeWidth = ghWindow.StrokeWidth * (ghWindow.WindowType == GHWinType.Status ? statusBarTextScale : messageTextScale);
                                                    textPaint.Color = SKColors.Black;
                                                    textPaint.DrawTextOnCanvas(canvas, substr.Value, tx, ty);
                                                }
                                                textPaint.Style = SKPaintStyle.Fill;
                                                textPaint.Color = UIUtils.NHColor2SKColor(instr.Color < (int)NhColor.CLR_MAX ? instr.Color : (int)NhColor.CLR_WHITE, instr.Attributes);
                                                textPaint.DrawTextOnCanvas(canvas, substr.Value, tx, ty);
                                                textPaint.Style = SKPaintStyle.Fill;
                                                xpos += totwidth;
#if GNH_MAP_PROFILING && DEBUG
                                            StopProfiling(GHProfilingStyle.Text);
#endif

                                                if (ghWindow.WindowType == GHWinType.Status && lastStatusRowPrintY < ty + textPaint.FontMetrics.Descent)
                                                {
                                                    lastStatusRowPrintY = ty + textPaint.FontMetrics.Descent;
                                                    lastStatusRowFontSpacing = textPaint.FontSpacing;
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            if (ghWindow.WindowType == GHWinType.Message)
                            {
                                if (_localMsgHistory != null)
                                {
                                    int j = ActualDisplayedMessages - 1, idx;
                                    float lineLengthLimit = 0.85f * canvaswidth;
                                    float spaceLength = textPaint.MeasureText(" ");

                                    bool refreshsmallesttop = false;
                                    GHSubstring printedsubline = new GHSubstring("");
                                    for (idx = _localMsgHistory.Length - 1; idx >= 0 && j >= 0; idx--)
                                    {
                                        GHMsgHistoryItem msgHistoryItem = _localMsgHistory[idx];
                                        //longLine = msgHistoryItem.Text;
                                        SKColor printColor = UIUtils.NHColor2SKColor(
                                            msgHistoryItem.Colors != null && msgHistoryItem.Colors.Length > 0 ? msgHistoryItem.Colors[0] : msgHistoryItem.NHColor < (int)NhColor.CLR_MAX ? msgHistoryItem.NHColor : (int)NhColor.CLR_WHITE, 
                                            msgHistoryItem.Attributes != null && msgHistoryItem.Attributes.Length > 0 ? msgHistoryItem.Attributes[0] : msgHistoryItem.Attribute);

                                        bool use_one_color = msgHistoryItem.Colors == null && msgHistoryItem.Attributes == null;
                                        int char_idx = 0;

                                        if (RefreshMsgHistoryRowCounts || msgHistoryItem.WrappedTextRows.Count == 0)
                                        {
                                            refreshsmallesttop = true;
                                            msgHistoryItem.WrappedTextRows.Clear();
                                            float lineLength = 0.0f;
                                            //string line = "";
                                            _lineBuilder.Clear();
                                            string[] txtsplit = msgHistoryItem.TextSplit;
                                            bool firstonline = true;
                                            for (int widx = 0; widx < txtsplit.Length; widx++)
                                            {
                                                string word = txtsplit[widx];
                                                //string wordWithSpace = word + " ";
                                                float wordLength = textPaint.MeasureText(word);
                                                float wordWithSpaceLength = wordLength + spaceLength;
                                                if (lineLength + wordLength > lineLengthLimit && !firstonline)
                                                {
                                                    msgHistoryItem.WrappedTextRows.Add(_lineBuilder.ToString());
                                                    //line = wordWithSpace;
                                                    _lineBuilder.Clear();
                                                    _lineBuilder.Append(word);
                                                    _lineBuilder.Append(" ");
                                                    lineLength = wordWithSpaceLength;
                                                    firstonline = true;
                                                }
                                                else
                                                {
                                                    //line += wordWithSpace;
                                                    _lineBuilder.Append(word);
                                                    _lineBuilder.Append(" ");
                                                    lineLength += wordWithSpaceLength;
                                                    firstonline = false;
                                                }
                                            }
                                            msgHistoryItem.WrappedTextRows.Add(_lineBuilder.ToString());
                                        }

                                        if(!msgHistoryItem.MatchFilter)
                                            continue;

                                        int lineidx;
                                        for (lineidx = 0; lineidx < msgHistoryItem.WrappedTextRows.Count; lineidx++)
                                        {
                                            string wrappedLine = msgHistoryItem.WrappedTextRows[lineidx];
                                            int window_row_idx = j + lineidx - msgHistoryItem.WrappedTextRows.Count + 1;
                                            if (window_row_idx < 0)
                                            {
                                                char_idx += wrappedLine.Length;
                                                continue;
                                            }
                                            tx = winRect.Left + ghWindow.Padding.Left;
                                            ty = winRect.Top + ghWindow.Padding.Top - textPaint.FontMetrics.Ascent + window_row_idx * height;
                                            if (forceAllMessages)
                                            {
                                                ty += InterlockedMessageScrollOffset;
                                            }
                                            if (ty + textPaint.FontMetrics.Descent < 0)
                                            {
                                                char_idx += wrappedLine.Length;
                                                continue;
                                            }
                                            if (ty - textPaint.FontMetrics.Ascent > canvasheight)
                                            {
                                                char_idx += wrappedLine.Length;
                                                continue;
                                            }

                                            if (use_one_color)
                                            {
#if GNH_MAP_PROFILING && DEBUG
                                                StartProfiling(GHProfilingStyle.Text);
#endif
                                                textPaint.Style = SKPaintStyle.Stroke;
                                                textPaint.StrokeWidth = ghWindow.StrokeWidth * (ghWindow.WindowType == GHWinType.Status ? statusBarTextScale : messageTextScale);
                                                textPaint.Color = SKColors.Black;
                                                //canvas.DrawText(wrappedLine, tx, ty, textPaint);
                                                textPaint.DrawTextOnCanvas(canvas, wrappedLine, tx, ty);
                                                textPaint.Style = SKPaintStyle.Fill;
                                                textPaint.StrokeWidth = 0;
                                                textPaint.Color = printColor;
                                                //canvas.DrawText(wrappedLine, tx, ty, textPaint);
                                                textPaint.DrawTextOnCanvas(canvas, wrappedLine, tx, ty);
                                                textPaint.Style = SKPaintStyle.Fill;
                                                textPaint.StrokeWidth = 0;
                                                textPaint.Color = SKColors.White;
                                                char_idx += wrappedLine.Length;
#if GNH_MAP_PROFILING && DEBUG
                                                StopProfiling(GHProfilingStyle.Text);
#endif
                                            }
                                            else
                                            {
                                                int charidx_start = 0;
                                                while (char_idx < msgHistoryItem.Text.Length && charidx_start < wrappedLine.Length)
                                                {
                                                    int charidx_len = 0;
                                                    int new_nhcolor = msgHistoryItem.Colors != null && msgHistoryItem.Colors.Length > 0 && char_idx < msgHistoryItem.Colors.Length ? msgHistoryItem.Colors[char_idx] : msgHistoryItem.NHColor < (int)NhColor.CLR_MAX ? msgHistoryItem.NHColor : (int)NhColor.CLR_WHITE;
                                                    int new_nhattr = msgHistoryItem.Attributes != null && msgHistoryItem.Attributes.Length > 0 && char_idx < msgHistoryItem.Attributes.Length ? msgHistoryItem.Attributes[char_idx] : msgHistoryItem.Attribute;
                                                    int char_idx2 = char_idx;
                                                    int new_nhcolor2 = new_nhcolor;
                                                    int new_nhattr2 = new_nhattr;

                                                    while (char_idx2 < msgHistoryItem.Text.Length && charidx_start + charidx_len < wrappedLine.Length && new_nhcolor == new_nhcolor2 && new_nhattr == new_nhattr2)
                                                    {
                                                        char_idx2++;
                                                        new_nhcolor2 = msgHistoryItem.Colors != null && msgHistoryItem.Colors.Length > 0 && char_idx2 < msgHistoryItem.Colors.Length ? msgHistoryItem.Colors[char_idx2] : msgHistoryItem.NHColor < (int)NhColor.CLR_MAX ? msgHistoryItem.NHColor : (int)NhColor.CLR_WHITE;
                                                        new_nhattr2 = msgHistoryItem.Attributes != null && msgHistoryItem.Attributes.Length > 0 && char_idx2 < msgHistoryItem.Attributes.Length ? msgHistoryItem.Attributes[char_idx2] : msgHistoryItem.Attribute;
                                                        charidx_len = char_idx2 - char_idx;
                                                    }

#if GNH_MAP_PROFILING && DEBUG
                                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                                    SKColor new_skcolor = UIUtils.NHColor2SKColor(new_nhcolor, new_nhattr);
                                                    printedsubline.SetValue(wrappedLine, charidx_start, charidx_len);
                                                    textPaint.Style = SKPaintStyle.Stroke;
                                                    textPaint.StrokeWidth = ghWindow.StrokeWidth * (ghWindow.WindowType == GHWinType.Status ? statusBarTextScale : messageTextScale);
                                                    textPaint.Color = SKColors.Black;
                                                    textPaint.DrawTextOnCanvas(canvas, printedsubline.Value, tx, ty);
                                                    textPaint.Style = SKPaintStyle.Fill;
                                                    textPaint.StrokeWidth = 0;
                                                    textPaint.Color = new_skcolor;
                                                    textPaint.DrawTextOnCanvas(canvas, printedsubline.Value, tx, ty);
                                                    float twidth = textPaint.MeasureText(printedsubline.Value);
                                                    textPaint.Style = SKPaintStyle.Fill;
                                                    textPaint.StrokeWidth = 0;
                                                    textPaint.Color = SKColors.White;
#if GNH_MAP_PROFILING && DEBUG
                                                    StopProfiling(GHProfilingStyle.Text);
#endif

                                                    tx += twidth;
                                                    char_idx += charidx_len;
                                                    charidx_start += charidx_len;
                                                }
                                            }
                                        }
                                        j -= msgHistoryItem.WrappedTextRows.Count;
                                    }
                                    RefreshMsgHistoryRowCounts = false;

                                    /* Calculate smallest top */
                                    if(refreshsmallesttop)
                                    {
                                        //lock (_messageScrollLock)
                                        {
                                            float localSmallestTop = canvasheight;
                                            //_messageSmallestTop = canvasheight;
                                            j = ActualDisplayedMessages - 1;
                                            for (idx = _localMsgHistory.Length - 1; idx >= 0 && j >= 0; idx--)
                                            {
                                                GHMsgHistoryItem msgHistoryItem = _localMsgHistory[idx];
                                                if (!msgHistoryItem.MatchFilter)
                                                    continue;
                                                int lineidx;
                                                for (lineidx = 0; lineidx < msgHistoryItem.WrappedTextRows.Count; lineidx++)
                                                {
                                                    string wrappedLine = msgHistoryItem.WrappedTextRows[lineidx];
                                                    int window_row_idx = j + lineidx - msgHistoryItem.WrappedTextRows.Count + 1;
                                                    if (window_row_idx < 0)
                                                        continue;
                                                    ty = winRect.Top + ghWindow.Padding.Top - textPaint.FontMetrics.Ascent + window_row_idx * height;
                                                    if (ty + textPaint.FontMetrics.Ascent < localSmallestTop)
                                                        localSmallestTop = ty + textPaint.FontMetrics.Ascent;
                                                }
                                                j -= msgHistoryItem.WrappedTextRows.Count;
                                            }
                                            float topScrollLimit = Math.Max(0, -localSmallestTop);
                                            InterlockedMessageSmallestTop = localSmallestTop;
                                            if (InterlockedMessageScrollOffset > topScrollLimit)
                                            {
                                                lock (_messageScrollLock)
                                                {
                                                    _messageScrollOffset = topScrollLimit;
                                                    _messageScrollSpeed = 0;
                                                    _messageScrollSpeedOn = false;
                                                    _messageScrollSpeedRecords.Clear();
                                                    InterlockedMessageScrollOffset = _messageScrollOffset;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    

                    float abilitybuttonbottom = (float)(stdCmdLayoutMargin.Top / canvasViewHeight) * canvasheight; ; // (float)((lAbilitiesButton.Y + lAbilitiesButton.Height) / MainCanvasView.Height) * canvasheight;
                    float escbuttonbottom = (float)((stdButtonY + stdButtonHeight) / canvasViewHeight) * canvasheight;
                    if (_localCanvasButtonRect.Top < escbuttonbottom)
                        _localCanvasButtonRect.Top = escbuttonbottom;
                    if (_localCanvasButtonRect.Top < abilitybuttonbottom)
                        _localCanvasButtonRect.Top = abilitybuttonbottom;

                    bool statusfieldsok = false;
                    statusfieldsok = _localStatusFields != null;

                    //_statusBarRectDrawn = false;
                    //_healthRectDrawn = false;
                    //_manaRectDrawn = false;
                    //_skillRectDrawn = false;
                    //_prevWepRectDrawn = false;
                    float orbleft = 5.0f;
                    float orbbordersize = (float)(stdRefButtonWidth * inverse_canvas_scale);

                    if (statusfieldsok && !forceAllMessages)
                    {
                        float statusbarheight = 0;
                        if (!ClassicStatusBar)
                        {
                            float hmargin = GHConstants.StatusBarHorizontalMargin;
                            float vmargin = GHConstants.StatusBarVerticalMargin;
                            float rowmargin = GHConstants.StatusBarRowMargin;
                            float basefontsize = GHConstants.StatusBarBaseFontSize * statusBarTextScale;
                            float shieldfontsize = GHConstants.StatusBarShieldFontSize * statusBarTextScale;
                            float diffontsize = GHConstants.StatusBarDifFontSize * statusBarTextScale;

                            float curx = hmargin;
                            float cury = vmargin;
                            textPaint.TextSize = basefontsize;
                            textPaint.Color = SKColors.Black.WithAlpha(128);
                            float rowheight = textPaint.FontSpacing;
                            float stdspacing = rowheight / 3;
                            float innerspacing = rowheight / 20;
                            statusbarheight = rowheight * 2 + vmargin * 2 + rowmargin;
                            SKRect darkenrect = new SKRect(0, 0, canvaswidth, statusbarheight);
                            statusBarRect = darkenrect;
                            //statusBarRectDrawn = true;
                            _localCanvasButtonRect.Top = darkenrect.Bottom + 1.25f * inverse_canvas_scale * (float)stdButtonWidth;
#if GNH_MAP_PROFILING && DEBUG
                            StartProfiling(GHProfilingStyle.Rect);
#endif
                            canvas.DrawRect(darkenrect, textPaint.Paint);
#if GNH_MAP_PROFILING && DEBUG
                            StopProfiling(GHProfilingStyle.Rect);
#endif
                            textPaint.Color = SKColors.White;
                            textPaint.Typeface = GHApp.LatoRegular;
                            float target_scale = rowheight / GHApp._statusWizardBitmap.Height; // All are 64px high

                            using (SKPaint highQualityPaint = new SKPaint())
                            {
#if !GNH_MAUI
                                highQualityPaint.FilterQuality = SKFilterQuality.High;
#endif
                                string valtext = "";
                                int valcolor = (int)NhColor.CLR_WHITE;
                                SKRect statusDest;
                                SKRect bounds = new SKRect();

                                if (_localStatusFields[(int)NhStatusFields.BL_MODE].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_MODE].Text != null)
                                {
                                    valtext = _localStatusFields[(int)NhStatusFields.BL_MODE].Text;
                                }

                                float target_width = 0;
                                float target_height = 0;
                                if (valtext.Contains("W"))
                                {
                                    target_width = target_scale * GHApp._statusWizardBitmap.Width;
                                    target_height = target_scale * GHApp._statusWizardBitmap.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    canvas.DrawImage(GHApp._statusWizardBitmap, statusDest);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                    curx += target_width;
                                    curx += innerspacing;
                                }

                                if (valtext.Contains("C"))
                                {
                                    target_width = target_scale * GHApp._statusCasualBitmap.Width;
                                    target_height = target_scale * GHApp._statusCasualBitmap.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    canvas.DrawImage(GHApp._statusCasualBitmap, statusDest);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                    curx += target_width;
                                    curx += innerspacing;
                                }
                                else if (valtext.Contains("R"))
                                {
                                    target_width = target_scale * GHApp._statusCasualClassicBitmap.Width;
                                    target_height = target_scale * GHApp._statusCasualClassicBitmap.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    canvas.DrawImage(GHApp._statusCasualClassicBitmap, statusDest);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                    curx += target_width;
                                    curx += innerspacing;
                                }
                                else if (valtext.Contains("M"))
                                {
                                    target_width = target_scale * GHApp._statusModernBitmap.Width;
                                    target_height = target_scale * GHApp._statusModernBitmap.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    canvas.DrawImage(GHApp._statusModernBitmap, statusDest);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                    curx += target_width;
                                    curx += innerspacing;
                                }

                                SKImage difbmp = GHApp._statusDifficultyBitmap;
                                string diftext = "";
                                if (valtext.Contains("s"))
                                {
                                    diftext = "s";
                                    difbmp = GHApp._statusDifficultyVeryEasyBitmap;
                                }
                                else if (valtext.Contains("e"))
                                {
                                    diftext = "e";
                                    difbmp = GHApp._statusDifficultyEasyBitmap;
                                }
                                else if (valtext.Contains("a"))
                                {
                                    diftext = "a";
                                    difbmp = GHApp._statusDifficultyAverageBitmap;
                                }
                                else if (valtext.Contains("v"))
                                {
                                    diftext = "v";
                                    difbmp = GHApp._statusDifficultyHardBitmap;
                                }
                                else if (valtext.Contains("x"))
                                {
                                    diftext = "x";
                                    difbmp = GHApp._statusDifficultyExpertBitmap;
                                }
                                else if (valtext.Contains("m"))
                                {
                                    diftext = "m";
                                    difbmp = GHApp._statusDifficultyMasterBitmap;
                                }
                                else if (valtext.Contains("g"))
                                {
                                    diftext = "g";
                                    difbmp = GHApp._statusDifficultyGrandMasterBitmap;
                                }

                                if (diftext != "")
                                {
                                    target_width = target_scale * difbmp.Width;
                                    target_height = target_scale * difbmp.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    canvas.DrawImage(difbmp, statusDest);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                    textPaint.MeasureText(diftext, ref bounds);
                                    //textPaint.TextAlign = SKTextAlign.Center;
                                    textPaint.Color = SKColors.Black;
                                    textPaint.TextSize = diffontsize;
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                    //canvas.DrawText(diftext, curx + target_width / 2, cury + (rowheight - (textPaint.FontSpacing)) / 2 - textPaint.FontMetrics.Ascent, textPaint);
                                    textPaint.DrawTextOnCanvas(canvas, diftext, curx + target_width / 2, cury + (rowheight - (textPaint.FontSpacing)) / 2 - textPaint.FontMetrics.Ascent, SKTextAlign.Center);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Text);
#endif
                                    curx += target_width;
                                    curx += stdspacing;
                                    //textPaint.TextAlign = SKTextAlign.Left;
                                    textPaint.Color = SKColors.White;
                                    textPaint.TextSize = basefontsize;
                                }


                                /* STATS on Desktop */
                                if (DesktopStatusBar)
                                {
                                    curx += stdspacing * 2;
                                    //target_width = target_scale * GHApp._statusSeparatorBitmap.Width;
                                    //target_height = target_scale * GHApp._statusSeparatorBitmap.Height;
                                    //statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                    //canvas.DrawImage(GHApp._statusSeparatorBitmap, statusDest);
                                    //curx += target_width;
                                    //curx += stdspacing;

                                    for (int i = 0; i < 6; i++)
                                    {
                                        valtext = "";
                                        if (_localStatusFields[(int)NhStatusFields.BL_STR + i].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_STR + i].Text != null)
                                        {
                                            valtext = _localStatusFields[(int)NhStatusFields.BL_STR + i].Text;
                                            valcolor = _localStatusFields[(int)NhStatusFields.BL_STR + i].Color;
                                        }
                                        if (valtext != "")
                                        {
                                            SKImage statIcon = GetStatIcon(i);
                                            target_width = target_scale * statIcon.Width;
                                            target_height = target_scale * statIcon.Height;
                                            statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                            canvas.DrawImage(statIcon, statusDest);
                                            curx += target_width;
                                            curx += innerspacing;
                                            float print_width = textPaint.MeasureText(valtext);
                                            SKColor oldColor = textPaint.Color;
                                            textPaint.Color = UIUtils.NHColor2SKColorCore(valcolor, 0, false, false);
                                            textPaint.DrawTextOnCanvas(canvas, valtext, curx, cury - textPaint.FontMetrics.Ascent);
                                            textPaint.Color = oldColor;
                                            curx += print_width + stdspacing;
                                        }
                                    }

                                    valtext = "";
                                    if (_localStatusFields[(int)NhStatusFields.BL_ALIGN].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_ALIGN].Text != null)
                                    {
                                        valtext = _localStatusFields[(int)NhStatusFields.BL_ALIGN].Text;
                                    }
                                    if (valtext != "")
                                    {
                                        curx += stdspacing / 2;

                                        SKImage statIcon = GetAlignmentIcon(valtext);
                                        target_width = target_scale * statIcon.Width;
                                        target_height = target_scale * statIcon.Height;
                                        statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                        canvas.DrawImage(statIcon, statusDest,
#if GNH_MAUI
                                            new SKSamplingOptions(SKFilterMode.Linear),
#endif
                                            highQualityPaint);
                                        curx += target_width;
                                        if (valtext.Length >= 3)
                                        {
                                            curx += innerspacing;
                                            GHSubstring print_text = new GHSubstring(valtext, 0, 3);
                                            float print_width = textPaint.MeasureText(print_text.Value);
                                            textPaint.DrawTextOnCanvas(canvas, print_text.Value, curx, cury - textPaint.FontMetrics.Ascent);
                                            curx += print_width;
                                        }

                                        curx += stdspacing / 2;
                                        curx += stdspacing;
                                    }
                                    curx += stdspacing * 2;
                                }


                                /* Normal non-desktop stats */
                                valtext = "";
                                if (_localStatusFields[(int)NhStatusFields.BL_XP].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_XP].Text != null)
                                {
                                    valtext = _localStatusFields[(int)NhStatusFields.BL_XP].Text;
                                }
                                if (valtext != "")
                                {
                                    target_width = target_scale * GHApp._statusXPLevelBitmap.Width;
                                    target_height = target_scale * GHApp._statusXPLevelBitmap.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    canvas.DrawImage(GHApp._statusXPLevelBitmap, statusDest,
#if GNH_MAUI
                                        new SKSamplingOptions(SKFilterMode.Linear),
#endif
                                        highQualityPaint);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                    curx += target_width;
                                    curx += innerspacing;
                                    float print_width = textPaint.MeasureText(valtext);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                    //canvas.DrawText(valtext, curx, cury - textPaint.FontMetrics.Ascent, textPaint);
                                    textPaint.DrawTextOnCanvas(canvas, valtext, curx, cury - textPaint.FontMetrics.Ascent);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Text);
#endif
                                    curx += print_width + stdspacing;
                                }

                                valtext = "";
                                if (_localStatusFields[(int)NhStatusFields.BL_HD].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_HD].Text != null)
                                {
                                    valtext = _localStatusFields[(int)NhStatusFields.BL_HD].Text;
                                }
                                if (valtext != "")
                                {
                                    target_width = target_scale * GHApp._statusHDBitmap.Width;
                                    target_height = target_scale * GHApp._statusHDBitmap.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    canvas.DrawImage(GHApp._statusHDBitmap, statusDest,
#if GNH_MAUI
                                        new SKSamplingOptions(SKFilterMode.Linear),
#endif
                                        highQualityPaint);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                    curx += target_width;
                                    curx += innerspacing;
                                    float print_width = textPaint.MeasureText(valtext);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                    //canvas.DrawText(valtext, curx, cury - textPaint.FontMetrics.Ascent, textPaint);
                                    textPaint.DrawTextOnCanvas(canvas, valtext, curx, cury - textPaint.FontMetrics.Ascent);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Text);
#endif
                                    curx += print_width + stdspacing;
                                }

                                valtext = "";
                                if (_localStatusFields[(int)NhStatusFields.BL_AC].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_AC].Text != null)
                                {
                                    valtext = _localStatusFields[(int)NhStatusFields.BL_AC].Text;
                                }
                                if (valtext != "")
                                {
                                    target_width = target_scale * GHApp._statusACBitmap.Width;
                                    target_height = target_scale * GHApp._statusACBitmap.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    canvas.DrawImage(GHApp._statusACBitmap, statusDest);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                    //textPaint.TextAlign = SKTextAlign.Center;
                                    textPaint.Color = SKColors.Black;
                                    textPaint.TextSize = shieldfontsize;
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                    //canvas.DrawText(valtext, curx + target_width / 2, cury + (rowheight - textPaint.FontSpacing) / 2 - textPaint.FontMetrics.Ascent, textPaint);
                                    textPaint.DrawTextOnCanvas(canvas, valtext, curx + target_width / 2, cury + (rowheight - textPaint.FontSpacing) / 2 - textPaint.FontMetrics.Ascent, SKTextAlign.Center);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Text);
#endif
                                    curx += target_width;
                                    curx += stdspacing;
                                    //textPaint.TextAlign = SKTextAlign.Left;
                                    textPaint.Color = SKColors.White;
                                    textPaint.TextSize = basefontsize;
                                }

                                valtext = "";
                                string valtext2 = "";
                                if (_localStatusFields[(int)NhStatusFields.BL_MC_LVL].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_MC_LVL].Text != null)
                                {
                                    valtext = _localStatusFields[(int)NhStatusFields.BL_MC_LVL].Text;
                                }
                                if (_localStatusFields[(int)NhStatusFields.BL_MC_PCT].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_MC_PCT].Text != null)
                                {
                                    valtext2 = _localStatusFields[(int)NhStatusFields.BL_MC_PCT].Text;
                                }
                                if (valtext != "")
                                {
                                    target_width = target_scale * GHApp._statusMCBitmap.Width;
                                    target_height = target_scale * GHApp._statusMCBitmap.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    canvas.DrawImage(GHApp._statusMCBitmap, statusDest);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                    //textPaint.TextAlign = SKTextAlign.Center;
                                    textPaint.Color = SKColors.Black;
                                    textPaint.TextSize = shieldfontsize;
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                    //canvas.DrawText(valtext, curx + target_width / 2, cury + (rowheight - textPaint.FontSpacing) / 2 - textPaint.FontMetrics.Ascent, textPaint);
                                    textPaint.DrawTextOnCanvas(canvas, valtext, curx + target_width / 2, cury + (rowheight - textPaint.FontSpacing) / 2 - textPaint.FontMetrics.Ascent, SKTextAlign.Center);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Text);
#endif
                                    curx += target_width;
                                    curx += innerspacing;
                                    //textPaint.TextAlign = SKTextAlign.Left;
                                    textPaint.Color = SKColors.White;
                                    textPaint.TextSize = basefontsize;
                                    string printtext = valtext2 + "%";
                                    float print_width = textPaint.MeasureText(printtext);
                                    //canvas.DrawText(printtext, curx, cury - textPaint.FontMetrics.Ascent, textPaint);
                                    textPaint.DrawTextOnCanvas(canvas, printtext, curx, cury - textPaint.FontMetrics.Ascent);
                                    curx += print_width + stdspacing;
                                }

                                valtext = "";
                                if (_localStatusFields[(int)NhStatusFields.BL_MOVE].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_MOVE].Text != null)
                                {
                                    valtext = _localStatusFields[(int)NhStatusFields.BL_MOVE].Text;
                                }
                                if (valtext != "")
                                {
                                    target_width = target_scale * GHApp._statusMoveBitmap.Width;
                                    target_height = target_scale * GHApp._statusMoveBitmap.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    canvas.DrawImage(GHApp._statusMoveBitmap, statusDest,
#if GNH_MAUI
                                        new SKSamplingOptions(SKFilterMode.Linear),
#endif
                                        highQualityPaint);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                    curx += target_width;
                                    curx += innerspacing;
                                    float print_width = textPaint.MeasureText(valtext);
                                    //canvas.DrawText(valtext, curx, cury - textPaint.FontMetrics.Ascent, textPaint);
                                    textPaint.DrawTextOnCanvas(canvas, valtext, curx, cury - textPaint.FontMetrics.Ascent);
                                    curx += print_width + stdspacing;
                                }

                                valtext = "";
                                valtext2 = "";
                                string valtext3 = "";
                                bool isenabled1 = false;
                                bool isenabled2 = false;
                                bool isenabled3 = false;
                                if (_localStatusFields[(int)NhStatusFields.BL_UWEP].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_UWEP].Text != null)
                                {
                                    valtext = _localStatusFields[(int)NhStatusFields.BL_UWEP].Text;
                                    isenabled1 = _localStatusFields[(int)NhStatusFields.BL_UWEP].IsEnabled;
                                }
                                if (_localStatusFields[(int)NhStatusFields.BL_UWEP2].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_UWEP2].Text != null)
                                {
                                    valtext2 = _localStatusFields[(int)NhStatusFields.BL_UWEP2].Text;
                                    isenabled2 = _localStatusFields[(int)NhStatusFields.BL_UWEP2].IsEnabled;
                                }
                                if (_localStatusFields[(int)NhStatusFields.BL_UQUIVER].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_UQUIVER].Text != null)
                                {
                                    valtext3 = _localStatusFields[(int)NhStatusFields.BL_UQUIVER].Text;
                                    isenabled3 = _localStatusFields[(int)NhStatusFields.BL_UQUIVER].IsEnabled;
                                }
                                if (valtext != "" || valtext2 != "" || valtext3 != "")
                                {
                                    target_width = target_scale * GHApp._statusWeaponStyleBitmap.Width;
                                    target_height = target_scale * GHApp._statusWeaponStyleBitmap.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    canvas.DrawImage(GHApp._statusWeaponStyleBitmap, statusDest,
#if GNH_MAUI
                                        new SKSamplingOptions(SKFilterMode.Linear),
#endif
                                        highQualityPaint);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                    curx += target_width;
                                    curx += innerspacing;
                                    float print_width = 0;
                                    if (_drawWeaponStyleAsGlyphs)
                                    {
                                        SKTypeface savedtypeface = textPaint.Typeface;
                                        float savedfontsize = textPaint.TextSize;
                                        //lock (_weaponStyleObjDataItemLock)
                                        {
                                            if (isenabled1 && valtext != "")
                                            {
                                                /* Right-hand weapon */
                                                if (_localWeaponStyleObjDataItem[0] != null)
                                                {
                                                    float startpicturex = curx;
                                                    using (new SKAutoCanvasRestore(canvas, true))
                                                    {
                                                        GlyphImageSource gis = _paintGlyphImageSource;
                                                        gis.ReferenceGamePage = this;
                                                        gis.UseUpperSide = false;
                                                        gis.AutoSize = true;
                                                        gis.Glyph = Math.Abs(_localWeaponStyleObjDataItem[0].ObjData.gui_glyph);
                                                        gis.ObjData = _localWeaponStyleObjDataItem[0];
                                                        gis.DoAutoSize();
                                                        float wep_scale = gis.Height == 0 ? 1.0f : target_height / gis.Height;
                                                        float weppicturewidth = wep_scale * gis.Width;
                                                        float weppictureheight = wep_scale * gis.Height;
                                                        canvas.Translate(curx + 0, cury + (target_height - weppictureheight) / 2);
                                                        canvas.Scale(wep_scale);
#if GNH_MAP_PROFILING && DEBUG
                                                        StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                                        gis.DrawOnCanvas(canvas, usingGL, false, true, fixRects);
#if GNH_MAP_PROFILING && DEBUG
                                                        StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                                        curx += weppicturewidth;
                                                        curx += innerspacing;
                                                    }
                                                    float endpicturex = curx;
#if GNH_MAP_PROFILING && DEBUG
                                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                                    if (_localWeaponStyleObjDataItem[0].OutOfAmmo)
                                                    {
                                                        textPaint.TextSize = basefontsize;
                                                        string printtext = "X";
                                                        SKColor oldcolor = textPaint.Color;
                                                        print_width = textPaint.MeasureText(printtext);
                                                        float font_height = textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent;
                                                        float ontopx = ((endpicturex - startpicturex) - print_width) / 2 + startpicturex;
                                                        textPaint.Color = SKColors.Black;
                                                        textPaint.Style = SKPaintStyle.Stroke;
                                                        textPaint.StrokeWidth = textPaint.TextSize / 5;
                                                        //canvas.DrawText(printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2, textPaint);
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        textPaint.Color = SKColors.Red;
                                                        //canvas.DrawText(printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2, textPaint);
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2);
                                                        textPaint.Color = oldcolor;
                                                    }

                                                    if (_localWeaponStyleObjDataItem[0].WrongAmmoType)
                                                    {
                                                        textPaint.Typeface = GHApp.LatoBold;
                                                        textPaint.TextSize = basefontsize;
                                                        string printtext = "?";
                                                        SKColor oldcolor = textPaint.Color;
                                                        print_width = textPaint.MeasureText(printtext);
                                                        float font_height = textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent;
                                                        float ontopx = ((endpicturex - startpicturex) - print_width) / 2 + startpicturex;
                                                        textPaint.Color = SKColors.Black;
                                                        textPaint.Style = SKPaintStyle.Stroke;
                                                        textPaint.StrokeWidth = textPaint.TextSize / 5;
                                                        //canvas.DrawText(printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2, textPaint);
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        textPaint.Color = SKColors.Red;
                                                        //canvas.DrawText(printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2, textPaint);
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2);
                                                        textPaint.Color = oldcolor;
                                                        textPaint.Typeface = GHApp.LatoRegular;
                                                    }
                                                    if (_localWeaponStyleObjDataItem[0].NotBeingUsed || _localWeaponStyleObjDataItem[0].NotWeapon)
                                                    {
                                                        textPaint.Typeface = GHApp.LatoBold;
                                                        textPaint.TextSize = basefontsize;
                                                        string printtext = "!";
                                                        SKColor oldcolor = textPaint.Color;
                                                        print_width = textPaint.MeasureText(printtext);
                                                        float ontopx = ((endpicturex - startpicturex) - print_width) / 2 + startpicturex;
                                                        float font_height = textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent;
                                                        textPaint.Color = SKColors.Black;
                                                        textPaint.Style = SKPaintStyle.Stroke;
                                                        textPaint.StrokeWidth = textPaint.TextSize / 5;
                                                        //canvas.DrawText(printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2, textPaint);
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        textPaint.Color = SKColors.Orange;
                                                        //canvas.DrawText(printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2, textPaint);
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2);
                                                        textPaint.Color = oldcolor;
                                                        textPaint.Typeface = GHApp.LatoRegular;
                                                    }
#if GNH_MAP_PROFILING && DEBUG
                                                    StopProfiling(GHProfilingStyle.Text);
#endif
                                                }
                                                else
                                                {
                                                    SKRect emptyHandedSource = new SKRect(0, 0, GHApp._statusEmptyHandedBitmap.Width, GHApp._statusEmptyHandedBitmap.Height);
                                                    float empty_handed_scale = rowheight / GHApp._statusEmptyHandedBitmap.Height;
                                                    if (valtext2 != "")
                                                    {
                                                        emptyHandedSource = new SKRect(0, 0, GHApp._statusEmptyHandedBitmap.Width / 2, GHApp._statusEmptyHandedBitmap.Height);
                                                        target_width = empty_handed_scale * GHApp._statusEmptyHandedBitmap.Width / 2;
                                                        target_height = empty_handed_scale * GHApp._statusEmptyHandedBitmap.Height;
                                                    }
                                                    else
                                                    {
                                                        target_width = empty_handed_scale * GHApp._statusEmptyHandedBitmap.Width;
                                                        target_height = empty_handed_scale * GHApp._statusEmptyHandedBitmap.Height;
                                                    }
                                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                                    canvas.DrawImage(GHApp._statusEmptyHandedBitmap, emptyHandedSource, statusDest);
#if GNH_MAP_PROFILING && DEBUG
                                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                                    curx += target_width;
                                                    curx += innerspacing;
                                                }
                                            }
                                            if (isenabled2 && valtext2 != "")
                                            {
                                                /* Left-hand weapon */
                                                if (_localWeaponStyleObjDataItem[1] != null)
                                                {
                                                    textPaint.TextSize = shieldfontsize;
                                                    string printtext = "+";
                                                    print_width = textPaint.MeasureText(printtext);
                                                    //canvas.DrawText(printtext, curx, cury - textPaint.FontMetrics.Ascent, textPaint);
                                                    textPaint.DrawTextOnCanvas(canvas, printtext, curx, cury - textPaint.FontMetrics.Ascent);
                                                    curx += print_width;

                                                    float startpicturex = curx;
                                                    using (new SKAutoCanvasRestore(canvas, true))
                                                    {
                                                        GlyphImageSource gis = _paintGlyphImageSource;
                                                        gis.ReferenceGamePage = this;
                                                        gis.UseUpperSide = false;
                                                        gis.AutoSize = true;
                                                        gis.Glyph = Math.Abs(_localWeaponStyleObjDataItem[1].ObjData.gui_glyph);
                                                        gis.ObjData = _localWeaponStyleObjDataItem[1];
                                                        gis.DoAutoSize();
                                                        float wep_scale = gis.Height == 0 ? 1.0f : target_height / gis.Height;
                                                        float weppicturewidth = wep_scale * gis.Width;
                                                        float weppictureheight = wep_scale * gis.Height;
                                                        canvas.Translate(curx + 0, cury + (target_height - weppictureheight) / 2);
                                                        canvas.Scale(wep_scale);
#if GNH_MAP_PROFILING && DEBUG
                                                        StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                                        gis.DrawOnCanvas(canvas, usingGL, false, true, fixRects);
#if GNH_MAP_PROFILING && DEBUG
                                                        StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                                        curx += weppicturewidth;
                                                        curx += innerspacing;
                                                    }
                                                    float endpicturex = curx;
#if GNH_MAP_PROFILING && DEBUG
                                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                                    if (_localWeaponStyleObjDataItem[1].OutOfAmmo)
                                                    {
                                                        textPaint.TextSize = basefontsize;
                                                        printtext = "X";
                                                        SKColor oldcolor = textPaint.Color;
                                                        print_width = textPaint.MeasureText(printtext);
                                                        float ontopx = ((endpicturex - startpicturex) - print_width) / 2 + startpicturex;
                                                        float font_height = textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent;
                                                        textPaint.Color = SKColors.Black;
                                                        textPaint.Style = SKPaintStyle.Stroke;
                                                        textPaint.StrokeWidth = textPaint.TextSize / 5;
                                                        //canvas.DrawText(printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2, textPaint);
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        textPaint.Color = SKColors.Red;
                                                        //canvas.DrawText(printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2, textPaint);
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2);
                                                        textPaint.Color = oldcolor;

                                                    }
                                                    if (_localWeaponStyleObjDataItem[1].WrongAmmoType)
                                                    {
                                                        textPaint.Typeface = GHApp.LatoBold;
                                                        textPaint.TextSize = basefontsize;
                                                        printtext = "?";
                                                        SKColor oldcolor = textPaint.Color;
                                                        print_width = textPaint.MeasureText(printtext);
                                                        float ontopx = ((endpicturex - startpicturex) - print_width) / 2 + startpicturex;
                                                        float font_height = textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent;
                                                        textPaint.Color = SKColors.Black;
                                                        textPaint.Style = SKPaintStyle.Stroke;
                                                        textPaint.StrokeWidth = textPaint.TextSize / 5;
                                                        //canvas.DrawText(printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2, textPaint);
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        textPaint.Color = SKColors.Red;
                                                        //canvas.DrawText(printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2, textPaint);
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2);
                                                        textPaint.Color = oldcolor;
                                                        textPaint.Typeface = GHApp.LatoRegular;
                                                    }
                                                    if (_localWeaponStyleObjDataItem[1].NotBeingUsed || _localWeaponStyleObjDataItem[1].NotWeapon)
                                                    {
                                                        textPaint.Typeface = GHApp.LatoBold;
                                                        textPaint.TextSize = basefontsize;
                                                        printtext = "!";
                                                        SKColor oldcolor = textPaint.Color;
                                                        textPaint.Color = SKColors.Orange;
                                                        print_width = textPaint.MeasureText(printtext);
                                                        float ontopx = ((endpicturex - startpicturex) - print_width) / 2 + startpicturex;
                                                        float font_height = textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent;
                                                        textPaint.Color = SKColors.Black;
                                                        textPaint.Style = SKPaintStyle.Stroke;
                                                        textPaint.StrokeWidth = textPaint.TextSize / 5;
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2);
                                                        textPaint.Style = SKPaintStyle.Fill;
                                                        textPaint.Color = SKColors.Orange;
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, ontopx, cury - textPaint.FontMetrics.Ascent + (target_height - font_height) / 2);
                                                        textPaint.Color = oldcolor;
                                                        textPaint.Typeface = GHApp.LatoRegular;
                                                    }
#if GNH_MAP_PROFILING && DEBUG
                                                    StopProfiling(GHProfilingStyle.Text);
#endif
                                                }
                                                else
                                                {
                                                    SKRect emptyHandedSource = new SKRect(0, 0, GHApp._statusEmptyHandedBitmap.Width, GHApp._statusEmptyHandedBitmap.Height);
                                                    float empty_handed_scale = rowheight / GHApp._statusEmptyHandedBitmap.Height;
                                                    if (valtext != "")
                                                    {
                                                        string printtext = "+";
                                                        print_width = textPaint.MeasureText(printtext);
                                                        textPaint.DrawTextOnCanvas(canvas, printtext, curx, cury - textPaint.FontMetrics.Ascent);
                                                        curx += print_width;

                                                        emptyHandedSource = new SKRect(GHApp._statusEmptyHandedBitmap.Width / 2, 0, GHApp._statusEmptyHandedBitmap.Width, GHApp._statusEmptyHandedBitmap.Height);
                                                        target_width = empty_handed_scale * GHApp._statusEmptyHandedBitmap.Width / 2;
                                                        target_height = empty_handed_scale * GHApp._statusEmptyHandedBitmap.Height;
                                                    }
                                                    else
                                                    {
                                                        target_width = empty_handed_scale * GHApp._statusEmptyHandedBitmap.Width;
                                                        target_height = empty_handed_scale * GHApp._statusEmptyHandedBitmap.Height;
                                                    }
                                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                                    canvas.DrawImage(GHApp._statusEmptyHandedBitmap, emptyHandedSource, statusDest);
#if GNH_MAP_PROFILING && DEBUG
                                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                                    curx += target_width;
                                                    curx += innerspacing;
                                                }
                                            }

                                            if (isenabled3 && valtext3 != "")
                                            {
                                                /* Throwing weapons in quiver (which are not ammo by definition) */
                                                if (_localWeaponStyleObjDataItem[2] != null && _localWeaponStyleObjDataItem[2].IsThrowingWeapon && !_localWeaponStyleObjDataItem[2].IsAmmo)
                                                {
                                                    curx += innerspacing; /* More space to other weapon styles */
                                                    target_width = target_scale * GHApp._statusQuiveredWeaponStyleBitmap.Width;
                                                    target_height = target_scale * GHApp._statusQuiveredWeaponStyleBitmap.Height;
                                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                                    canvas.DrawImage(GHApp._statusQuiveredWeaponStyleBitmap, statusDest,
#if GNH_MAUI
                                                        new SKSamplingOptions(SKFilterMode.Linear),
#endif
                                                        highQualityPaint);
#if GNH_MAP_PROFILING && DEBUG
                                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                                    curx += target_width;
                                                    curx += innerspacing;

                                                    using (new SKAutoCanvasRestore(canvas, true))
                                                    {
                                                        GlyphImageSource gis = _paintGlyphImageSource;
                                                        gis.ReferenceGamePage = this;
                                                        gis.UseUpperSide = false;
                                                        gis.AutoSize = true;
                                                        gis.Glyph = Math.Abs(_localWeaponStyleObjDataItem[2].ObjData.gui_glyph);
                                                        gis.ObjData = _localWeaponStyleObjDataItem[2];
                                                        gis.DoAutoSize();
                                                        float wep_scale = gis.Height == 0 ? 1.0f : target_height / gis.Height;
                                                        float weppicturewidth = wep_scale * gis.Width;
                                                        float weppictureheight = wep_scale * gis.Height;
                                                        canvas.Translate(curx + 0, cury + (target_height - weppictureheight) / 2);
                                                        canvas.Scale(wep_scale);
                                                        gis.DrawOnCanvas(canvas, usingGL, false, true, fixRects);
                                                        curx += weppicturewidth;
                                                        curx += innerspacing;
                                                    }
                                                }
                                            }
                                        }
                                        textPaint.TextSize = savedfontsize;
                                        textPaint.Typeface = savedtypeface;
                                    }
                                    else
                                    {
#if GNH_MAP_PROFILING && DEBUG
                                        StartProfiling(GHProfilingStyle.Text);
#endif
                                        if (valtext != "")
                                        {
                                            print_width = textPaint.MeasureText(valtext);
                                            textPaint.DrawTextOnCanvas(canvas, valtext, curx, cury - textPaint.FontMetrics.Ascent);
                                            curx += print_width;
                                        }
                                        if (valtext2 != "")
                                        {
                                            string printtext = "/" + valtext2;
                                            print_width = textPaint.MeasureText(printtext);
                                            textPaint.DrawTextOnCanvas(canvas, printtext, curx, cury - textPaint.FontMetrics.Ascent);
                                            curx += print_width;
                                        }
#if GNH_MAP_PROFILING && DEBUG
                                        StopProfiling(GHProfilingStyle.Text);
#endif
                                    }
                                    curx += stdspacing;
                                }

                                /* Quick spell and wand */
                                lockTaken = false;
                                //lock (_quickLock)
                                try
                                {
                                    Monitor.TryEnter(curGame._quickLock, ref lockTaken);
                                    if (lockTaken)
                                    {
                                        _localQuickWandExceptinality = curGame._quickWandExceptionality;
                                        _localQuickWandGlyph = curGame._quickWandGlyph;
                                        _localQuickWandName = curGame._quickWandName;
                                        _localQuickSpellOtyp = curGame._quickSpellOtyp;
                                        _localQuickSpellGlyph = curGame._quickSpellGlyph;
                                        _localQuickSpellName = curGame._quickSpellName;
                                    }
                                }
                                finally
                                {
                                    if (lockTaken)
                                        Monitor.Exit(curGame._quickLock);
                                }
                                lockTaken = false;

                                if (_localQuickWandGlyph != GHApp.NoGlyph)
                                {
                                    target_width = target_scale * GHApp._statusQuickWandBitmap.Width;
                                    target_height = target_scale * GHApp._statusQuickWandBitmap.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                    canvas.DrawImage(GHApp._statusQuickWandBitmap, statusDest);
                                    curx += target_width;
                                    curx += innerspacing;

                                    using (new SKAutoCanvasRestore(canvas, true))
                                    {
                                        GlyphImageSource gis = _paintGlyphImageSource;
                                        gis.ReferenceGamePage = this;
                                        gis.UseUpperSide = false;
                                        gis.AutoSize = true;
                                        gis.Glyph = Math.Abs(_localQuickWandGlyph);
                                        gis.ObjData = new ObjectDataItem(new Obj() { exceptionality = (byte)_localQuickWandExceptinality }, new ObjClassData(), false);
                                        gis.DoAutoSize();
                                        float wep_scale = gis.Height == 0 ? 1.0f : target_height / gis.Height;
                                        float weppicturewidth = wep_scale * gis.Width;
                                        float weppictureheight = wep_scale * gis.Height;
                                        canvas.Translate(curx + 0, cury + (target_height - weppictureheight) / 2);
                                        canvas.Scale(wep_scale);
                                        gis.DrawOnCanvas(canvas, usingGL, false, true, fixRects);
                                        curx += weppicturewidth;
                                    }
                                    curx += stdspacing;
                                }
                                if (_localQuickSpellGlyph != GHApp.NoGlyph)
                                {
                                    target_width = target_scale * GHApp._statusQuickSpellBitmap.Width;
                                    target_height = target_scale * GHApp._statusQuickSpellBitmap.Height;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                    canvas.DrawImage(GHApp._statusQuickSpellBitmap, statusDest);
                                    curx += target_width;
                                    curx += innerspacing;
                                    using (new SKAutoCanvasRestore(canvas, true))
                                    {
                                        GlyphImageSource gis = _paintGlyphImageSource;
                                        gis.ReferenceGamePage = this;
                                        gis.UseUpperSide = true;
                                        gis.AutoSize = true;
                                        gis.ObjData = null;
                                        gis.Glyph = Math.Abs(_localQuickSpellGlyph);
                                        gis.DoAutoSize();
                                        float wep_scale = gis.Height == 0 ? 1.0f : target_height / gis.Height;
                                        float weppicturewidth = wep_scale * gis.Width;
                                        float weppictureheight = wep_scale * gis.Height;
                                        canvas.Translate(curx + 0, cury + (target_height - weppictureheight) / 2);
                                        canvas.Scale(wep_scale);
                                        gis.DrawOnCanvas(canvas, usingGL, false, true, fixRects);
                                        curx += weppicturewidth;
                                    }
                                    curx += stdspacing;
                                }


                                /* Right aligned */
                                bool turnsprinted = false;
                                float finalleftcurx = curx;
                                curx = canvaswidth - hmargin;
                                float turnsleft = curx;

                                /* Turns */
                                valtext = "";
                                if (_localStatusFields[(int)NhStatusFields.BL_TIME].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_TIME].Text != null)
                                {
                                    valtext = _localStatusFields[(int)NhStatusFields.BL_TIME].Text;
                                }
                                if (valtext != "")
                                {
                                    target_width = target_scale * GHApp._statusTurnsBitmap.Width;
                                    target_height = target_scale * GHApp._statusTurnsBitmap.Height;
                                    float print_width = textPaint.MeasureText(valtext);
                                    float newcurx = canvaswidth - hmargin - print_width - innerspacing - target_width;
                                    if (newcurx >= finalleftcurx) /* Avoid printing status bar elements over each other */
                                    {
                                        turnsprinted = true;
                                        curx = newcurx;
                                        turnsleft = curx;
                                        statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                        StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                        canvas.DrawImage(GHApp._statusTurnsBitmap, statusDest);
#if GNH_MAP_PROFILING && DEBUG
                                        StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                        curx += target_width;
                                        curx += innerspacing;
#if GNH_MAP_PROFILING && DEBUG
                                        StartProfiling(GHProfilingStyle.Text);
#endif
                                        textPaint.DrawTextOnCanvas(canvas, valtext, curx, cury - textPaint.FontMetrics.Ascent);
#if GNH_MAP_PROFILING && DEBUG
                                        StopProfiling(GHProfilingStyle.Text);
#endif
                                        curx += print_width;
                                    }
                                }

                                /* Gold */
                                bool goldprinted = false;
                                float goldleft = turnsleft;
                                if (!RightAligned2ndRow)
                                {
                                    valtext = "";
                                    if (_localStatusFields[(int)NhStatusFields.BL_GOLD].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_GOLD].Text != null)
                                    {
                                        valtext = _localStatusFields[(int)NhStatusFields.BL_GOLD].Text;
                                    }
                                    if (valtext != "")
                                    {
                                        GHSubstring printtext = valtext.Length > 11 && valtext[0] == '\\' ? new GHSubstring(valtext, 11) : new GHSubstring(valtext);
                                        target_width = target_scale * GHApp._statusGoldBitmap.Width;
                                        target_height = target_scale * GHApp._statusGoldBitmap.Height;
                                        float print_width = textPaint.MeasureText(printtext.Value);
                                        float newcurx = turnsleft - (turnsprinted ? stdspacing : 0) - print_width - innerspacing - target_width;
                                        if (newcurx >= finalleftcurx) /* Avoid printing status bar elements over each other */
                                        {
                                            goldprinted = true;
                                            curx = newcurx;
                                            goldleft = curx;
                                            statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                            canvas.DrawImage(GHApp._statusGoldBitmap, statusDest);
                                            curx += target_width;
                                            curx += innerspacing;
                                            textPaint.DrawTextOnCanvas(canvas, printtext.Value, curx, cury - textPaint.FontMetrics.Ascent);
                                            curx += print_width;
                                        }
                                    }

                                    float scoreleft = goldleft;
                                    bool scoreprinted = false;
                                    if (ShowScore)
                                    {
                                        /* Score */
                                        valtext = "";
                                        if (_localStatusFields[(int)NhStatusFields.BL_SCORE].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_SCORE].Text != null)
                                        {
                                            valtext = _localStatusFields[(int)NhStatusFields.BL_SCORE].Text;
                                        }
                                        if (valtext != "")
                                        {
                                            target_width = target_scale * GHApp._statusScoreBitmap.Width;
                                            target_height = target_scale * GHApp._statusScoreBitmap.Height;
                                            float print_width = textPaint.MeasureText(valtext);
                                            float newcurx = goldleft - (goldprinted || turnsprinted ? stdspacing : 0) - print_width - innerspacing - target_width;
                                            if (newcurx >= finalleftcurx) /* Avoid printing status bar elements over each other */
                                            {
                                                scoreprinted = true;
                                                curx = newcurx;
                                                scoreleft = curx;
                                                statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                                canvas.DrawImage(GHApp._statusScoreBitmap, statusDest);
                                                curx += target_width;
                                                curx += innerspacing;
                                                textPaint.DrawTextOnCanvas(canvas, valtext, curx, cury - textPaint.FontMetrics.Ascent);
                                                curx += print_width;
                                            }
                                        }
                                    }
                                    if (ShowXP)
                                    {
                                        /* XP Points */
                                        valtext = "";
                                        if (_localStatusFields[(int)NhStatusFields.BL_EXP].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_EXP].Text != null)
                                        {
                                            valtext = _localStatusFields[(int)NhStatusFields.BL_EXP].Text;
                                        }
                                        if (valtext != "")
                                        {
                                            target_width = target_scale * GHApp._statusXPPointsBitmap.Width;
                                            target_height = target_scale * GHApp._statusXPPointsBitmap.Height;
                                            float print_width = textPaint.MeasureText(valtext);
                                            float newcurx = scoreleft - (goldprinted || turnsprinted || scoreprinted ? stdspacing : 0) - print_width - innerspacing - target_width;
                                            if (newcurx >= finalleftcurx) /* Avoid printing status bar elements over each other */
                                            {
                                                curx = newcurx;
                                                statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                                canvas.DrawImage(GHApp._statusXPPointsBitmap, statusDest,
#if GNH_MAUI
                                                    new SKSamplingOptions(SKFilterMode.Linear),
#endif
                                                    highQualityPaint);
                                                curx += target_width;
                                                curx += innerspacing;
                                                textPaint.DrawTextOnCanvas(canvas, valtext, curx, cury - textPaint.FontMetrics.Ascent);
                                                curx += print_width;
                                            }
                                        }
                                    }
                                }


                                /* Second row */
                                curx = hmargin;
                                cury += rowheight + rowmargin;

                                /* Title */
                                valtext = "";
                                if (_localStatusFields[(int)NhStatusFields.BL_TITLE].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_TITLE].Text != null)
                                {
                                    valtext = _localStatusFields[(int)NhStatusFields.BL_TITLE].Text;
                                }
                                valtext = valtext.Trim();
                                if (valtext != "")
                                {
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                    textPaint.DrawTextOnCanvas(canvas, valtext, curx, cury - textPaint.FontMetrics.Ascent);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Text);
#endif
                                    float textprint_length = textPaint.MeasureText(valtext);
                                    curx += textprint_length;
                                    curx += stdspacing;
                                }

                                {
                                    /* Condition, status and buff marks */
                                    float marksize = rowheight * 0.80f;
                                    float markpadding = marksize / 8;
                                    if (_local_u_status_bits != 0)
                                    {
                                        int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                                        foreach (int status_mark in _statusmarkorder)
                                        {
                                            ulong statusbit = 1UL << status_mark;
                                            if ((_local_u_status_bits & statusbit) != 0)
                                            {
                                                int mglyph = (int)game_ui_tile_types.STATUS_MARKS + status_mark / GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS + GHApp.UITileOff;
                                                int mtile = GHApp.Glyph2Tile[mglyph];
                                                int sheet_idx = GHApp.TileSheetIdx(mtile);
                                                int tile_x = GHApp.TileSheetX(mtile);
                                                int tile_y = GHApp.TileSheetY(mtile);
                                                int within_tile_x = (status_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) % tiles_per_row;
                                                int within_tile_y = (status_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) / tiles_per_row;
                                                int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                                                int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                                                SKRect source_rt = new SKRect();
                                                source_rt.Left = c_x;
                                                source_rt.Right = c_x + GHConstants.StatusMarkWidth;
                                                source_rt.Top = c_y;
                                                source_rt.Bottom = c_y + GHConstants.StatusMarkHeight;

                                                SKRect target_rt = new SKRect();
                                                target_rt.Left = curx;
                                                target_rt.Right = target_rt.Left + marksize;
                                                target_rt.Top = cury + (rowheight - marksize) / 2;
                                                target_rt.Bottom = target_rt.Top + marksize;
#if GNH_MAP_PROFILING && DEBUG
                                                StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                                canvas.DrawImage(TileMap[sheet_idx], source_rt, target_rt);
#if GNH_MAP_PROFILING && DEBUG
                                                StopProfiling(GHProfilingStyle.Bitmap);
#endif

                                                curx += marksize;
                                                curx += markpadding;
                                            }
                                        }
                                    }

                                    if (_local_u_condition_bits != 0)
                                    {
                                        int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                                        for (int condition_mark = 0; condition_mark < (int)bl_conditions.NUM_BL_CONDITIONS; condition_mark++)
                                        {
                                            ulong conditionbit = 1UL << condition_mark;
                                            if ((_local_u_condition_bits & conditionbit) != 0)
                                            {
                                                int mglyph = (int)game_ui_tile_types.CONDITION_MARKS + condition_mark / GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS + GHApp.UITileOff;
                                                int mtile = GHApp.Glyph2Tile[mglyph];
                                                int sheet_idx = GHApp.TileSheetIdx(mtile);
                                                int tile_x = GHApp.TileSheetX(mtile);
                                                int tile_y = GHApp.TileSheetY(mtile);
                                                int within_tile_x = (condition_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) % tiles_per_row;
                                                int within_tile_y = (condition_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) / tiles_per_row;
                                                int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                                                int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                                                SKRect source_rt = new SKRect();
                                                source_rt.Left = c_x;
                                                source_rt.Right = c_x + GHConstants.StatusMarkWidth;
                                                source_rt.Top = c_y;
                                                source_rt.Bottom = c_y + GHConstants.StatusMarkHeight;

                                                SKRect target_rt = new SKRect();
                                                target_rt.Left = curx;
                                                target_rt.Right = target_rt.Left + marksize;
                                                target_rt.Top = cury + (rowheight - marksize) / 2;
                                                target_rt.Bottom = target_rt.Top + marksize;
#if GNH_MAP_PROFILING && DEBUG
                                                StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                                canvas.DrawImage(TileMap[sheet_idx], source_rt, target_rt);
#if GNH_MAP_PROFILING && DEBUG
                                                StopProfiling(GHProfilingStyle.Bitmap);
#endif

                                                curx += marksize;
                                                curx += markpadding;
                                            }
                                        }
                                    }

                                    ulong buff_bits;
                                    for (int buff_ulong = 0; buff_ulong < GHConstants.NUM_BUFF_BIT_ULONGS; buff_ulong++)
                                    {
                                        buff_bits = _local_u_buff_bits[buff_ulong];
                                        int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                                        if (buff_bits != 0)
                                        {
                                            for (int buff_idx = 0; buff_idx < 32; buff_idx++)
                                            {
                                                ulong buffbit = 1UL << buff_idx;
                                                if ((buff_bits & buffbit) != 0)
                                                {
                                                    int propidx = buff_ulong * 32 + buff_idx;
                                                    if (propidx > GHConstants.LAST_PROP)
                                                        break;
                                                    int mglyph = (propidx - 1) / GHConstants.BUFFS_PER_TILE + GHApp.BuffTileOff;
                                                    int mtile = GHApp.Glyph2Tile[mglyph];
                                                    int sheet_idx = GHApp.TileSheetIdx(mtile);
                                                    int tile_x = GHApp.TileSheetX(mtile);
                                                    int tile_y = GHApp.TileSheetY(mtile);

                                                    int buff_mark = (propidx - 1) % GHConstants.BUFFS_PER_TILE;
                                                    int within_tile_x = buff_mark % tiles_per_row;
                                                    int within_tile_y = buff_mark / tiles_per_row;
                                                    int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                                                    int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                                                    SKRect source_rt = new SKRect();
                                                    source_rt.Left = c_x;
                                                    source_rt.Right = c_x + GHConstants.StatusMarkWidth;
                                                    source_rt.Top = c_y;
                                                    source_rt.Bottom = c_y + GHConstants.StatusMarkHeight;

                                                    SKRect target_rt = new SKRect();
                                                    target_rt.Left = curx;
                                                    target_rt.Right = target_rt.Left + marksize;
                                                    target_rt.Top = cury + (rowheight - marksize) / 2;
                                                    target_rt.Bottom = target_rt.Top + marksize;
#if GNH_MAP_PROFILING && DEBUG
                                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                                    canvas.DrawImage(TileMap[sheet_idx], source_rt, target_rt);
#if GNH_MAP_PROFILING && DEBUG
                                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif

                                                    curx += marksize;
                                                    curx += markpadding;
                                                }
                                            }
                                        }
                                    }

                                    bool colorfound = false;
                                    for (int i = (int)NhColor.CLR_BLACK + 1; i < (int)NhColor.CLR_WHITE; i++)
                                    {
                                        if (i == (int)NhColor.NO_COLOR || i == (int)NhColor.CLR_GRAY)
                                            continue;

                                        colorfound = false;
                                        for (int j = 0; j < 6; j++)
                                        {
                                            if (_localStatusFields[(int)NhStatusFields.BL_STR + j].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_STR + j].Text != null)
                                            {
                                                if (_localStatusFields[(int)NhStatusFields.BL_STR + j].Color == i)
                                                {
                                                    colorfound = true;
                                                    break;
                                                }
                                            }
                                        }
                                        if (colorfound)
                                        {
                                            SKColor dotcolor = UIUtils.NHColor2SKColorCore(i, 0, true, false);
                                            SKPoint dotpoint = new SKPoint(curx + marksize / 4, cury + (rowheight - marksize) / 2 + marksize / 2);
                                            float dotradius = marksize / 8;
                                            textPaint.Color = dotcolor;
                                            textPaint.Style = SKPaintStyle.Fill;
                                            canvas.DrawCircle(dotpoint, dotradius, textPaint.Paint);
                                            curx += marksize / 2;
                                            curx += markpadding;
                                        }
                                    }
                                    textPaint.Color = SKColors.White;
                                }

                                float final2ndrowleftcurx = curx;


                                /* Right aligned */
                                float dungeonleft = canvaswidth - hmargin;
                                /* Dungeon level */
                                valtext = "";
                                if (_localStatusFields[(int)NhStatusFields.BL_LEVELDESC].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_LEVELDESC].Text != null)
                                {
                                    valtext = _localStatusFields[(int)NhStatusFields.BL_LEVELDESC].Text;
                                }
                                if (valtext != "")
                                {
                                    GHSubstring printtext;
                                    if (valtext.Length > 3 && (new GHSubstring(valtext, 0, 3)).IsEqualTo("DL:"))
                                    {
                                        printtext = new GHSubstring(valtext, 3);
                                    }
                                    else if (valtext.Length > 5 && (new GHSubstring(valtext, 0, 5)).IsEqualTo("Dlvl:"))
                                    {
                                        printtext = new GHSubstring(valtext, 5);
                                    }
                                    else
                                        printtext = new GHSubstring(valtext);

                                    target_width = target_scale * GHApp._statusDungeonLevelBitmap.Width;
                                    target_height = target_scale * GHApp._statusDungeonLevelBitmap.Height;
                                    float print_width = textPaint.MeasureText(printtext.Value);
                                    curx = canvaswidth - hmargin - print_width - innerspacing - target_width;
                                    dungeonleft = curx;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    canvas.DrawImage(GHApp._statusDungeonLevelBitmap, statusDest);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                    curx += target_width;
                                    curx += innerspacing;
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Text);
#endif
                                    textPaint.DrawTextOnCanvas(canvas, printtext.Value, curx, cury - textPaint.FontMetrics.Ascent);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Text);
#endif
                                    curx += print_width;
                                }

                                float desktopleft = dungeonleft;
                                if (RightAligned2ndRow)
                                {
                                    valtext = "";
                                    if (_localStatusFields[(int)NhStatusFields.BL_GOLD].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_GOLD].Text != null)
                                    {
                                        valtext = _localStatusFields[(int)NhStatusFields.BL_GOLD].Text;
                                    }
                                    if (valtext != "")
                                    {
                                        GHSubstring printtext = valtext.Length > 11 && valtext[0] == '\\' ? new GHSubstring(valtext, 11) : new GHSubstring(valtext);
                                        target_width = target_scale * GHApp._statusGoldBitmap.Width;
                                        target_height = target_scale * GHApp._statusGoldBitmap.Height;
                                        float print_width = textPaint.MeasureText(printtext.Value);
                                        float newcurx = desktopleft - stdspacing - print_width - innerspacing - target_width;
                                        if (newcurx >= final2ndrowleftcurx) /* Avoid printing status bar elements over each other */
                                        {
                                            curx = newcurx;
                                            desktopleft = curx;
                                            statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                            canvas.DrawImage(GHApp._statusGoldBitmap, statusDest);
                                            curx += target_width;
                                            curx += innerspacing;
                                            textPaint.DrawTextOnCanvas(canvas, printtext.Value, curx, cury - textPaint.FontMetrics.Ascent);
                                            curx += print_width;
                                        }
                                    }

                                    if (ShowScore)
                                    {
                                        /* Score */
                                        valtext = "";
                                        if (_localStatusFields[(int)NhStatusFields.BL_SCORE].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_SCORE].Text != null)
                                        {
                                            valtext = _localStatusFields[(int)NhStatusFields.BL_SCORE].Text;
                                        }
                                        if (valtext != "")
                                        {
                                            target_width = target_scale * GHApp._statusScoreBitmap.Width;
                                            target_height = target_scale * GHApp._statusScoreBitmap.Height;
                                            float print_width = textPaint.MeasureText(valtext);
                                            float newcurx = desktopleft - stdspacing - print_width - innerspacing - target_width;
                                            if (newcurx >= final2ndrowleftcurx) /* Avoid printing status bar elements over each other */
                                            {
                                                curx = newcurx;
                                                desktopleft = curx;
                                                statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                                canvas.DrawImage(GHApp._statusScoreBitmap, statusDest);
                                                curx += target_width;
                                                curx += innerspacing;
                                                textPaint.DrawTextOnCanvas(canvas, valtext, curx, cury - textPaint.FontMetrics.Ascent);
                                                curx += print_width;
                                            }
                                        }
                                    }
                                    if (ShowXP)
                                    {
                                        /* XP Points */
                                        valtext = "";
                                        if (_localStatusFields[(int)NhStatusFields.BL_EXP].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_EXP].Text != null)
                                        {
                                            valtext = _localStatusFields[(int)NhStatusFields.BL_EXP].Text;
                                        }
                                        if (valtext != "")
                                        {
                                            target_width = target_scale * GHApp._statusXPPointsBitmap.Width;
                                            target_height = target_scale * GHApp._statusXPPointsBitmap.Height;
                                            float print_width = textPaint.MeasureText(valtext);
                                            float newcurx = desktopleft - stdspacing - print_width - innerspacing - target_width;
                                            if (newcurx >= final2ndrowleftcurx) /* Avoid printing status bar elements over each other */
                                            {
                                                curx = newcurx;
                                                desktopleft = curx;
                                                statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                                canvas.DrawImage(GHApp._statusXPPointsBitmap, statusDest);
                                                curx += target_width;
                                                curx += innerspacing;
                                                textPaint.DrawTextOnCanvas(canvas, valtext, curx, cury - textPaint.FontMetrics.Ascent);
                                                curx += print_width;
                                            }
                                        }
                                    }
                                }

                                double chargeLevel = GHApp.BatteryChargeLevel;
                                float chargePercentage = (float)chargeLevel / 100;
                                if (ShowBattery || chargePercentage <= GHConstants.CriticalBatteryChargeLevel)
                                {
                                    target_width = target_scale * GHApp._batteryFrameBitmap.Width;
                                    target_height = target_scale * GHApp._batteryFrameBitmap.Height;
                                    curx = desktopleft - innerspacing * 5 - target_width;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                    canvas.DrawImage(GHApp._batteryFrameBitmap, statusDest);
                                    desktopleft = curx;

                                    int alen = _shineAnimation.Length;
                                    if (chargePercentage <= GHConstants.CriticalBatteryChargeLevel)
                                    {
                                        textPaint.Color = _magicShineOutlineColor.WithAlpha((byte)(_shineAnimation[generalcountervalue % alen] * 255));
                                        canvas.DrawImage(GHApp._batteryRedFrameBitmap, statusDest, textPaint.Paint);
                                    }

                                    const int topMargin = 12, bottomMargin = 5, hMargin = 6;

                                    if (chargeLevel <= 9)
                                    {
                                        string drawtext = ((int)chargeLevel).ToString();
                                        textPaint.TextSize = diffontsize;
                                        //textPaint.TextAlign = SKTextAlign.Center;
                                        float alpha = _shineAnimation[generalcountervalue % alen];
                                        textPaint.Color = new SKColor(255, (byte)(alpha * 0 + (1 - alpha) * 255), (byte)(alpha * 0 + (1 - alpha) * 255));
                                        float vsize = target_height - (topMargin + bottomMargin) * target_scale;
                                        float fsize = textPaint.FontSpacing;
                                        float vpadding = (vsize - fsize) / 2;
                                        SKPoint drawpoint = new SKPoint(curx + target_width / 2, cury + (topMargin * target_scale) + vpadding - textPaint.FontMetrics.Ascent);
                                        textPaint.DrawTextOnCanvas(canvas, drawtext, drawpoint, SKTextAlign.Center);
                                        //textPaint.TextAlign = SKTextAlign.Left;
                                        textPaint.TextSize = basefontsize;
                                        textPaint.Color = SKColors.White;
                                    }

                                    int totalHeight = GHApp._batteryFrameBitmap.Height;
                                    int fillHeight = totalHeight - topMargin - bottomMargin;
                                    float calcFillHeight = fillHeight * chargePercentage;
                                    float addedFillTop = fillHeight - calcFillHeight;

                                    float r_mult = chargePercentage <= 0.25f ? chargePercentage * 2.0f + 0.5f : chargePercentage <= 0.5f ? 1.0f : (1.0f - chargePercentage) * 2.0f;
                                    float g_mult = chargePercentage <= 0.25f ? 0 : chargePercentage <= 0.5f ? (chargePercentage - 0.25f) * 4.0f : 1.0f;
                                    textPaint.Color = new SKColor((byte)(255 * r_mult), (byte)(255 * g_mult), 0);

                                    statusDest = new SKRect(curx + hMargin * target_scale, cury + (topMargin + addedFillTop) * target_scale, curx + target_width - hMargin * target_scale, cury + target_height - bottomMargin * target_scale);
                                    canvas.DrawRect(statusDest, textPaint.Paint);
                                    textPaint.Color = SKColors.White;

                                    curx += target_width;
                                }

                                if (ShowFPS)
                                {
                                    target_width = target_scale * GHApp._fpsBitmap.Width;
                                    target_height = target_scale * GHApp._fpsBitmap.Height;
                                    curx = desktopleft - innerspacing * 5 - target_width;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                    canvas.DrawImage(GHApp._fpsBitmap, statusDest);
                                    desktopleft = curx;

                                    string drawtext;
                                    //lockTaken = false;
                                    //lock (_fpslock)
                                    //try
                                    //{
                                    //    Monitor.TryEnter(_fpslock, ref lockTaken);
                                    //    if (lockTaken)
                                    //    {
                                    //        _localFps = _fps;
                                    //    }
                                    //}
                                    //finally
                                    //{
                                    //    if (lockTaken)
                                    //        Monitor.Exit(_fpslock);
                                    //}
                                    //lockTaken = false;

                                    drawtext = string.Format("{0:0.0}", FPS);

                                    const int topMargin = 4, bottomMargin = 16;
                                    textPaint.Color = SKColors.White;
                                    textPaint.TextSize = diffontsize;
                                    //textPaint.TextAlign = SKTextAlign.Center;
                                    float vsize = target_height - (topMargin + bottomMargin) * target_scale;
                                    float fsize = textPaint.FontSpacing;
                                    float vpadding = (vsize - fsize) / 2;
                                    SKPoint drawpoint = new SKPoint(curx + target_width / 2, cury + (topMargin * target_scale) + vpadding - textPaint.FontMetrics.Ascent);
                                    textPaint.DrawTextOnCanvas(canvas, drawtext, drawpoint, SKTextAlign.Center);
                                    //textPaint.TextAlign = SKTextAlign.Left;
                                    textPaint.TextSize = basefontsize;
                                }

                                if (ShowMemory)
                                {
                                    target_width = target_scale * GHApp._memoryBitmap.Width;
                                    target_height = target_scale * GHApp._memoryBitmap.Height;
                                    curx = desktopleft - innerspacing * 5 - target_width;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                    canvas.DrawImage(GHApp._memoryBitmap, statusDest);
                                    desktopleft = curx;

                                    string drawtext;
                                    _localMemUsage = Interlocked.CompareExchange(ref _memUsage, 0, 0);
                                    //lockTaken = false;
                                    ////lock (_showMemoryLock)
                                    //try
                                    //{
                                    //    Monitor.TryEnter(_showMemoryLock, ref lockTaken);
                                    //    if (lockTaken)
                                    //    {
                                    //        _localMemUsage = _memUsage;
                                    //    }
                                    //}
                                    //finally
                                    //{
                                    //    if (lockTaken)
                                    //        Monitor.Exit(_showMemoryLock);
                                    //}
                                    //lockTaken = false;

                                    drawtext = (_localMemUsage / 1024).ToString();

                                    const int topMargin = 7, bottomMargin = 20;
                                    textPaint.Color = SKColors.White;
                                    textPaint.TextSize = diffontsize;
                                    float vsize = target_height - (topMargin + bottomMargin) * target_scale;
                                    float fsize = textPaint.FontSpacing;
                                    float vpadding = (vsize - fsize) / 2;
                                    SKPoint drawpoint = new SKPoint(curx + target_width / 2, cury + (topMargin * target_scale) + vpadding - textPaint.FontMetrics.Ascent);
                                    textPaint.DrawTextOnCanvas(canvas, drawtext, drawpoint, SKTextAlign.Center);
                                    textPaint.TextSize = basefontsize;
                                }

                                if (ShowZoom)
                                {
                                    target_width = target_scale * GHApp._zoomBitmap.Width;
                                    target_height = target_scale * GHApp._zoomBitmap.Height;
                                    curx = desktopleft - innerspacing * 5 - target_width;
                                    statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                                    canvas.DrawImage(GHApp._zoomBitmap, statusDest);
                                    desktopleft = curx;

                                    float percentage = usedFontSize / DefaultMapFontSize;
                                    int percentage_int = (int)(percentage * 100);
                                    string drawtext = percentage_int.ToString();

                                    const int topMargin = 12, bottomMargin = 12;
                                    const int leftMargin = 5, rightMargin = 11;
                                    textPaint.Color = SKColors.White;
                                    textPaint.TextSize = diffontsize * 0.9f;
                                    float vsize = target_height - (topMargin + bottomMargin) * target_scale;
                                    float fsize = textPaint.FontSpacing;
                                    float vpadding = (vsize - fsize) / 2;
                                    SKPoint drawpoint = new SKPoint(curx + leftMargin + (target_width - leftMargin - rightMargin) / 2, cury + (topMargin * target_scale) + vpadding - textPaint.FontMetrics.Ascent);
                                    textPaint.DrawTextOnCanvas(canvas, drawtext, drawpoint, SKTextAlign.Center);

                                    if (MapFontShowPercentageDecimal)
                                    {
                                        const int topFractionMargin = 46, bottomFractionMargin = 4;
                                        int fraction_int = (int)((percentage * 100 - (float)Math.Floor(percentage * 100)) * 10);
                                        string drawtext2 = fraction_int.ToString();
                                        textPaint.TextSize = textPaint.TextSize * 0.7f;
                                        float vsize2 = target_height - (topFractionMargin + bottomFractionMargin) * target_scale;
                                        float fsize2 = textPaint.FontSpacing;
                                        float vpadding2 = (vsize2 - fsize2) / 2;
                                        SKPoint drawpoint2 = new SKPoint(curx + leftMargin + (target_width - leftMargin - rightMargin) / 2, cury + (topFractionMargin * target_scale) + vpadding2 - textPaint.FontMetrics.Ascent);
                                        textPaint.DrawTextOnCanvas(canvas, drawtext2, drawpoint2, SKTextAlign.Center);
                                    }

                                    textPaint.TextSize = basefontsize;
                                }

                                if (ShowRecording)
                                {
                                    if (GHApp.RecordGame && !PlayingReplay)
                                    {
                                        target_width = rowheight / 4;
                                        target_height = rowheight;
                                        curx = desktopleft - innerspacing * 6 - target_width;
                                        desktopleft = curx;
                                        SKPoint dotpoint = new SKPoint(curx + target_width / 2, cury + target_height / 2);
                                        float dotradius = target_width / 2;
                                        textPaint.Color = SKColors.Red;
                                        textPaint.Style = SKPaintStyle.Fill;
                                        canvas.DrawCircle(dotpoint, dotradius, textPaint.Paint);
                                        curx += target_width;
                                    }
                                }

                                /* Pets */
                                if (ShowPets)
                                {
                                    //lock (_petDataLock)
                                    {
                                        textPaint.Color = SKColors.White;
                                        textPaint.Typeface = GHApp.LatoRegular;
                                        textPaint.TextSize = 36;
                                        float pet_target_height = inverse_canvas_scale * (float)(stdButtonHeight + stdRefButtonWidth) / 2;
                                        float pet_picture_target_height = pet_target_height * 0.56f;
                                        float pet_hp_target_height = pet_target_height * 0.24f;
                                        float pet_status_target_height = pet_target_height * 0.2f;
                                        float pet_hp_size = textPaint.TextSize * pet_hp_target_height / textPaint.FontSpacing;
                                        float pet_target_width = pet_target_height;

                                        SKRect menubuttonrect = GetThreadSafeViewScreenRect(GameMenuButton); //UseSimpleCmdLayout ? SimpleGameMenuButton : GameMenuButton
                                        SKRect canvasrect = GetThreadSafeViewScreenRect(MainCanvasView);
                                        SKRect adjustedrect = new SKRect(menubuttonrect.Left - canvasrect.Left, menubuttonrect.Top - canvasrect.Top, menubuttonrect.Right - canvasrect.Left, menubuttonrect.Bottom - canvasrect.Top);
                                        float menu_button_left = adjustedrect.Left;
                                        /* Below is a bit more efficient, but needs to be updated if UI is changed */
                                        //float menu_button_left = (float)(UseSimpleCmdLayout ? UIGrid.ThreadSafeX + SimpleUpperCmdLayout.ThreadSafeX + SimpleGameMenuLayout.ThreadSafeX + SimpleGameMenuButton.ThreadSafeX
                                        //    : UIGrid.ThreadSafeX + UpperCmdLayout.ThreadSafeX + GameMenuLayout.ThreadSafeX + GameMenuButton.ThreadSafeX)
                                        //    * inverse_canvas_scale;
                                        float pet_tx_start = orbleft + orbbordersize * 1.1f;
                                        tx = pet_tx_start;
                                        ty = statusbarheight + 5.0f;
                                        int petrownum = 0;
                                        int petidx = -1;

                                        foreach (GHPetDataItem pdi in _localPetData)
                                        {
                                            petidx++;
                                            monst_info mi = pdi.Data;
                                            using (new SKAutoCanvasRestore(canvas, true))
                                            {
                                                canvas.ClipRect(new SKRect(tx - 1, ty - 1, tx + pet_target_width + 1, ty + pet_target_height + 2));
                                                SKRect usedRect = new SKRect();
                                                if(petidx < _localPetRects.Count)
                                                    _localPetRects[petidx] = usedRect = new SKRect(tx, ty, tx + pet_target_width, ty + pet_target_height);

                                                float petpicturewidth = 0f;
                                                float petpictureheight = 0f;
                                                using (new SKAutoCanvasRestore(canvas, true))
                                                {
                                                    GlyphImageSource gis = new GlyphImageSource();
                                                    gis.ReferenceGamePage = this;
                                                    gis.UseUpperSide = false; /* Monsters are generally full-sized */
                                                    gis.AutoSize = true;
                                                    gis.Glyph = Math.Abs(mi.gui_glyph);
                                                    gis.DoAutoSize();
                                                    float pet_scale = Math.Min(gis.Width == 0 ? 1.0f : pet_target_width / gis.Width, gis.Height == 0 ? 1.0f : pet_picture_target_height / gis.Height);
                                                    petpicturewidth = pet_scale * gis.Width;
                                                    petpictureheight = pet_scale * gis.Height;
                                                    canvas.Translate(tx + (pet_target_width - petpicturewidth) / 2, ty + (pet_picture_target_height - petpictureheight));
                                                    canvas.Scale(pet_scale);
#if GNH_MAP_PROFILING && DEBUG
                                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                                    gis.DrawOnCanvas(canvas, usingGL, _localIsPointerHovering && usedRect.Contains(_localPointerHoverLocation), false, fixRects);
#if GNH_MAP_PROFILING && DEBUG
                                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                                }

                                                float curpety = ty + pet_picture_target_height;
                                                textPaint.TextSize = pet_hp_size;
                                                //textPaint.TextAlign = SKTextAlign.Center;
                                                float petHPHeight = textPaint.FontSpacing;
                                                float barpadding = (textPaint.FontSpacing - (textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent)) / 2;
                                                SKRect petHPRect = new SKRect(tx, curpety, tx + pet_target_width, curpety + petHPHeight);
                                                float petpct = mi.mhpmax <= 0 ? 0.0f : (float)mi.mhp / (float)mi.mhpmax;
                                                SKRect petHPFill = new SKRect(tx, curpety, tx + pet_target_width * petpct, curpety + petHPHeight);
                                                textPaint.Color = SKColors.Red.WithAlpha(144);
#if GNH_MAP_PROFILING && DEBUG
                                                StartProfiling(GHProfilingStyle.Rect);
#endif
                                                canvas.DrawRect(petHPFill, textPaint.Paint);
                                                SKRect petHPNonFill = new SKRect(tx + pet_target_width * petpct, curpety, tx + pet_target_width, curpety + petHPHeight);
                                                textPaint.Color = SKColors.Gray.WithAlpha(144);
                                                canvas.DrawRect(petHPNonFill, textPaint.Paint);
                                                textPaint.Color = SKColors.Black.WithAlpha(144);
                                                textPaint.Style = SKPaintStyle.Stroke;
                                                textPaint.StrokeWidth = 2;
                                                canvas.DrawRect(petHPRect, textPaint.Paint);
#if GNH_MAP_PROFILING && DEBUG
                                                StopProfiling(GHProfilingStyle.Rect);
#endif

                                                curpety += barpadding - textPaint.FontMetrics.Ascent;
                                                textPaint.Style = SKPaintStyle.Fill;
                                                textPaint.Color = SKColors.White;
#if GNH_MAP_PROFILING && DEBUG
                                                StartProfiling(GHProfilingStyle.Text);
#endif
                                                textPaint.DrawTextOnCanvas(canvas, mi.mhp + "(" + mi.mhpmax + ")", tx + pet_target_width / 2, curpety, SKTextAlign.Center);
#if GNH_MAP_PROFILING && DEBUG
                                                StopProfiling(GHProfilingStyle.Text);
#endif

                                                {
                                                    /* Condition, status and buff marks */
                                                    curx = tx;
                                                    cury = petHPRect.Bottom;
                                                    rowheight = pet_status_target_height;

                                                    float marksize = rowheight * 0.95f;
                                                    float markpadding = marksize / 8;
                                                    ulong pet_status_bits;
                                                    pet_status_bits = mi.status_bits;
                                                    if (pet_status_bits != 0)
                                                    {
                                                        int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                                                        foreach (int status_mark in _statusmarkorder)
                                                        {
                                                            ulong statusbit = 1UL << status_mark;
                                                            if ((pet_status_bits & statusbit) != 0)
                                                            {
                                                                int mglyph = (int)game_ui_tile_types.STATUS_MARKS + status_mark / GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS + GHApp.UITileOff;
                                                                int mtile = GHApp.Glyph2Tile[mglyph];
                                                                int sheet_idx = GHApp.TileSheetIdx(mtile);
                                                                int tile_x = GHApp.TileSheetX(mtile);
                                                                int tile_y = GHApp.TileSheetY(mtile);
                                                                int within_tile_x = (status_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) % tiles_per_row;
                                                                int within_tile_y = (status_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) / tiles_per_row;
                                                                int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                                                                int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                                                                SKRect source_rt = new SKRect();
                                                                source_rt.Left = c_x;
                                                                source_rt.Right = c_x + GHConstants.StatusMarkWidth;
                                                                source_rt.Top = c_y;
                                                                source_rt.Bottom = c_y + GHConstants.StatusMarkHeight;

                                                                SKRect target_rt = new SKRect();
                                                                target_rt.Left = curx;
                                                                target_rt.Right = target_rt.Left + marksize;
                                                                target_rt.Top = cury + (rowheight - marksize) / 2;
                                                                target_rt.Bottom = target_rt.Top + marksize;
#if GNH_MAP_PROFILING && DEBUG
                                                                StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                                                GHApp.MaybeFixRects(ref source_rt, ref target_rt, 1.0f, usingGL, fixRects);
                                                                canvas.DrawImage(TileMap[sheet_idx], source_rt, target_rt);
#if GNH_MAP_PROFILING && DEBUG
                                                                StopProfiling(GHProfilingStyle.Bitmap);
#endif

                                                                curx += marksize;
                                                                curx += markpadding;
                                                            }
                                                        }
                                                    }

                                                    ulong pet_condition_bits;
                                                    pet_condition_bits = mi.condition_bits;
                                                    if (pet_condition_bits != 0)
                                                    {
                                                        int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                                                        for (int condition_mark = 0; condition_mark < (int)bl_conditions.NUM_BL_CONDITIONS; condition_mark++)
                                                        {
                                                            ulong conditionbit = 1UL << condition_mark;
                                                            if ((pet_condition_bits & conditionbit) != 0)
                                                            {
                                                                int mglyph = (int)game_ui_tile_types.CONDITION_MARKS + condition_mark / GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS + GHApp.UITileOff;
                                                                int mtile = GHApp.Glyph2Tile[mglyph];
                                                                int sheet_idx = GHApp.TileSheetIdx(mtile);
                                                                int tile_x = GHApp.TileSheetX(mtile);
                                                                int tile_y = GHApp.TileSheetY(mtile);
                                                                int within_tile_x = (condition_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) % tiles_per_row;
                                                                int within_tile_y = (condition_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) / tiles_per_row;
                                                                int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                                                                int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                                                                SKRect source_rt = new SKRect();
                                                                source_rt.Left = c_x;
                                                                source_rt.Right = c_x + GHConstants.StatusMarkWidth;
                                                                source_rt.Top = c_y;
                                                                source_rt.Bottom = c_y + GHConstants.StatusMarkHeight;

                                                                SKRect target_rt = new SKRect();
                                                                target_rt.Left = curx;
                                                                target_rt.Right = target_rt.Left + marksize;
                                                                target_rt.Top = cury + (rowheight - marksize) / 2;
                                                                target_rt.Bottom = target_rt.Top + marksize;
#if GNH_MAP_PROFILING && DEBUG
                                                                StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                                                GHApp.MaybeFixRects(ref source_rt, ref target_rt, 1.0f, usingGL, fixRects);
                                                                canvas.DrawImage(TileMap[sheet_idx], source_rt, target_rt);
#if GNH_MAP_PROFILING && DEBUG
                                                                StopProfiling(GHProfilingStyle.Bitmap);
#endif

                                                                curx += marksize;
                                                                curx += markpadding;
                                                            }
                                                        }
                                                    }

                                                    ulong buff_bits;
                                                    for (int buff_ulong = 0; buff_ulong < GHConstants.NUM_BUFF_BIT_ULONGS; buff_ulong++)
                                                    {
                                                        buff_bits = mi.buff_bits[buff_ulong];
                                                        int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                                                        if (buff_bits != 0)
                                                        {
                                                            for (int buff_idx = 0; buff_idx < 32; buff_idx++)
                                                            {
                                                                ulong buffbit = 1UL << buff_idx;
                                                                if ((buff_bits & buffbit) != 0)
                                                                {
                                                                    int propidx = buff_ulong * 32 + buff_idx;
                                                                    if (propidx > GHConstants.LAST_PROP)
                                                                        break;
                                                                    int mglyph = (propidx - 1) / GHConstants.BUFFS_PER_TILE + GHApp.BuffTileOff;
                                                                    int mtile = GHApp.Glyph2Tile[mglyph];
                                                                    int sheet_idx = GHApp.TileSheetIdx(mtile);
                                                                    int tile_x = GHApp.TileSheetX(mtile);
                                                                    int tile_y = GHApp.TileSheetY(mtile);

                                                                    int buff_mark = (propidx - 1) % GHConstants.BUFFS_PER_TILE;
                                                                    int within_tile_x = buff_mark % tiles_per_row;
                                                                    int within_tile_y = buff_mark / tiles_per_row;
                                                                    int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                                                                    int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                                                                    SKRect source_rt = new SKRect();
                                                                    source_rt.Left = c_x;
                                                                    source_rt.Right = c_x + GHConstants.StatusMarkWidth;
                                                                    source_rt.Top = c_y;
                                                                    source_rt.Bottom = c_y + GHConstants.StatusMarkHeight;

                                                                    SKRect target_rt = new SKRect();
                                                                    target_rt.Left = curx;
                                                                    target_rt.Right = target_rt.Left + marksize;
                                                                    target_rt.Top = cury + (rowheight - marksize) / 2;
                                                                    target_rt.Bottom = target_rt.Top + marksize;
#if GNH_MAP_PROFILING && DEBUG
                                                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                                                    GHApp.MaybeFixRects(ref source_rt, ref target_rt, 1.0f, usingGL, fixRects);
                                                                    canvas.DrawImage(TileMap[sheet_idx], source_rt, target_rt);
#if GNH_MAP_PROFILING && DEBUG
                                                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif

                                                                    curx += marksize;
                                                                    curx += markpadding;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                                /* Next pet */
                                                tx += pet_target_width;
                                                if (tx + pet_target_width * 1.08f > menu_button_left)
                                                {
                                                    tx = pet_tx_start;
                                                    ty += pet_target_height + textPaint.FontSpacing / 2;
                                                    petrownum++;
                                                    if (petrownum >= NumDisplayedPetRows)
                                                        break;
                                                }
                                                else
                                                    tx += pet_target_width * 0.08f;
                                            }

                                            //textPaint.TextAlign = SKTextAlign.Left;
                                        }
                                    }
                                }
                                //else
                                //{
                                //    //lock (_petDataLock)
                                //    {
                                //        for (int i = 0; i < _localPetRects.Count; i++)
                                //        {
                                //            _localPetRects[i] = new SKRect();
                                //        }
                                //    }
                                //}
                            }
                        }

                        bool orbsok = false;
                        bool prevwepok = false;
                        bool isunwield = false;
                        bool skillbuttonok = false;
                        orbsok = _localStatusFields[(int)NhStatusFields.BL_HPMAX].Text != "" && _localStatusFields[(int)NhStatusFields.BL_HPMAX].Text != "0";
                        skillbuttonok = _localStatusFields[(int)NhStatusFields.BL_SKILL].Text != null && _localStatusFields[(int)NhStatusFields.BL_SKILL].Text == "Skill";
                        if (_localWeaponStyleObjDataItem[0] != null)
                        {
                            prevwepok = _localWeaponStyleObjDataItem[0].PreviousWeaponFound || _localWeaponStyleObjDataItem[0].PreviousUnwield;
                            isunwield = _localWeaponStyleObjDataItem[0].PreviousUnwield;
                        }
                        float lastdrawnrecty = ClassicStatusBar ? Math.Max(abilitybuttonbottom, lastStatusRowPrintY + 0.0f * lastStatusRowFontSpacing) : statusbarheight;
                        tx = orbleft;
                        ty = lastdrawnrecty + 5.0f;
                        if (orbsok && skillbuttonok && prevwepok && ty + orbbordersize * 4 + 5 + 15 + 15 > Math.Min(herewindowtop, messagewindowtop))
                            skillbuttonok = false;

                        /* HP and MP */
                        if ((ShowOrbs || !ClassicStatusBar) && orbsok)
                        {
                            float orbfillpercentage = 0.0f;
                            string valtext = "";
                            string maxtext = "";
                            bool pctset = false;
                            if (_localStatusFields[(int)NhStatusFields.BL_HP].Text != null && _localStatusFields[(int)NhStatusFields.BL_HP].Text != "" && _localStatusFields[(int)NhStatusFields.BL_HPMAX].Text != null && _localStatusFields[(int)NhStatusFields.BL_HPMAX].Text != "")
                            {
                                valtext = _localStatusFields[(int)NhStatusFields.BL_HP].Text;
                                maxtext = _localStatusFields[(int)NhStatusFields.BL_HPMAX].Text;
                                int hp = 0, hpmax = 1;
                                if (int.TryParse(_localStatusFields[(int)NhStatusFields.BL_HP].Text, out hp) && int.TryParse(_localStatusFields[(int)NhStatusFields.BL_HPMAX].Text, out hpmax))
                                {
                                    if (hpmax > 0)
                                    {
                                        orbfillpercentage = (float)hp / (float)hpmax;
                                        pctset = true;
                                    }
                                }
                                if (!pctset)
                                    orbfillpercentage = ((float)_localStatusFields[(int)NhStatusFields.BL_HP].Percent) / 100.0f;
                            }
                            SKRect orbBorderDest = new SKRect(tx, ty, tx + orbbordersize, ty + orbbordersize);
                            healthRect = orbBorderDest;
                            //healthRectDrawn = true;
                            DrawOrb(canvas, textPaint, orbBorderDest, SKColors.Red, valtext, maxtext, orbfillpercentage, ShowMaxHealthInOrb, false /* isPointerHovering && orbBorderDest.Contains(pointerHoverLocation) */);

                            orbfillpercentage = 0.0f;
                            valtext = "";
                            maxtext = "";
                            if (_localStatusFields[(int)NhStatusFields.BL_ENE].Text != null && _localStatusFields[(int)NhStatusFields.BL_ENE].Text != "" && _localStatusFields[(int)NhStatusFields.BL_ENEMAX].Text != null && _localStatusFields[(int)NhStatusFields.BL_ENEMAX].Text != "")
                            {
                                valtext = _localStatusFields[(int)NhStatusFields.BL_ENE].Text;
                                maxtext = _localStatusFields[(int)NhStatusFields.BL_ENEMAX].Text;
                                int en = 0, enmax = 1;
                                if (int.TryParse(_localStatusFields[(int)NhStatusFields.BL_ENE].Text, out en) && int.TryParse(_localStatusFields[(int)NhStatusFields.BL_ENEMAX].Text, out enmax))
                                {
                                    if (enmax > 0)
                                    {
                                        orbfillpercentage = (float)en / (float)enmax;
                                    }
                                }
                            }
                            orbBorderDest = new SKRect(tx, ty + orbbordersize + 5, tx + orbbordersize, ty + orbbordersize + 5 + orbbordersize);
                            manaRect = orbBorderDest;
                            //manaRectDrawn = true;
                            DrawOrb(canvas, textPaint, orbBorderDest, SKColors.Blue, valtext, maxtext, orbfillpercentage, ShowMaxManaInOrb, false /* isPointerHovering && orbBorderDest.Contains(pointerHoverLocation) */);
                            lastdrawnrecty = orbBorderDest.Bottom;
                        }

                        if (skillbuttonok)
                        {
                            SKRect skillDest = new SKRect(tx, lastdrawnrecty + 15.0f, tx + orbbordersize, lastdrawnrecty + 15.0f + orbbordersize);
                            skillRect = skillDest;
                            //skillRectDrawn = true;
                            textPaint.Color = SKColors.White;
                            textPaint.Typeface = GHApp.LatoRegular;
                            textPaint.TextSize = GHConstants.SkillButtonBaseFontSize * skillDest.Width / 50.0f;
                            //textPaint.TextAlign = SKTextAlign.Center;
#if GNH_MAP_PROFILING && DEBUG
                            StartProfiling(GHProfilingStyle.Bitmap);
#endif
                            using(SKPaint btnPaint = new SKPaint())
                            {
                                if (_localIsPointerHovering && skillDest.Contains(_localPointerHoverLocation))
                                {
                                    btnPaint.ColorFilter = UIUtils.HighlightColorFilter;
                                }
                                canvas.DrawImage(GHApp._skillBitmap, skillDest, btnPaint);
                            }
#if GNH_MAP_PROFILING && DEBUG
                            StopProfiling(GHProfilingStyle.Bitmap);
#endif
                            float text_x = (skillDest.Left + skillDest.Right) / 2;
                            float text_y = skillDest.Bottom - textPaint.FontMetrics.Ascent;
#if GNH_MAP_PROFILING && DEBUG
                            StartProfiling(GHProfilingStyle.Text);
#endif
                            textPaint.DrawTextOnCanvas(canvas, "Skills", text_x, text_y, SKTextAlign.Center);
#if GNH_MAP_PROFILING && DEBUG
                            StopProfiling(GHProfilingStyle.Text);
#endif
                            //textPaint.TextAlign = SKTextAlign.Left;
                            lastdrawnrecty = skillDest.Bottom + textPaint.FontSpacing;
                        }

                        if (prevwepok)
                        {
                            SKRect prevWepDest = new SKRect(tx, lastdrawnrecty + 15.0f, tx + orbbordersize, lastdrawnrecty + 15.0f + orbbordersize);
                            prevWepRect = prevWepDest;
                            //prevWepRectDrawn = true;
                            textPaint.Color = SKColors.White;
                            textPaint.Typeface = GHApp.LatoRegular;
                            textPaint.TextSize = GHConstants.SkillButtonBaseFontSize * prevWepDest.Width / 50.0f;
                            //textPaint.TextAlign = SKTextAlign.Center;
#if GNH_MAP_PROFILING && DEBUG
                            StartProfiling(GHProfilingStyle.Bitmap);
#endif
                            using (SKPaint btnPaint = new SKPaint())
                            {
                                if (_localIsPointerHovering && prevWepDest.Contains(_localPointerHoverLocation))
                                {
                                    btnPaint.ColorFilter = UIUtils.HighlightColorFilter;
                                }
                                canvas.DrawImage(isunwield ? GHApp._prevUnwieldBitmap : GHApp._prevWepBitmap, prevWepDest, btnPaint);
                            }
#if GNH_MAP_PROFILING && DEBUG
                            StopProfiling(GHProfilingStyle.Bitmap);
#endif
                            float text_x = (prevWepDest.Left + prevWepDest.Right) / 2;
                            float text_y = prevWepDest.Bottom - textPaint.FontMetrics.Ascent;
#if GNH_MAP_PROFILING && DEBUG
                            StartProfiling(GHProfilingStyle.Text);
#endif
                            textPaint.DrawTextOnCanvas(canvas, isunwield ? "Unwield" : "Wield Last", text_x, text_y, SKTextAlign.Center);
#if GNH_MAP_PROFILING && DEBUG
                            StopProfiling(GHProfilingStyle.Text);
#endif
                            //textPaint.TextAlign = SKTextAlign.Left;
                        }
                    }

                    /* Context Menu */
                    //lock(_contextMenuDataLock)
                    {
                        float startBottom = canvasheight - (float)usedButtonRowStackHeight * inverse_canvas_scale - GHConstants.ContextButtonBottomStartMargin;
                        float textSize = GHConstants.ContextButtonBaseFontSize * orbbordersize / 50.0f;
                        float internalPadding = (float)GHConstants.ContextButtonSpacing * inverse_canvas_scale;
                        float startTop = startBottom + internalPadding;
                        float horizontalPadding = 2f * inverse_canvas_scale;
                        float startLeft = canvaswidth - orbbordersize - horizontalPadding;
                        float topLimit = (float)(stdCmdLayoutHeight + stdCmdLayoutMargin.Top) * inverse_canvas_scale;
                        bool isFirstCmb = true;
                        int cbIdx = -1;
                        foreach (ContextMenuButton cmb in _localContextMenuData) /* foreach, since _contextMenuData may in theory be cleared concurrently in the same thread */
                        {
                            cbIdx++;
                            SKRect usedRect = new SKRect();
                            startTop -= (orbbordersize + internalPadding + textSize);
                            if (startTop < topLimit && !isFirstCmb)
                            {
                                startTop = startBottom - orbbordersize - textSize;
                                startLeft -= (internalPadding + orbbordersize);
                            }
                            else
                            {
                                isFirstCmb = false;
                            }
                            if(cbIdx < _localContextMenuRects.Count)
                                _localContextMenuRects[cbIdx] = usedRect = new SKRect(startLeft, startTop, startLeft + orbbordersize, startTop + orbbordersize + textSize);
                            SKRect imgDest = new SKRect(startLeft, startTop, startLeft + orbbordersize, startTop + orbbordersize);
                            textPaint.Color = SKColors.White;
                            textPaint.Typeface = GHApp.LatoRegular;
                            textPaint.TextSize = textSize;
                            //textPaint.TextAlign = SKTextAlign.Center;
#if GNH_MAP_PROFILING && DEBUG
                            StartProfiling(GHProfilingStyle.Bitmap);
#endif
                            using (SKPaint btnPaint = new SKPaint())
                            {
                                if (_localIsPointerHovering && usedRect.Contains(_localPointerHoverLocation))
                                {
                                    btnPaint.ColorFilter = UIUtils.HighlightColorFilter;
                                }
                                canvas.DrawImage(cmb.Bitmap, imgDest, btnPaint);
                            }
#if GNH_MAP_PROFILING && DEBUG
                            StopProfiling(GHProfilingStyle.Bitmap);
#endif
                            float text_x = (imgDest.Left + imgDest.Right) / 2;
                            float text_y = imgDest.Bottom - textPaint.FontMetrics.Ascent;
#if GNH_MAP_PROFILING && DEBUG
                            StartProfiling(GHProfilingStyle.Text);
#endif
                            textPaint.DrawTextOnCanvas(canvas, cmb.LblText, text_x, text_y, SKTextAlign.Center);
#if GNH_MAP_PROFILING && DEBUG
                            StopProfiling(GHProfilingStyle.Text);
#endif
                        }
                    }
                    
                    //if(!statusBarRectDrawn)
                    //    statusBarRect = new SKRect();
                    //if (!healthRectDrawn)
                    //    healthRect = new SKRect();
                    //if (!manaRectDrawn)
                    //    manaRect = new SKRect();
                    //if (!skillRectDrawn)
                    //    skillRect = new SKRect();
                    //if (!prevWepRectDrawn)
                    //    prevWepRect = new SKRect();

                    /* Number Pad and Direction Arrows */
                    _localCanvasButtonRect.Right = canvaswidth * (float)(0.8);
                    _localCanvasButtonRect.Left = canvaswidth * (float)(0.2);
                }

                if (showDirections || (mapWalkMode && walkArrows))
                {
                    SKRect targetrect;
                    float buttonsize = showDirections ? GHConstants.ArrowButtonSize : GHConstants.MoveArrowButtonSize;
                    SKColor oldcolor = textPaint.Color;
                    textPaint.Color = showDirections ? textPaint.Color.WithAlpha(170) : textPaint.Color.WithAlpha(85);

                    for (int i = 0; i < 9; i++)
                    {
                        //lock (_canvasButtonLock)
                        {
                            switch (i)
                            {
                                case 0:
                                    tx = _localCanvasButtonRect.Left;
                                    ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height / 2 - _localCanvasButtonRect.Height * (buttonsize / 2);
                                    break;
                                case 1:
                                    tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width / 2 - _localCanvasButtonRect.Width * (buttonsize / 2);
                                    ty = _localCanvasButtonRect.Top;
                                    break;
                                case 2:
                                    tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width - _localCanvasButtonRect.Width * buttonsize;
                                    ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height / 2 - _localCanvasButtonRect.Height * (buttonsize / 2);
                                    break;
                                case 3:
                                    tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width / 2 - _localCanvasButtonRect.Width * (buttonsize / 2);
                                    ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height - _localCanvasButtonRect.Height * buttonsize;
                                    break;
                                case 4:
                                    tx = _localCanvasButtonRect.Left;
                                    ty = _localCanvasButtonRect.Top;
                                    break;
                                case 5:
                                    continue;
                                case 6:
                                    tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width * (1.0f - buttonsize);
                                    ty = _localCanvasButtonRect.Top;
                                    break;
                                case 7:
                                    tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width * (1.0f - buttonsize);
                                    ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height * (1.0f - buttonsize);
                                    break;
                                case 8:
                                    tx = _localCanvasButtonRect.Left;
                                    ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height * (1.0f - buttonsize);
                                    break;
                                default:
                                    continue;
                            }

                            float px = Math.Max(0, _localCanvasButtonRect.Width - _localCanvasButtonRect.Height) * buttonsize / 2;
                            float py = Math.Max(0, _localCanvasButtonRect.Height - _localCanvasButtonRect.Width) * buttonsize / 2;
                            float truesize = Math.Min(_localCanvasButtonRect.Width, _localCanvasButtonRect.Height) * buttonsize;
                            targetrect = new SKRect(tx + px, ty + py, tx + px + truesize, ty + py + truesize);
                        }
                        canvas.DrawImage(GHApp._arrowBitmap[i], targetrect, textPaint.Paint);
                    }
                    textPaint.Color = oldcolor;
                }
                else if (showNumberPad)
                {
                    for (int j = 0; j <= 2; j++)
                    {
                        float buttonsize = GHConstants.NumberButtonSize;
                        float offset = 0;
                        SKColor oldcolor = textPaint.Color;
                        SKMaskFilter oldfilter = textPaint.MaskFilter;
                        textPaint.Typeface = GHApp.DiabloTypeface;
                        textPaint.TextSize = 225;
                        if (j == 0)
                        {
                            textPaint.Color = SKColors.Black.WithAlpha(oldcolor.Alpha);
                            textPaint.MaskFilter = _blur;
                            offset = textPaint.TextSize / 15;
                            textPaint.Style = SKPaintStyle.Fill;
                        }
                        else if (j == 1)
                        {
                            textPaint.Color = new SKColor(255, 255, 0xD7, 255);
                            textPaint.Style = SKPaintStyle.Fill;
                        }
                        else
                        {
                            textPaint.Color = new SKColor(80, 80, 50, 255);
                            textPaint.Style = SKPaintStyle.Stroke;
                            textPaint.StrokeWidth = textPaint.TextSize / 20;
                        }
                        float avgwidth = textPaint.MeasureText("A");
                        for (int i = 0; i <= 9; i++)
                        {
                            //lock (_canvasButtonLock)
                            {
                                switch (i)
                                {
                                    case 0:
                                        str = "4";
                                        tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width * (buttonsize / 2) - avgwidth / 2;
                                        ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height / 2 + textPaint.FontMetrics.Descent;
                                        break;
                                    case 1:
                                        str = "8";
                                        tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width / 2 - avgwidth / 2;
                                        ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height * (buttonsize / 2) + textPaint.FontMetrics.Descent;
                                        break;
                                    case 2:
                                        str = "6";
                                        tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width * (1.0f - buttonsize / 2) - avgwidth / 2;
                                        ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height / 2 + textPaint.FontMetrics.Descent;
                                        break;
                                    case 3:
                                        str = "2";
                                        tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width / 2 - avgwidth / 2;
                                        ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height * (1.0f - buttonsize / 2) + textPaint.FontMetrics.Descent;
                                        break;
                                    case 4:
                                        str = "7";
                                        tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width * (buttonsize / 2) - avgwidth / 2;
                                        ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height * (buttonsize / 2) + textPaint.FontMetrics.Descent;
                                        break;
                                    case 5:
                                        str = "5";
                                        tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width / 2 - avgwidth / 2;
                                        ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height / 2 + textPaint.FontMetrics.Descent;
                                        break;
                                    case 6:
                                        str = "9";
                                        tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width * (1.0f - buttonsize / 2) - avgwidth / 2;
                                        ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height * (buttonsize / 2) + textPaint.FontMetrics.Descent;
                                        break;
                                    case 7:
                                        str = "3";
                                        tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width * (1.0f - buttonsize / 2) - avgwidth / 2;
                                        ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height * (1.0f - buttonsize / 2) + textPaint.FontMetrics.Descent;
                                        break;
                                    case 8:
                                        str = "1";
                                        tx = _localCanvasButtonRect.Left + _localCanvasButtonRect.Width * (buttonsize / 2) - avgwidth / 2;
                                        ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height * (1.0f - buttonsize / 2) + textPaint.FontMetrics.Descent;
                                        break;
                                    case 9:
                                        str = "0";
                                        tx = 0 + _localCanvasButtonRect.Left / 2 - avgwidth / 2;
                                        //ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height * (buttonsize / 2) + textPaint.FontMetrics.Descent;
                                        ty = _localCanvasButtonRect.Top + _localCanvasButtonRect.Height * (1.0f - buttonsize / 2) + textPaint.FontMetrics.Descent;
                                        textPaint.TextSize = Math.Max(10.0f, textPaint.TextSize * Math.Min(1.0f, _localCanvasButtonRect.Left / (_localCanvasButtonRect.Width * buttonsize)));
                                        break;
                                }
                            }
                            textPaint.DrawTextOnCanvas(canvas, str, tx + offset, ty + offset);
                        }
                        textPaint.Color = oldcolor;
                        textPaint.MaskFilter = oldfilter;
                    }
                    textPaint.Style = SKPaintStyle.Fill;
                }

                //youRectDrawn = false;
                /* Status Screen */
                if (ShowExtendedStatusBar)
                {
                    DrawExtendedStatusBar(canvas, textPaint, canvaswidth, canvasheight, inverse_canvas_scale, statusBarSkiaHeight, canvasViewWidth, canvasViewHeight, stdButtonWidth, stdButtonHeight, usedButtonRowStackHeight, usingGL, fixRects, ref youRect);
                }
#if WINDOWS
                GameCursorType newCursor = GameCursorType.Normal;
                bool doChangeCursor = false;
                //lock (_canvasPointerLock)
                {
                    GameCursorType usedCursor = _localIsPointerHovering && (statusBarRect.Contains(_localPointerHoverLocation) || youRect.Contains(_localPointerHoverLocation) || healthRect.Contains(_localPointerHoverLocation) || manaRect.Contains(_localPointerHoverLocation)) ? GameCursorType.Info : GameCursorType.Normal;
                    if (usedCursor != _localCurrentCursorType)
                    {
                        doChangeCursor = true;
                        _localCurrentCursorType = newCursor = usedCursor;
                    }
                }
                if (doChangeCursor)
                    UIUtils.ChangeElementCursor(RootGrid, newCursor);
#endif
            }


            lockTaken = false;
            //lock (_uiPetRectLock)
            try
            {
                Monitor.TryEnter(_uiPetRectLock, ref lockTaken);
                if (lockTaken)
                {
                    _uiPetData.Clear();
                    _uiPetData.AddRange(_localPetData);
                    _uiPetRects.Clear();
                    _uiPetRects.AddRange(_localPetRects);
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_uiPetRectLock);
            }
            lockTaken = false;

            //lock (_uiContextMenuRectLock)
            try
            {
                Monitor.TryEnter(_uiContextMenuRectLock, ref lockTaken);
                if (lockTaken)
                {
                    _uiContextMenuData.Clear();
                    _uiContextMenuData.AddRange(_localContextMenuData);
                    _uiContextMenuRects.Clear();
                    _uiContextMenuRects.AddRange(_localContextMenuRects);
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_uiContextMenuRectLock);
            }
            lockTaken = false;

            //lock (_canvasButtonLock)
            try
            {
                Monitor.TryEnter(_canvasButtonLock, ref lockTaken);
                if (lockTaken)
                {
                    _canvasButtonRect = _localCanvasButtonRect;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_canvasButtonLock);
            }
            lockTaken = false;

            //lock (_statusOffsetLock)
            try
            {
                Monitor.TryEnter(_statusOffsetLock, ref lockTaken);
                if (lockTaken)
                {
                    _statusClipBottom = _localStatusClipBottom;
                    _statusLargestBottom = _localStatusLargestBottom;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_statusOffsetLock);
            }
            lockTaken = false;

            //lock (_uiRectLock)
            try
            {
                Monitor.TryEnter(_uiRectLock, ref lockTaken);
                if (lockTaken)
                {
                    _uiStatusBarRect = statusBarRect;
                    _uiHealthRect = healthRect;
                    _uiManaRect = manaRect;
                    _uiSkillRect = skillRect;
                    _uiPrevWepRect = prevWepRect;
                    _uiYouRect = youRect;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_uiRectLock);
            }
            lockTaken = false;

#if GNH_MAP_PROFILING && DEBUG
            if ((_totalFrames % 120) == 0)
                Debug.WriteLine("Frames: " + _totalFrames + ", bmp: " + _profilingStopwatchBmp.ElapsedTicks / _totalFrames + ", text: " + _profilingStopwatchText.ElapsedTicks / _totalFrames + ", rect: " + _profilingStopwatchRect.ElapsedTicks / _totalFrames);
#endif
        }

        private void DrawExtendedStatusBar(SKCanvas canvas, GHSkiaFontPaint textPaint, float canvaswidth, float canvasheight, float inverse_canvas_scale, float statusBarSkiaHeight,
            double canvasViewWidth, double canvasViewHeight, double stdButtonWidth, double stdButtonHeight, double usedButtonRowStackHeight, bool usingGL, bool fixRects,
            ref SKRect youRect)
        {
            ButtonGridStats btnGridSize = CalculateStoneButtonGridSize(canvasViewWidth, canvasViewHeight);

            float box_left = canvaswidth < canvasheight ? (btnGridSize.Buttons > 7 ? 2.25f : 1.25f) * inverse_canvas_scale * (float)stdButtonWidth :
                (btnGridSize.Columns * 1.125f) * inverse_canvas_scale * (float)stdButtonWidth;
            float box_right = canvaswidth - box_left;
            if (canvaswidth < canvasheight && box_right - box_left < GHConstants.StatusScreenWidthThresholdMultiplierPortrait * canvaswidth)
            {
                //if (btnGridSize.Buttons > 7)
                box_left = Math.Max((0.75f) * inverse_canvas_scale * (float)stdButtonWidth, box_right - GHConstants.StatusScreenWidthThresholdMultiplierPortrait * canvaswidth);
            }
            else if (box_right - box_left < GHConstants.StatusScreenWidthThresholdMultiplierLandscape * canvaswidth)
            {
                //if (btnGridSize.Columns > 3)
                //    box_left = (3.375f) * inverse_canvas_scale * (float)stdButtonWidth;
                //if (btnGridSize.Columns > 2 && box_right - box_left < GHConstants.StatusScreenWidthThresholdMultiplierLandscape * canvaswidth)
                //    box_left = (2.25f) * inverse_canvas_scale * (float)stdButtonWidth;
                //if (box_right - box_left < GHConstants.StatusScreenWidthThresholdMultiplierLandscape * canvaswidth)
                //    box_left = (1.50f) * inverse_canvas_scale * (float)stdButtonWidth;
                box_left = Math.Max((1.50f) * inverse_canvas_scale * (float)stdButtonWidth, box_right - GHConstants.StatusScreenWidthThresholdMultiplierLandscape * canvaswidth);
            }
            if (box_right < box_left)
                box_left = box_right;
            float box_top = canvaswidth < canvasheight ? statusBarSkiaHeight + 1.25f * inverse_canvas_scale * (float)stdButtonHeight :
                statusBarSkiaHeight + 0.25f * inverse_canvas_scale * (float)stdButtonHeight;
            float box_bottom = canvasheight - 1.25f * inverse_canvas_scale * (float)usedButtonRowStackHeight;
            if (box_bottom < box_top)
                box_bottom = box_top;

            /* Window Background */
            textPaint.Color = SKColors.Black;
            SKRect bkgrect = new SKRect(box_left, box_top, box_right, box_bottom);
            float youmargin = Math.Min((box_right - box_left), (box_bottom - box_top)) / 14;
            float yousize = Math.Min((box_right - box_left), (box_bottom - box_top)) / 8;
            float youtouchsize = Math.Min((box_right - box_left), (box_bottom - box_top)) / 6;
            float youtouchmargin = Math.Max(0, (youtouchsize - yousize) / 2);
            SKRect urect = new SKRect(box_right - youmargin - yousize, box_top + youmargin, box_right - youmargin, box_top + youmargin + yousize);
            SKRect utouchrect = new SKRect(urect.Left - youtouchmargin, urect.Top - youtouchmargin, urect.Right + youtouchmargin, urect.Bottom + youtouchmargin);

            youRect = utouchrect;
            //youRectDrawn = true;

            /* Background first */
            textPaint.Style = SKPaintStyle.Fill;
            textPaint.Color = SKColors.Black.WithAlpha(200);
            canvas.DrawRect(0, 0, canvaswidth, canvasheight, textPaint.Paint);
            textPaint.Color = SKColors.Black;
            canvas.DrawImage(GHApp.ScrollBitmap, bkgrect);
            canvas.DrawImage(GHApp.YouBitmap, urect);

            /* Then the status contents */
            textPaint.Style = SKPaintStyle.Fill;
            textPaint.Typeface = GHApp.UnderwoodTypeface;
            textPaint.Color = SKColors.Black;
            textPaint.TextSize = 36;

            float twidth = textPaint.MeasureText("Strength");
            float theight = textPaint.FontSpacing;
            float tscale_one_column = Math.Max(0.1f, Math.Min((bkgrect.Width * (1 - 2f / 12.6f) / 4) / twidth, (bkgrect.Height * (1 - 2f / 8.5f) / 21) / theight));
            float tscale_two_columns = Math.Max(0.1f, Math.Min((bkgrect.Width * (1 - 2f / 12.6f) / 4) / twidth, (bkgrect.Height * (1 - 2f / 8.5f) / 18) / theight));
            //float strwidth_one_column = twidth * tscale_one_column;
            float strwidth_two_columns = twidth * tscale_two_columns;
            //float indentation_one_column = strwidth_one_column * 20f / 8f;
            float indentation_two_columns = strwidth_two_columns * 20f / 8f;
            bool use_two_columns = bkgrect.Width - bkgrect.Width * 2f / 12.6f >= indentation_two_columns * 2.5f;

            float tscale = use_two_columns ? tscale_two_columns : tscale_one_column;
            float basefontsize = textPaint.TextSize * tscale;
            textPaint.TextSize = basefontsize;
            float strwidth = twidth * tscale;
            float indentation = strwidth * 20f / 8f;

            float tx;
            float ty = bkgrect.Top + bkgrect.Height / 8.5f - textPaint.FontMetrics.Ascent;
            string valtext, valtext2;
            float base_ty = ty;
            float box_bottom_draw_threshold = box_bottom - bkgrect.Height / 8.5f;
            float box_top_draw_threshold = box_top + bkgrect.Height / 8.5f;
            float icon_height = textPaint.FontSpacing * 0.85f;
            float icon_max_width = icon_height * 2f;
            float icon_base_left = bkgrect.Left - icon_max_width; //bkgrect.Right - bkgrect.Width * 1f / 12.6f - icon_max_width
            float icon_tx = icon_base_left;
            float icon_ty;
            icon_ty = ty + textPaint.FontMetrics.Ascent + (textPaint.FontSpacing - icon_height) / 2;
            float icon_width = icon_height;
            SKRect icon_rect;
            int valcolor = (int)NhColor.CLR_WHITE;

            valtext = "";
            if (_localStatusFields[(int)NhStatusFields.BL_TITLE].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_TITLE].Text != null)
            {
                valtext = _localStatusFields[(int)NhStatusFields.BL_TITLE].Text.Trim();
            }
            if (valtext != "")
            {
                textPaint.Typeface = GHApp.ImmortalTypeface;
                textPaint.TextSize = basefontsize * 1.1f;
                tx = (bkgrect.Left + bkgrect.Right) / 2;
                //textPaint.TextAlign = SKTextAlign.Center;
                textPaint.DrawTextOnCanvas(canvas, valtext, tx, ty, SKTextAlign.Center);
                //textPaint.TextAlign = SKTextAlign.Left;
                textPaint.Typeface = GHApp.UnderwoodTypeface;
                textPaint.TextSize = basefontsize;
                ty += textPaint.FontSpacing;
                box_top_draw_threshold = ty;
                ty += textPaint.FontSpacing * 0.5f;
            }

            using (new SKAutoCanvasRestore(canvas, true))
            {
                tx = bkgrect.Left + bkgrect.Width / 12.6f;

                SKRect cliprect = new SKRect(0, ty + textPaint.FontMetrics.Ascent, canvaswidth, bkgrect.Bottom - bkgrect.Height / 8.5f);
                //canvas.ClipRect(cliprect); // Note this ClipRect sometimes malfunctions on iOS with SKGLView

                //lock (_statusOffsetLock)
                {
                    ty += _localStatusOffsetY;
                    _localStatusClipBottom = cliprect.Bottom;
                    _localStatusLargestBottom = 0;
                }
                base_ty = ty;
                box_bottom_draw_threshold = _localStatusClipBottom;

                for (int i = 0; i < 6; i++)
                {
                    valtext = "";
                    if (_localStatusFields[(int)NhStatusFields.BL_STR + i].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_STR + i].Text != null)
                    {
                        valtext = _localStatusFields[(int)NhStatusFields.BL_STR + i].Text;
                        valcolor = _localStatusFields[(int)NhStatusFields.BL_STR + i].Color;
                    }
                    if (valtext != "")
                    {
                        _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                        if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                        {
                            string printtext = _attributeStrings[i];
                            textPaint.DrawTextOnCanvas(canvas, printtext, tx, ty);
                            textPaint.Color = UIUtils.NHColor2SKColorCore(valcolor, 0, true, false);
                            textPaint.DrawTextOnCanvas(canvas, valtext, tx + indentation, ty);
                            textPaint.Color = SKColors.Black;
                            SKImage statIcon = GetStatIcon(i);
                            icon_width = icon_height * (float)statIcon.Width / (float)statIcon.Height;
                            icon_tx = icon_base_left + (icon_max_width - icon_width) / 2f;
                            icon_ty = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - icon_height) / 2;
                            icon_rect = new SKRect(icon_tx, icon_ty, icon_tx + icon_width, icon_ty + icon_height);
                            canvas.DrawImage(statIcon, icon_rect);
                        }
                        ty += textPaint.FontSpacing;
                    }
                }
                ty += textPaint.FontSpacing * 0.5f;

                valtext = "";
                if (_localStatusFields[(int)NhStatusFields.BL_XP].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_XP].Text != null)
                {
                    valtext = _localStatusFields[(int)NhStatusFields.BL_XP].Text;
                }
                if (valtext != "")
                {
                    _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                    if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                    {
                        textPaint.DrawTextOnCanvas(canvas, "Level:", tx, ty);
                        textPaint.DrawTextOnCanvas(canvas, valtext, tx + indentation, ty);
                        icon_width = icon_height * (float)GHApp._statusXPLevelBitmap.Width / (float)GHApp._statusXPLevelBitmap.Height;
                        icon_tx = icon_base_left + (icon_max_width - icon_width) / 2f;
                        icon_ty = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - icon_height) / 2;
                        icon_rect = new SKRect(icon_tx, icon_ty, icon_tx + icon_width, icon_ty + icon_height);
                        canvas.DrawImage(GHApp._statusXPLevelBitmap, icon_rect);
                    }
                    ty += textPaint.FontSpacing;
                }

                valtext = "";
                if (_localStatusFields[(int)NhStatusFields.BL_EXP].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_EXP].Text != null)
                {
                    valtext = _localStatusFields[(int)NhStatusFields.BL_EXP].Text;
                }
                if (valtext != "")
                {
                    _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                    if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                    {
                        textPaint.DrawTextOnCanvas(canvas, "Experience:", tx, ty);
                        textPaint.DrawTextOnCanvas(canvas, valtext, tx + indentation, ty);
                        icon_tx = icon_base_left + (icon_max_width - icon_width) / 2f;
                        icon_ty = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - icon_height) / 2;
                        icon_rect = new SKRect(icon_tx, icon_ty, icon_tx + icon_width, icon_ty + icon_height);
                        canvas.DrawImage(GHApp._statusXPPointsBitmap, icon_rect);
                    }
                    ty += textPaint.FontSpacing;
                }

                valtext = "";
                if (_localStatusFields[(int)NhStatusFields.BL_HD].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_HD].Text != null)
                {
                    valtext = _localStatusFields[(int)NhStatusFields.BL_HD].Text;
                }
                if (valtext != "")
                {
                    _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                    if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                    {
                        textPaint.DrawTextOnCanvas(canvas, "Hit dice:", tx, ty);
                        textPaint.DrawTextOnCanvas(canvas, valtext, tx + indentation, ty);
                        icon_width = icon_height * (float)GHApp._statusHDBitmap.Width / (float)GHApp._statusHDBitmap.Height;
                        icon_tx = icon_base_left + (icon_max_width - icon_width) / 2f;
                        icon_ty = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - icon_height) / 2;
                        icon_rect = new SKRect(icon_tx, icon_ty, icon_tx + icon_width, icon_ty + icon_height);
                        canvas.DrawImage(GHApp._statusHDBitmap, icon_rect);
                    }
                    ty += textPaint.FontSpacing;
                }

                valtext = "";
                if (_localStatusFields[(int)NhStatusFields.BL_ALIGN].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_ALIGN].Text != null)
                {
                    valtext = _localStatusFields[(int)NhStatusFields.BL_ALIGN].Text;
                }
                if (valtext != "")
                {
                    _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                    if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                    {
                        textPaint.DrawTextOnCanvas(canvas, "Alignment:", tx, ty);
                        textPaint.DrawTextOnCanvas(canvas, valtext, tx + indentation, ty);
                        icon_tx = icon_base_left + (icon_max_width - icon_width) / 2f;
                        icon_ty = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - icon_height) / 2;
                        icon_rect = new SKRect(icon_tx, icon_ty, icon_tx + icon_width, icon_ty + icon_height);
                        canvas.DrawImage(GetAlignmentIcon(valtext), icon_rect);
                    }
                    ty += textPaint.FontSpacing;
                }

                valtext = "";
                if (_localStatusFields[(int)NhStatusFields.BL_SCORE].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_SCORE].Text != null)
                {
                    valtext = _localStatusFields[(int)NhStatusFields.BL_SCORE].Text;
                }
                if (valtext != "")
                {
                    _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                    if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                    {
                        textPaint.DrawTextOnCanvas(canvas, "Score:", tx, ty);
                        textPaint.DrawTextOnCanvas(canvas, valtext, tx + indentation, ty);
                        icon_tx = icon_base_left + (icon_max_width - icon_width) / 2f;
                        icon_ty = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - icon_height) / 2;
                        icon_rect = new SKRect(icon_tx, icon_ty, icon_tx + icon_width, icon_ty + icon_height);
                        canvas.DrawImage(GHApp._statusScoreBitmap, icon_rect);
                    }
                    ty += textPaint.FontSpacing;
                }

                ty += textPaint.FontSpacing * 0.5f;

                valtext = "";
                if (_localStatusFields[(int)NhStatusFields.BL_AC].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_AC].Text != null)
                {
                    valtext = _localStatusFields[(int)NhStatusFields.BL_AC].Text;
                }
                if (valtext != "")
                {
                    //lock (_statusOffsetLock)
                    {
                        _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                    }
                    if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                    {
                        textPaint.DrawTextOnCanvas(canvas, "Armor class:", tx, ty);
                        textPaint.DrawTextOnCanvas(canvas, valtext, tx + indentation, ty);
                        icon_width = icon_height * (float)GHApp._statusACBitmap.Width / (float)GHApp._statusACBitmap.Height;
                        icon_tx = icon_base_left + (icon_max_width - icon_width) / 2f;
                        icon_ty = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - icon_height) / 2;
                        icon_rect = new SKRect(icon_tx, icon_ty, icon_tx + icon_width, icon_ty + icon_height);
                        canvas.DrawImage(GHApp._statusACBitmap, icon_rect);
                    }
                    ty += textPaint.FontSpacing;
                }

                valtext = "";
                valtext2 = "";
                if (_localStatusFields[(int)NhStatusFields.BL_MC_LVL].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_MC_LVL].Text != null)
                {
                    valtext = _localStatusFields[(int)NhStatusFields.BL_MC_LVL].Text;
                }
                if (_localStatusFields[(int)NhStatusFields.BL_MC_PCT].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_MC_PCT].Text != null)
                {
                    valtext2 = _localStatusFields[(int)NhStatusFields.BL_MC_PCT].Text;
                }
                if (valtext != "")
                {
                    //lock (_statusOffsetLock)
                    {
                        _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                    }
                    if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                    {
                        textPaint.DrawTextOnCanvas(canvas, "Magic cancellation:", tx, ty);
                        string printtext = valtext2 != "" ? valtext + "/" + valtext2 + "%" : valtext;
                        textPaint.DrawTextOnCanvas(canvas, printtext, tx + indentation, ty);
                        icon_width = icon_height * (float)GHApp._statusMCBitmap.Width / (float)GHApp._statusMCBitmap.Height;
                        icon_tx = icon_base_left + (icon_max_width - icon_width) / 2f;
                        icon_ty = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - icon_height) / 2;
                        icon_rect = new SKRect(icon_tx, icon_ty, icon_tx + icon_width, icon_ty + icon_height);
                        canvas.DrawImage(GHApp._statusMCBitmap, icon_rect);
                    }
                    ty += textPaint.FontSpacing;
                }

                valtext = "";
                if (_localStatusFields[(int)NhStatusFields.BL_MOVE].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_MOVE].Text != null)
                {
                    valtext = _localStatusFields[(int)NhStatusFields.BL_MOVE].Text;
                }
                if (valtext != "")
                {
                    //lock (_statusOffsetLock)
                    {
                        _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                    }
                    if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                    {
                        textPaint.DrawTextOnCanvas(canvas, "Move:", tx, ty);
                        textPaint.DrawTextOnCanvas(canvas, valtext, tx + indentation, ty);
                        icon_width = icon_height * (float)GHApp._statusMoveBitmap.Width / (float)GHApp._statusMoveBitmap.Height;
                        icon_tx = icon_base_left + (icon_max_width - icon_width) / 2f;
                        icon_ty = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - icon_height) / 2;
                        icon_rect = new SKRect(icon_tx, icon_ty, icon_tx + icon_width, icon_ty + icon_height);
                        canvas.DrawImage(GHApp._statusMoveBitmap, icon_rect);
                    }
                    ty += textPaint.FontSpacing;
                }

                valtext = "";
                valtext2 = "";
                string valtext3 = "";
                if (_localStatusFields[(int)NhStatusFields.BL_UWEP].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_UWEP].Text != null)
                {
                    valtext = _localStatusFields[(int)NhStatusFields.BL_UWEP].Text;
                }
                if (_localStatusFields[(int)NhStatusFields.BL_UWEP2].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_UWEP2].Text != null)
                {
                    valtext2 = _localStatusFields[(int)NhStatusFields.BL_UWEP2].Text;
                }
                if (_localStatusFields[(int)NhStatusFields.BL_UQUIVER].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_UQUIVER].Text != null)
                {
                    valtext3 = _localStatusFields[(int)NhStatusFields.BL_UQUIVER].Text;
                }
                if (valtext != "" || valtext2 != "" || valtext3 != "")
                {
                    //lock (_statusOffsetLock)
                    {
                        _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                    }
                    if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                    {
                        textPaint.DrawTextOnCanvas(canvas, "Weapon style:", tx, ty);
                        string printtext = valtext;
                        if (valtext2 != "")
                            printtext += "/" + valtext2;
                        if (valtext3 != "")
                            printtext += "/" + valtext3;
                        textPaint.DrawTextOnCanvas(canvas, printtext, tx + indentation, ty);
                        icon_width = icon_height * (float)GHApp._statusWeaponStyleBitmap.Width / (float)GHApp._statusWeaponStyleBitmap.Height;
                        icon_tx = icon_base_left + (icon_max_width - icon_width) / 2f;
                        icon_ty = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - icon_height) / 2;
                        icon_rect = new SKRect(icon_tx, icon_ty, icon_tx + icon_width, icon_ty + icon_height);
                        canvas.DrawImage(GHApp._statusWeaponStyleBitmap, icon_rect);
                    }
                    ty += textPaint.FontSpacing;
                }

                ty += textPaint.FontSpacing * 0.5f;

                valtext = "";
                if (_localStatusFields[(int)NhStatusFields.BL_GOLD].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_GOLD].Text != null)
                {
                    valtext = _localStatusFields[(int)NhStatusFields.BL_GOLD].Text;
                }
                if (valtext != "")
                {
                    //lock (_statusOffsetLock)
                    {
                        _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                    }
                    if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                    {
                        GHSubstring printtext = valtext.Length > 11 && valtext[0] == '\\' ? new GHSubstring(valtext, 11) : new GHSubstring(valtext);
                        textPaint.DrawTextOnCanvas(canvas, "Gold:", tx, ty);
                        textPaint.DrawTextOnCanvas(canvas, printtext.Value, tx + indentation, ty);
                        icon_width = icon_height * (float)GHApp._statusGoldBitmap.Width / (float)GHApp._statusGoldBitmap.Height;
                        icon_tx = icon_base_left + (icon_max_width - icon_width) / 2f;
                        icon_ty = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - icon_height) / 2;
                        icon_rect = new SKRect(icon_tx, icon_ty, icon_tx + icon_width, icon_ty + icon_height);
                        canvas.DrawImage(GHApp._statusGoldBitmap, icon_rect);
                    }
                    ty += textPaint.FontSpacing;
                }

                valtext = "";
                if (_localStatusFields[(int)NhStatusFields.BL_TIME].IsEnabled && _localStatusFields[(int)NhStatusFields.BL_TIME].Text != null)
                {
                    valtext = _localStatusFields[(int)NhStatusFields.BL_TIME].Text;
                }
                if (valtext != "")
                {
                    //lock (_statusOffsetLock)
                    {
                        _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                    }
                    if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                    {
                        textPaint.DrawTextOnCanvas(canvas, "Turns:", tx, ty);
                        textPaint.DrawTextOnCanvas(canvas, valtext, tx + indentation, ty);
                        icon_width = icon_height * (float)GHApp._statusTurnsBitmap.Width / (float)GHApp._statusTurnsBitmap.Height;
                        icon_tx = icon_base_left + (icon_max_width - icon_width) / 2f;
                        icon_ty = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - icon_height) / 2;
                        icon_rect = new SKRect(icon_tx, icon_ty, icon_tx + icon_width, icon_ty + icon_height);
                        canvas.DrawImage(GHApp._statusTurnsBitmap, icon_rect);
                    }
                    ty += textPaint.FontSpacing;
                }

                ty += textPaint.FontSpacing * 0.5f;

                /* Condition, status and buff marks */
                if (use_two_columns)
                {
                    tx += indentation * 1.75f;
                    ty = base_ty;
                }

                float marksize = textPaint.FontSpacing * 0.85f;
                float markpadding = marksize / 4;
                if (_local_u_status_bits != 0)
                {
                    int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                    foreach (int status_mark in _statusmarkorder)
                    {
                        ulong statusbit = 1UL << status_mark;
                        if ((_local_u_status_bits & statusbit) != 0)
                        {
                            string statusname = _status_names[status_mark];
                            int mglyph = (int)game_ui_tile_types.STATUS_MARKS + status_mark / GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS + GHApp.UITileOff;
                            int mtile = GHApp.Glyph2Tile[mglyph];
                            int sheet_idx = GHApp.TileSheetIdx(mtile);
                            int tile_x = GHApp.TileSheetX(mtile);
                            int tile_y = GHApp.TileSheetY(mtile);
                            int within_tile_x = (status_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) % tiles_per_row;
                            int within_tile_y = (status_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) / tiles_per_row;
                            int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                            int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                            SKRect source_rt = new SKRect();
                            source_rt.Left = c_x;
                            source_rt.Right = c_x + GHConstants.StatusMarkWidth;
                            source_rt.Top = c_y;
                            source_rt.Bottom = c_y + GHConstants.StatusMarkHeight;

                            SKRect target_rt = new SKRect();
                            target_rt.Left = tx;
                            target_rt.Right = target_rt.Left + marksize;
                            target_rt.Top = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - marksize) / 2;
                            target_rt.Bottom = target_rt.Top + marksize;

                            if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                            {
                                GHApp.MaybeFixRects(ref source_rt, ref target_rt, 1.0f, usingGL, fixRects);
                                canvas.DrawImage(TileMap[sheet_idx], source_rt, target_rt);
                                textPaint.DrawTextOnCanvas(canvas, statusname, tx + marksize + markpadding, ty);
                            }
                            //lock (_statusOffsetLock)
                            {
                                _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                            }
                            ty += textPaint.FontSpacing;
                        }
                    }
                }

                if (_local_u_condition_bits != 0)
                {
                    int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                    for (int condition_mark = 0; condition_mark < (int)bl_conditions.NUM_BL_CONDITIONS; condition_mark++)
                    {
                        ulong conditionbit = 1UL << condition_mark;
                        if ((_local_u_condition_bits & conditionbit) != 0)
                        {
                            string conditionname = _condition_names[condition_mark];
                            int mglyph = (int)game_ui_tile_types.CONDITION_MARKS + condition_mark / GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS + GHApp.UITileOff;
                            int mtile = GHApp.Glyph2Tile[mglyph];
                            int sheet_idx = GHApp.TileSheetIdx(mtile);
                            int tile_x = GHApp.TileSheetX(mtile);
                            int tile_y = GHApp.TileSheetY(mtile);
                            int within_tile_x = (condition_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) % tiles_per_row;
                            int within_tile_y = (condition_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) / tiles_per_row;
                            int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                            int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                            SKRect source_rt = new SKRect();
                            source_rt.Left = c_x;
                            source_rt.Right = c_x + GHConstants.StatusMarkWidth;
                            source_rt.Top = c_y;
                            source_rt.Bottom = c_y + GHConstants.StatusMarkHeight;

                            SKRect target_rt = new SKRect();
                            target_rt.Left = tx;
                            target_rt.Right = target_rt.Left + marksize;
                            target_rt.Top = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - marksize) / 2;
                            target_rt.Bottom = target_rt.Top + marksize;

                            if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                            {
                                GHApp.MaybeFixRects(ref source_rt, ref target_rt, 1.0f, usingGL, fixRects);
                                canvas.DrawImage(TileMap[sheet_idx], source_rt, target_rt);
                                textPaint.DrawTextOnCanvas(canvas, conditionname, tx + marksize + markpadding, ty);
                            }
                            //lock (_statusOffsetLock)
                            {
                                _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                            }
                            ty += textPaint.FontSpacing;
                        }
                    }
                }

                ulong buff_bits;
                for (int buff_ulong = 0; buff_ulong < GHConstants.NUM_BUFF_BIT_ULONGS; buff_ulong++)
                {
                    buff_bits = _local_u_buff_bits[buff_ulong];
                    int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                    if (buff_bits != 0)
                    {
                        for (int buff_idx = 0; buff_idx < 32; buff_idx++)
                        {
                            ulong buffbit = 1UL << buff_idx;
                            if ((buff_bits & buffbit) != 0)
                            {
                                int propidx = buff_ulong * 32 + buff_idx;
                                if (propidx > GHConstants.LAST_PROP)
                                    break;
                                string propname = GHApp.GnollHackService.GetPropertyName(propidx);
                                if (propname != null && propname.Length > 0)
                                    propname = propname[0].ToString().ToUpper() + (propname.Length == 1 ? "" : propname.Substring(1));

                                int mglyph = (propidx - 1) / GHConstants.BUFFS_PER_TILE + GHApp.BuffTileOff;
                                int mtile = GHApp.Glyph2Tile[mglyph];
                                int sheet_idx = GHApp.TileSheetIdx(mtile);
                                int tile_x = GHApp.TileSheetX(mtile);
                                int tile_y = GHApp.TileSheetY(mtile);

                                int buff_mark = (propidx - 1) % GHConstants.BUFFS_PER_TILE;
                                int within_tile_x = buff_mark % tiles_per_row;
                                int within_tile_y = buff_mark / tiles_per_row;
                                int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                                int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                                SKRect source_rt = new SKRect();
                                source_rt.Left = c_x;
                                source_rt.Right = c_x + GHConstants.StatusMarkWidth;
                                source_rt.Top = c_y;
                                source_rt.Bottom = c_y + GHConstants.StatusMarkHeight;

                                SKRect target_rt = new SKRect();
                                target_rt.Left = tx;
                                target_rt.Right = target_rt.Left + marksize;
                                target_rt.Top = ty + textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent / 2 + (textPaint.FontSpacing - marksize) / 2;
                                target_rt.Bottom = target_rt.Top + marksize;

                                if (ty <= box_bottom_draw_threshold && ty >= box_top_draw_threshold)
                                {
                                    GHApp.MaybeFixRects(ref source_rt, ref target_rt, 1.0f, usingGL, fixRects);
                                    canvas.DrawImage(TileMap[sheet_idx], source_rt, target_rt);
                                    if (propname != null)
                                        textPaint.DrawTextOnCanvas(canvas, propname, tx + marksize + markpadding, ty);
                                }
                                //lock (_statusOffsetLock)
                                {
                                    _localStatusLargestBottom = Math.Max(_localStatusLargestBottom, ty + textPaint.FontMetrics.Descent);
                                }
                                ty += textPaint.FontSpacing;
                            }
                        }
                    }
                }
            }
        }

        bool DarkenedPos(int mapx, int mapy)
        {
            bool darken;
            if (_mapData[mapx, mapy].Layers.layer_gui_glyphs != null
                && (_mapData[mapx, mapy].Layers.layer_gui_glyphs[(int)layer_types.LAYER_FLOOR] == GHApp.UnexploredGlyph
                    || _mapData[mapx, mapy].Layers.layer_gui_glyphs[(int)layer_types.LAYER_FLOOR] == GHApp.NoGlyph)
                )
            {
                darken = false;
            }
            else
            {
                bool showing_detection = (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_SHOWING_DETECTION) != 0;
                darken = (!showing_detection && (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_CAN_SEE) == 0);
            }
            return darken;
        }

        int GetDarkenPercentage(int mapx, int mapy, bool lighter_darkening)
        {
            bool uloc = ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_UXUY) != 0);
            bool unlit = ((_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_APPEARS_UNLIT) != 0);
            // Get values from XAML controls
            int darken_percentage = lighter_darkening ? (uloc ? 90 : unlit ? 65 : 80) : (uloc ? 85 : unlit ? 40 : 65);
            return darken_percentage;
        }

        void DoDarkening(SKCanvas canvas, SKPaint paint, float tx, float ty, float width, float height, int darken_percentage)
        {
            int val = (darken_percentage * 255) / 100;
            SKColor color = new SKColor((byte)val, (byte)val, (byte)val);
            paint.Color = color;
            SKBlendMode old_bm = paint.BlendMode;
            paint.BlendMode = SKBlendMode.Modulate;
            SKRect targetrect = new SKRect(tx, ty, tx + width, ty + height);
            canvas.DrawRect(targetrect, paint);
            paint.BlendMode = old_bm;
        }

        private bool IsNoWallEndAutoDraw(int x, int y)
        {
            if (!GHUtils.isok(x, y))
                return true;

            if (_mapData[x, y].Layers.layer_gui_glyphs[(int)layer_types.LAYER_FLOOR] == GHApp.UnexploredGlyph
                || _mapData[x, y].Layers.layer_gui_glyphs[(int)layer_types.LAYER_FLOOR] == GHApp.NoGlyph)
                return true;

            if ((_mapData[x, y].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_NO_WALL_END_AUTODRAW) != 0)
                return true;

            return false;
        }

        struct SavedDarkenedAutodrawBitmap
        {
            AutoDrawParameterDefinition AutodrawParameters;
            float DarkenPercentage;
            public SavedDarkenedAutodrawBitmap(AutoDrawParameterDefinition autodrawParameters, float darkenPercentage)
            {
                AutodrawParameters = autodrawParameters;
                DarkenPercentage = darkenPercentage;
            }
        }

        struct SavedDarkenedBitmap
        {
            SKImage Bitmap;
            SKRect SourceRect;
            float DarkenPercentage;
            public SavedDarkenedBitmap(SKImage bitmap, SKRect skrect, float darkenPercentage)
            {
                Bitmap = bitmap;
                SourceRect = skrect;
                DarkenPercentage = darkenPercentage;
            }
        }

        struct SavedAutodrawBitmap
        {
            public int Autodraw;
            public double FillPercentage;
            public int Stage;

            public SavedAutodrawBitmap(int autodraw, double fillPercentage, int stage)
            {
                Autodraw = autodraw;
                FillPercentage = fillPercentage;
                Stage = stage;
            }
        }

        //private readonly object _saveAutoDrawLock = new object();
        Dictionary<SavedAutodrawBitmap, SKBitmap> _savedAutoDrawBitmaps = new Dictionary<SavedAutodrawBitmap, SKBitmap>();

        public void DrawAutoDraw(int autodraw, SKCanvas canvas, bool delayedDraw, SKPaint paint, ObjectDataItem otmp_round,
            int layer_idx, int mapx, int mapy,
            bool tileflag_halfsize, bool tileflag_normalobjmissile, bool tileflag_fullsizeditem,
            float tx, float ty, float width, float height,
            float scale, float targetscale, float scaled_x_padding, float scaled_y_padding, float scaled_tile_height,
            bool is_inventory, bool drawwallends, bool usingGL, bool highFilterQuality, bool fixRects)
        {
            if (delayedDraw)
            {
                ulong contents_no = 0;
                ulong contents_id_sum = 0;
                int item_charges = 0;
                int item_special_quality = 0;
                bool item_lit = false;
                if (otmp_round != null)
                {
                    item_charges = otmp_round.ObjData.charges;
                    item_special_quality = otmp_round.ObjData.special_quality;
                    item_lit = otmp_round.LampLit;
                    if(otmp_round.HasContainedObjs)
                    {
                        foreach (ObjectDataItem otmp in otmp_round.ContainedObjsEnumerable)
                        {
                            if (otmp != null)
                            {
                                contents_no++;
                                contents_id_sum += otmp.ObjData.o_id;
                            }
                        }
                    }
                }
                _drawCommandList.Add(new GHDrawCommand(canvas.TotalMatrix, paint.Color, paint.ColorFilter, mapx, mapy, new AutoDrawParameterDefinition(autodraw, otmp_round, layer_idx, 
                     tileflag_halfsize, tileflag_normalobjmissile, tileflag_fullsizeditem,
                     tx, ty, width, height, scale, targetscale, scaled_x_padding, scaled_y_padding, scaled_tile_height,
                     is_inventory, drawwallends, contents_no, contents_id_sum, item_charges, item_special_quality, item_lit)));
                return;
            }

            /******************/
            /* AUTODRAW START */
            /******************/
            if (GHApp._autodraws != null)
            {
                float opaqueness = 1;
                int sheet_idx = 0;
                float extra_y_padding = 0;
                if (!is_inventory)
                {
                    if (tileflag_normalobjmissile)
                    {
                        if (!tileflag_fullsizeditem)
                            extra_y_padding += (height - scaled_tile_height) / 2;
                    }
                    else if (tileflag_halfsize)
                    {
                        extra_y_padding += height / 2;
                    }
                }

                if (drawwallends && GHApp._autodraws[autodraw].draw_type == (int)autodraw_drawing_types.AUTODRAW_DRAW_REPLACE_WALL_ENDS)
                {
                    for (byte dir = 0; dir < 4; dir++)
                    {
                        byte dir_bit = (byte)(1 << dir);
                        if ((GHApp._autodraws[autodraw].flags & dir_bit) != 0)
                        {
                            int rx = 0;
                            int ry = 0;
                            int[] corner_x = new int[2];
                            int[] corner_y = new int[2];
                            switch (dir)
                            {
                                case 0:
                                    rx = mapx - 1;
                                    ry = mapy;
                                    corner_x[0] = mapx;
                                    corner_y[0] = mapy - 1;
                                    corner_x[1] = mapx;
                                    corner_y[1] = mapy + 1;
                                    break;
                                case 1:
                                    rx = mapx + 1;
                                    ry = mapy;
                                    corner_x[0] = mapx;
                                    corner_y[0] = mapy - 1;
                                    corner_x[1] = mapx;
                                    corner_y[1] = mapy + 1;
                                    break;
                                case 2:
                                    rx = mapx;
                                    ry = mapy - 1;
                                    corner_x[0] = mapx - 1;
                                    corner_y[0] = mapy;
                                    corner_x[1] = mapx + 1;
                                    corner_y[1] = mapy;
                                    break;
                                case 3:
                                    rx = mapx;
                                    ry = mapy + 1;
                                    corner_x[0] = mapx - 1;
                                    corner_y[0] = mapy;
                                    corner_x[1] = mapx + 1;
                                    corner_y[1] = mapy;
                                    break;
                                default:
                                    break;
                            }

                            if (IsNoWallEndAutoDraw(rx, ry)) // NO_WALL_END_AUTODRAW(rx, ry))
                            {
                                /* No action */
                            }
                            else
                            {
                                for (int corner = 0; corner <= 1; corner++)
                                {
                                    int source_glyph = GHApp._autodraws[autodraw].source_glyph;
                                    int atile = GHApp.Glyph2Tile[source_glyph];
                                    int a_sheet_idx = GHApp.TileSheetIdx(atile);
                                    int at_x = GHApp.TileSheetX(atile);
                                    int at_y = GHApp.TileSheetY(atile);

                                    SKRect source_rt = new SKRect();
                                    switch (dir)
                                    {
                                        case 0: /* left */
                                            if (IsNoWallEndAutoDraw(corner_x[corner], corner_y[corner])) // NO_WALL_END_AUTODRAW(corner_x[corner], corner_y[corner]))
                                            {
                                                source_glyph = GHApp._autodraws[autodraw].source_glyph2; /* S_vwall */
                                                atile = GHApp.Glyph2Tile[source_glyph];
                                                a_sheet_idx = GHApp.TileSheetIdx(atile);
                                                at_x = GHApp.TileSheetX(atile);
                                                at_y = GHApp.TileSheetY(atile);
                                            }
                                            source_rt.Left = at_x;
                                            source_rt.Right = source_rt.Left + 12;
                                            if (corner == 0)
                                            {
                                                source_rt.Top = at_y;
                                                source_rt.Bottom = at_y + 18;
                                            }
                                            else
                                            {
                                                source_rt.Top = at_y + 18;
                                                source_rt.Bottom = at_y + GHConstants.TileHeight;
                                            }
                                            break;
                                        case 1: /* right */
                                            //if (NO_WALL_END_AUTODRAW(corner_x[corner], corner_y[corner]))
                                            if (IsNoWallEndAutoDraw(corner_x[corner], corner_y[corner]))
                                            {
                                                source_glyph = GHApp._autodraws[autodraw].source_glyph2; /* S_vwall */
                                                atile = GHApp.Glyph2Tile[source_glyph];
                                                a_sheet_idx = GHApp.TileSheetIdx(atile);
                                                at_x = GHApp.TileSheetX(atile);
                                                at_y = GHApp.TileSheetY(atile);
                                            }
                                            source_rt.Right = at_x + GHConstants.TileWidth;
                                            source_rt.Left = source_rt.Right - 12;
                                            if (corner == 0)
                                            {
                                                source_rt.Top = at_y;
                                                source_rt.Bottom = at_y + 18;
                                            }
                                            else
                                            {
                                                source_rt.Top = at_y + 18;
                                                source_rt.Bottom = at_y + GHConstants.TileHeight;
                                            }
                                            break;
                                        case 2: /* up */
                                            //if (NO_WALL_END_AUTODRAW(corner_x[corner], corner_y[corner]))
                                            if (IsNoWallEndAutoDraw(corner_x[corner], corner_y[corner]))
                                            {
                                                source_glyph = GHApp._autodraws[autodraw].source_glyph3; /* S_hwall */
                                                atile = GHApp.Glyph2Tile[source_glyph];
                                                a_sheet_idx = GHApp.TileSheetIdx(atile);
                                                at_x = GHApp.TileSheetX(atile);
                                                at_y = GHApp.TileSheetY(atile);
                                            }
                                            if (corner == 0)
                                            {
                                                source_rt.Left = at_x;
                                                source_rt.Right = at_x + GHConstants.TileWidth / 2;
                                            }
                                            else
                                            {
                                                source_rt.Left = at_x + GHConstants.TileWidth / 2;
                                                source_rt.Right = at_x + GHConstants.TileWidth;
                                            }
                                            source_rt.Top = at_y;
                                            source_rt.Bottom = source_rt.Top + 12;
                                            break;
                                        case 3: /* down */
                                            //if (NO_WALL_END_AUTODRAW(corner_x[corner], corner_y[corner]))
                                            if (IsNoWallEndAutoDraw(corner_x[corner], corner_y[corner]))
                                            {
                                                source_glyph = GHApp._autodraws[autodraw].source_glyph3; /* S_hwall */
                                                atile = GHApp.Glyph2Tile[source_glyph];
                                                a_sheet_idx = GHApp.TileSheetIdx(atile);
                                                at_x = GHApp.TileSheetX(atile);
                                                at_y = GHApp.TileSheetY(atile);
                                            }
                                            if (corner == 0)
                                            {
                                                source_rt.Left = at_x;
                                                source_rt.Right = at_x + GHConstants.TileWidth / 2;
                                            }
                                            else
                                            {
                                                source_rt.Left = at_x + GHConstants.TileWidth / 2;
                                                source_rt.Right = at_x + GHConstants.TileWidth;
                                            }
                                            source_rt.Top = at_y + 12;
                                            source_rt.Bottom = at_y + GHConstants.TileHeight;
                                            break;
                                        default:
                                            break;
                                    }

                                    SKRect target_rt = new SKRect();
                                    target_rt.Left = tx + (targetscale * (float)(source_rt.Left - at_x));
                                    target_rt.Right = tx + (targetscale * (float)(source_rt.Right - at_x));
                                    target_rt.Top = ty + (targetscale * (float)(source_rt.Top - at_y));
                                    target_rt.Bottom = ty + (targetscale * (float)(source_rt.Bottom - at_y));
#if GNH_MAP_PROFILING && DEBUG
                                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                                    GHApp.MaybeFixRects(ref source_rt, ref target_rt, targetscale, usingGL, fixRects);
                                    canvas.DrawImage(TileMap[a_sheet_idx], source_rt, target_rt,
#if GNH_MAUI
                                        new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest),
#endif
                                        paint);
#if GNH_MAP_PROFILING && DEBUG
                                    StopProfiling(GHProfilingStyle.Bitmap);
#endif
                                }
                            }
                        }
                    }
                }
                else if (
                    ((GHApp._autodraws[autodraw].draw_type == (int)autodraw_drawing_types.AUTODRAW_DRAW_CHAIN || GHApp._autodraws[autodraw].draw_type == (int)autodraw_drawing_types.AUTODRAW_DRAW_BALL) 
                      && (otmp_round == null || otmp_round.OtypData.is_uchain != 0 || otmp_round.OtypData.is_uball != 0) /* Currently a small kludge to ensure that the autodraw applies only to uchain and uball */
                    )
                    /*|| autodraw_u_punished*/)
                {
                    DrawChain(canvas, paint, mapx, mapy, autodraw, false, width, height, ty, tx, scale, targetscale, usingGL, highFilterQuality, fixRects);
                }
                else if (GHApp._autodraws[autodraw].draw_type == (int)autodraw_drawing_types.AUTODRAW_DRAW_LONG_WORM)
                {
                    /* Long worm here */

                    int source_glyph_seg_end = GHApp._autodraws[autodraw].source_glyph;
                    int source_glyph_seg_dir_out = GHApp._autodraws[autodraw].source_glyph2;
                    int source_glyph_seg_dir_in = GHApp._autodraws[autodraw].source_glyph2 + 4;
                    int source_glyph_seg_layer = GHApp._autodraws[autodraw].source_glyph3;
                    int drawing_tail = GHApp._autodraws[autodraw].flags;
                    int wdir_out = _mapData[mapx, mapy].Layers.wsegdir;
                    int wdir_in = _mapData[mapx, mapy].Layers.reverse_prev_wsegdir;
                    bool is_head = (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_WORM_HEAD) != 0;
                    bool is_tailend = (_mapData[mapx, mapy].Layers.monster_flags & (ulong)LayerMonsterFlags.LMFLAGS_WORM_TAILEND) != 0;
                    for (int wlayer = 0; wlayer < 5; wlayer++)
                    {
                        int source_glyph = GHApp.NoGlyph;
                        bool hflip_seg = false;
                        bool vflip_seg = false;
                        switch (wlayer)
                        {
                            case 0:
                            case 2:
                            case 4:
                                if (is_head || is_tailend)
                                    continue;
                                source_glyph = source_glyph_seg_layer + wlayer / 2;
                                break;
                            case 1:
                                source_glyph = is_tailend ? GHApp.NoGlyph : is_head ? source_glyph_seg_end : source_glyph_seg_dir_in;
                                break;
                            case 3:
                                source_glyph = is_tailend ? source_glyph_seg_end : is_head ? GHApp.NoGlyph : source_glyph_seg_dir_out;
                                break;
                            default:
                                break;
                        }

                        if (source_glyph != GHApp.NoGlyph)
                        {
                            int wdir = (wlayer == 1 ? wdir_in : wlayer == 3 ? wdir_out : 0);
                            switch (wdir)
                            {
                                case 1:
                                    source_glyph += 2;
                                    hflip_seg = false;
                                    vflip_seg = false;
                                    break;
                                case 2:
                                    source_glyph += 0;
                                    hflip_seg = false;
                                    vflip_seg = false;
                                    break;
                                case 3:
                                    source_glyph += 3;
                                    hflip_seg = false;
                                    vflip_seg = true;
                                    break;
                                case 4:
                                    source_glyph += 1;
                                    hflip_seg = true;
                                    vflip_seg = false;
                                    break;
                                case 5:
                                    source_glyph += 3;
                                    hflip_seg = false;
                                    vflip_seg = false;
                                    break;
                                case 6:
                                    source_glyph += 0;
                                    hflip_seg = false;
                                    vflip_seg = true;
                                    break;
                                case 7:
                                    source_glyph += 2;
                                    hflip_seg = false;
                                    vflip_seg = true;
                                    break;
                                case 8:
                                    source_glyph += 1;
                                    hflip_seg = false;
                                    vflip_seg = false;
                                    break;
                                default:
                                    break;
                            }

                            int atile = GHApp.Glyph2Tile[source_glyph];
                            int a_sheet_idx = GHApp.TileSheetIdx(atile);
                            int at_x = GHApp.TileSheetX(atile);
                            int at_y = GHApp.TileSheetY(atile);

                            int worm_source_x = at_x;
                            int worm_source_y = at_y;
                            int worm_source_width = GHConstants.TileWidth;
                            int worm_source_height = GHConstants.TileHeight;
                            SKRect sourcerect = new SKRect(worm_source_x, worm_source_y, worm_source_x + worm_source_width, worm_source_y + worm_source_height);

                            float target_x = tx;
                            float target_y = ty;
                            float target_width = ((float)worm_source_width * targetscale);
                            float target_height = ((float)worm_source_height * targetscale);
                            SKRect targetrect;
                            targetrect = new SKRect(0, 0, target_width, target_height);

                            using (new SKAutoCanvasRestore(canvas, true))
                            {
                                canvas.Translate(target_x + (hflip_seg ? width : 0), target_y + (vflip_seg ? height : 0));
                                canvas.Scale(hflip_seg ? -1 : 1, vflip_seg ? -1 : 1, 0, 0);
                                paint.Color = paint.Color.WithAlpha((byte)(0xFF * opaqueness));
                                GHApp.MaybeFixRects(ref sourcerect, ref targetrect, targetscale, usingGL, fixRects);
                                canvas.DrawImage(TileMap[sheet_idx], sourcerect, targetrect,
#if GNH_MAUI
                                    new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest),
#endif
                                    paint);
                            }
                        }
                    }
                }
                else if (GHApp._autodraws[autodraw].draw_type == (int)autodraw_drawing_types.AUTODRAW_DRAW_BOOKSHELF_CONTENTS && otmp_round != null && otmp_round.HasContainedObjs)
                {
                    int num_shelves = 4;
                    int y_to_first_shelf = 49;
                    int shelf_start = 8;
                    int shelf_width = 50;
                    int shelf_height = 10;
                    int shelf_border_height = 2;
                    int shelf_item_width = 5;
                    int src_book_x = 0;
                    int src_book_y = 0;
                    int src_scroll_x = 5;
                    int src_scroll_y = 0;
                    int cnt = 0;
                    int items_per_row = shelf_width / shelf_item_width;
                    foreach (ObjectDataItem contained_obj in otmp_round.ContainedObjsEnumerable)
                    {
                        int src_x = 0, src_y = 0;
                        float dest_x = 0, dest_y = 0;
                        if (contained_obj.ObjData.oclass == (int)obj_class_types.SPBOOK_CLASS)
                        {
                            src_x = src_book_x;
                            src_y = src_book_y;
                        }
                        else if (contained_obj.ObjData.oclass == (int)obj_class_types.SCROLL_CLASS)
                        {
                            src_x = src_scroll_x;
                            src_y = src_scroll_y;
                        }
                        else
                            continue;

                        for (int item_idx = 0; item_idx < contained_obj.ObjData.quan; item_idx++)
                        {
                            int item_row = cnt / items_per_row;
                            int item_xpos = cnt % items_per_row;

                            if (item_row >= num_shelves)
                                break;

                            dest_y = (y_to_first_shelf + item_row * (shelf_height + shelf_border_height)) * scale * targetscale;
                            dest_x = (shelf_start + item_xpos * shelf_item_width) * scale * targetscale;

                            int source_glyph = GHApp._autodraws[autodraw].source_glyph;
                            int atile = GHApp.Glyph2Tile[source_glyph];
                            int a_sheet_idx = GHApp.TileSheetIdx(atile);
                            int at_x = GHApp.TileSheetX(atile);
                            int at_y = GHApp.TileSheetY(atile);

                            SKRect source_rt = new SKRect();
                            source_rt.Left = at_x + src_x;
                            source_rt.Right = source_rt.Left + shelf_item_width;
                            source_rt.Top = at_y + src_y;
                            source_rt.Bottom = source_rt.Top + shelf_height;

                            float target_x = tx + dest_x;
                            float target_y = ty + dest_y;
                            float target_width = targetscale * scale * source_rt.Width;
                            float target_height = targetscale * scale * source_rt.Height;
                            SKRect target_rt;
                            target_rt = new SKRect(0, 0, target_width, target_height);

                            using (new SKAutoCanvasRestore(canvas, true))
                            {
                                canvas.Translate(target_x, target_y);
                                canvas.Scale(1, 1, 0, 0);
                                paint.Color = paint.Color.WithAlpha((byte)(0xFF * opaqueness));
                                GHApp.MaybeFixRects(ref source_rt, ref target_rt, targetscale, usingGL, fixRects);
                                canvas.DrawImage(TileMap[a_sheet_idx], source_rt, target_rt,
#if GNH_MAUI
                                    new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest),
#endif
                                    paint);
                            }
                            cnt++;
                        }
                    }
                }
                else if (GHApp._autodraws[autodraw].draw_type == (int)autodraw_drawing_types.AUTODRAW_DRAW_WEAPON_RACK_CONTENTS && otmp_round != null && otmp_round.HasContainedObjs)
                {
                    int y_to_rack_top = 31;
                    int rack_start = 0; /* Assume weapons are drawn reasonably well in the center */
                    int rack_width = 48;
                    int rack_height = GHConstants.TileHeight - y_to_rack_top;
                    int rack_item_spacing = 6;
                    int cnt = 0;
                    foreach (ObjectDataItem contained_obj in otmp_round.ContainedObjsEnumerable)
                    {
                        int source_glyph = Math.Abs(contained_obj.ObjData.gui_glyph);
                        if (source_glyph <= 0 || source_glyph == GHApp.NoGlyph)
                            continue;
                        bool has_floor_tile = (GHApp.GlyphTileFlags[source_glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_HAS_FLOOR_TILE) != 0; // artidx > 0 ? has_artifact_floor_tile(artidx) : has_obj_floor_tile(contained_obj);
                        bool is_height_clipping = (GHApp.GlyphTileFlags[source_glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_HEIGHT_IS_CLIPPING) != 0;
                        bool fullsizeditem = (GHApp.GlyphTileFlags[source_glyph] & (byte)glyph_tile_flags.GLYPH_TILE_FLAG_FULL_SIZED_ITEM) != 0;
                        int cobj_height = contained_obj.OtypData.tile_height; // artidx ? artilist[artidx].tile_floor_height : OBJ_TILE_HEIGHT(contained_obj->otyp);
                        int artidx = contained_obj.ObjData.oartifact;
                        float dest_x = 0, dest_y = 0;
                        int src_x = 0, src_y = fullsizeditem || has_floor_tile ? 0 : GHConstants.TileHeight / 2;
                        int item_width = has_floor_tile || is_height_clipping ? GHConstants.TileHeight / 2 : cobj_height > 0 ? cobj_height : GHConstants.TileHeight / 2;
                        int item_height = has_floor_tile || is_height_clipping ? GHConstants.TileWidth : (item_width * GHConstants.TileWidth) / (GHConstants.TileHeight / 2);
                        int padding = (GHConstants.TileHeight / 2 - item_width) / 2;
                        int vertical_padding = (GHConstants.TileWidth - item_height) / 2;
                        if (contained_obj.ObjData.oclass != (int)obj_class_types.WEAPON_CLASS)
                            continue;

                        int item_xpos = cnt / 2 * rack_item_spacing;
                        if (item_xpos >= rack_width / 2)
                            break;

                        dest_y = (y_to_rack_top + vertical_padding) * scale * targetscale;
                        dest_x = (cnt % 2 == 0 ? rack_start + item_xpos + padding : GHConstants.TileWidth - item_width - rack_start - item_xpos - padding) * scale * targetscale;

                        int atile = GHApp.Glyph2Tile[source_glyph];
                        int a_sheet_idx = GHApp.TileSheetIdx(atile);
                        int at_x = GHApp.TileSheetX(atile);
                        int at_y = GHApp.TileSheetY(atile);

                        SKRect source_rt = new SKRect();
                        source_rt.Left = at_x + src_x;
                        source_rt.Right = source_rt.Left + GHConstants.TileWidth;
                        source_rt.Top = at_y + src_y;
                        source_rt.Bottom = source_rt.Top + (fullsizeditem ? GHConstants.TileHeight : GHConstants.TileHeight / 2);

                        float original_width = source_rt.Right - source_rt.Left;
                        float original_height = source_rt.Bottom - source_rt.Top;
                        float rotated_width = original_height;
                        float rotated_height = original_width;

                        float content_scale = fullsizeditem || has_floor_tile || is_height_clipping ? 1.0f : item_width / 48.0f;

                        float target_x = tx + dest_x;
                        float target_y = ty + dest_y;
                        float target_width = targetscale * scale * content_scale * original_width; //(float)item_width;
                        float target_height = targetscale * scale * content_scale * original_height; //((float)item_width * rotated_height) / rotated_width;
                        SKRect target_rt;
                        target_rt = new SKRect(0, 0, target_width, target_height);

                        using (new SKAutoCanvasRestore(canvas, true))
                        {
                            canvas.Translate(target_x, target_y);
                            canvas.Scale(1, 1, 0, 0);
                            canvas.RotateDegrees(-90);
                            canvas.Translate(-target_width, 0);
                            paint.Color = paint.Color.WithAlpha((byte)(0xFF * opaqueness));
                            GHApp.MaybeFixRects(ref source_rt, ref target_rt, targetscale, usingGL, fixRects);
                            canvas.DrawImage(TileMap[a_sheet_idx], source_rt, target_rt,
#if GNH_MAUI
                                new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest),
#endif
                                paint);
                        }
                        cnt++;
                    }
                }
                else if (GHApp._autodraws[autodraw].draw_type == (int)autodraw_drawing_types.AUTODRAW_DRAW_CANDELABRUM_CANDLES && (otmp_round != null || layer_idx == (int)layer_types.LAYER_MISSILE))
                {
                    float y_start = scaled_y_padding + extra_y_padding;
                    float x_start = scaled_x_padding;
                    int x_padding = 13;
                    int item_width = 6;
                    int item_height = 13;
                    int src_unlit_x = 0;
                    int src_unlit_y = 10;
                    int src_lit_x = 6 * (1 + (int)GHApp._autodraws[autodraw].flags);
                    int src_lit_y = 10;
                    short missile_special_quality = _mapData[mapx, mapy].Layers.missile_special_quality;
                    bool missile_lamplit = (_mapData[mapx, mapy].Layers.missile_flags & (ulong)LayerMissileFlags.MISSILE_FLAGS_LIT) != 0;

                    for (int cidx = 0; cidx < Math.Min((short)7, otmp_round != null ? otmp_round.ObjData.special_quality : missile_special_quality); cidx++)
                    {
                        int src_x = 0, src_y = 0;
                        float dest_x = 0, dest_y = 0;
                        if (otmp_round != null ? otmp_round.LampLit : missile_lamplit)
                        {
                            src_x = src_lit_x;
                            src_y = src_lit_y;
                        }
                        else
                        {
                            src_x = src_unlit_x;
                            src_y = src_unlit_y;
                        }

                        int item_xpos = cidx;

                        dest_y = y_start;
                        dest_x = x_start + ((float)(x_padding + item_xpos * item_width) * scale * targetscale);

                        int source_glyph = GHApp._autodraws[autodraw].source_glyph;
                        int atile = GHApp.Glyph2Tile[source_glyph];
                        int a_sheet_idx = GHApp.TileSheetIdx(atile);
                        int at_x = GHApp.TileSheetX(atile);
                        int at_y = GHApp.TileSheetY(atile);

                        SKRect source_rt = new SKRect();
                        source_rt.Left = at_x + src_x;
                        source_rt.Right = source_rt.Left + item_width;
                        source_rt.Top = at_y + src_y;
                        source_rt.Bottom = source_rt.Top + item_height;

                        float target_x = tx + dest_x;
                        float target_y = ty + dest_y;
                        float target_width = targetscale * scale * source_rt.Width;
                        float target_height = targetscale * scale * source_rt.Height;
                        SKRect target_rt;
                        target_rt = new SKRect(0, 0, target_width, target_height);

                        using (new SKAutoCanvasRestore(canvas, true))
                        {
                            canvas.Translate(target_x, target_y);
                            canvas.Scale(1, 1, 0, 0);
                            paint.Color = paint.Color.WithAlpha((byte)(0xFF * opaqueness));
                            GHApp.MaybeFixRects(ref source_rt, ref target_rt, targetscale, usingGL, fixRects);
                            canvas.DrawImage(TileMap[a_sheet_idx], source_rt, target_rt,
#if GNH_MAUI
                                new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest),
#endif
                                paint);
                        }
                    }
                }
                else if (GHApp._autodraws[autodraw].draw_type == (int)autodraw_drawing_types.AUTODRAW_DRAW_LARGE_FIVE_BRANCHED_CANDELABRUM_CANDLES && (otmp_round != null || layer_idx == (int)layer_types.LAYER_MISSILE))
                {
                    float y_start = scaled_y_padding;
                    float x_start = scaled_x_padding;
                    int item_width = 9;
                    int item_height = 31;
                    int src_unlit_x = 0;
                    int src_unlit_y = 0;
                    int src_lit_x = 9 * (1 + (int)GHApp._autodraws[autodraw].flags);
                    int src_lit_y = 0;
                    int cnt = 0;
                    short missile_special_quality = _mapData[mapx, mapy].Layers.missile_special_quality;
                    bool missile_lamplit = (_mapData[mapx, mapy].Layers.missile_flags & (ulong)LayerMissileFlags.MISSILE_FLAGS_LIT) != 0;

                    for (int cidx = 0; cidx < (otmp_round != null ? Math.Min((short)otmp_round.OtypData.special_quality, otmp_round.ObjData.special_quality) : missile_special_quality); cidx++)
                    {
                        int src_x = 0, src_y = 0;
                        float dest_x = 0, dest_y = 0;
                        if (otmp_round != null ? otmp_round.LampLit : missile_lamplit)
                        {
                            src_x = src_lit_x;
                            src_y = src_lit_y;
                        }
                        else
                        {
                            src_x = src_unlit_x;
                            src_y = src_unlit_y;
                        }

                        switch (cidx)
                        {
                            case 0:
                                dest_x = x_start + ((float)(29) * scale * targetscale);
                                dest_y = y_start + ((float)(0) * scale * targetscale);
                                break;
                            case 1:
                                dest_x = x_start + ((float)(18) * scale * targetscale);
                                dest_y = y_start + ((float)(4) * scale * targetscale);
                                break;
                            case 2:
                                dest_x = x_start + ((float)(40) * scale * targetscale);
                                dest_y = y_start + ((float)(3) * scale * targetscale);
                                break;
                            case 3:
                                dest_x = x_start + ((float)(8) * scale * targetscale);
                                dest_y = y_start + ((float)(14) * scale * targetscale);
                                break;
                            case 4:
                                dest_x = x_start + ((float)(50) * scale * targetscale);
                                dest_y = y_start + ((float)(15) * scale * targetscale);
                                break;
                            default:
                                break;
                        }

                        int source_glyph = GHApp._autodraws[autodraw].source_glyph;
                        int atile = GHApp.Glyph2Tile[source_glyph];
                        int a_sheet_idx = GHApp.TileSheetIdx(atile);
                        int at_x = GHApp.TileSheetX(atile);
                        int at_y = GHApp.TileSheetY(atile);

                        SKRect source_rt = new SKRect();
                        source_rt.Left = at_x + src_x;
                        source_rt.Right = source_rt.Left + item_width;
                        source_rt.Top = at_y + src_y;
                        source_rt.Bottom = source_rt.Top + item_height;

                        float target_x = tx + dest_x;
                        float target_y = ty + dest_y;
                        float target_width = targetscale * scale * source_rt.Width;
                        float target_height = targetscale * scale * source_rt.Height;
                        SKRect target_rt;
                        target_rt = new SKRect(0, 0, target_width, target_height);

                        using (new SKAutoCanvasRestore(canvas, true))
                        {
                            canvas.Translate(target_x, target_y);
                            canvas.Scale(1, 1, 0, 0);
                            paint.Color = paint.Color.WithAlpha((byte)(0xFF * opaqueness));
                            GHApp.MaybeFixRects(ref source_rt, ref target_rt, targetscale, usingGL, fixRects);
                            canvas.DrawImage(TileMap[a_sheet_idx], source_rt, target_rt,
#if GNH_MAUI
                                new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest),
#endif
                                paint);
                        }
                        cnt++;
                    }
                }
                else if (GHApp._autodraws[autodraw].draw_type == (int)autodraw_drawing_types.AUTODRAW_DRAW_JAR_CONTENTS && otmp_round != null)
                {
                    short max_charge = otmp_round.OtypData.max_charges;
                    double fill_percentage = (max_charge > 0 ? (double)otmp_round.ObjData.charges / (double)max_charge : 0.0);
                    if (fill_percentage >= 0.0)
                    {
                        SKRect source_rt = new SKRect();
                        SKRect target_rt = new SKRect();
                        float jar_width = GHConstants.TileWidth;
                        float jar_height = GHConstants.TileHeight / 2;

                        float dest_x, dest_y;
                        dest_x = tx + scaled_x_padding;
                        dest_y = ty + scaled_y_padding + extra_y_padding;

                        /* First, background */
                        int source_glyph = GHApp._autodraws[autodraw].source_glyph;
                        int atile = GHApp.Glyph2Tile[source_glyph];
                        int a_sheet_idx = GHApp.TileSheetIdx(atile);
                        int at_x = GHApp.TileSheetX(atile);
                        int at_y = GHApp.TileSheetY(atile);

                        int source_glyph2 = GHApp._autodraws[autodraw].source_glyph2;
                        int atile2 = GHApp.Glyph2Tile[source_glyph2];
                        int a2_sheet_idx = GHApp.TileSheetIdx(atile2);
                        int a2t_x = GHApp.TileSheetX(atile2);
                        int a2t_y = GHApp.TileSheetY(atile2);

                        source_rt.Left = at_x;
                        source_rt.Right = source_rt.Left + jar_width;
                        source_rt.Top = at_y;
                        source_rt.Bottom = source_rt.Top + jar_height;

                        target_rt.Left = 0;
                        target_rt.Right = jar_width * scale * targetscale;
                        target_rt.Top = 0;
                        target_rt.Bottom = jar_height * scale * targetscale;

                        using (new SKAutoCanvasRestore(canvas, true))
                        {
                            canvas.Translate(dest_x, dest_y);
                            paint.Color = paint.Color.WithAlpha((byte)(0xFF * opaqueness));
                            GHApp.MaybeFixRects(ref source_rt, ref target_rt, targetscale, usingGL, fixRects);
                            canvas.DrawImage(TileMap[a_sheet_idx], source_rt, target_rt,
#if GNH_MAUI
                                new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest),
#endif
                                paint);
                        }

                        /* Color */
                        ulong draw_color = GHApp._autodraws[autodraw].parameter1;
                        byte blue = (byte)(draw_color & 0xFFUL);
                        byte green = (byte)((draw_color & 0xFF00UL) >> 8);
                        byte red = (byte)((draw_color & 0xFF0000UL) >> 16);
                        SKColor fillcolor = new SKColor(red, green, blue);

                        double semi_transparency;
                        SKBlendMode oldbm;
                        if (fill_percentage > 0.0)
                        {
                            /* Second, contents */
                            source_rt.Left = at_x;
                            source_rt.Right = source_rt.Left + GHConstants.TileWidth;
                            source_rt.Top = at_y + GHConstants.TileHeight / 2;
                            source_rt.Bottom = source_rt.Top + GHConstants.TileHeight / 2;
                            float source_width = source_rt.Right - source_rt.Left;
                            float source_height = source_rt.Bottom - source_rt.Top;

                            target_rt.Left = 0;
                            target_rt.Right = source_width;
                            target_rt.Top = 0;
                            target_rt.Bottom = source_height;

                            /* Draw to _paintBitmap */
                            semi_transparency = 0.0;

                            SavedAutodrawBitmap cachekey = new SavedAutodrawBitmap(autodraw, fill_percentage, 0);
                            SKBitmap usedContentsBitmap = null;
                            SKBitmap cachedBitmap = null;
                            bool getsuccessful1;
                            //lock (_saveAutoDrawLock)
                            {
                                getsuccessful1 = _savedAutoDrawBitmaps.TryGetValue(cachekey, out cachedBitmap);
                            }
                            if (getsuccessful1 && cachedBitmap != null)
                            {
                                usedContentsBitmap = cachedBitmap;
                            }
                            else
                            {
                                oldbm = paint.BlendMode;
                                using (SKCanvas _paintCanvas = new SKCanvas(_paintBitmap))
                                {
                                    _paintCanvas.Clear(SKColors.Transparent);
                                    paint.Color = SKColors.Black.WithAlpha((byte)(0xFF * (1 - semi_transparency)));
                                    _paintCanvas.DrawImage(TileMap[a_sheet_idx], source_rt, target_rt,
#if GNH_MAUI
                                        new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest),
#endif
                                        paint);
                                    if ((GHApp._autodraws[autodraw].parameter3 & 1) != 0)
                                    {
                                        paint.BlendMode = SKBlendMode.Modulate;
                                        paint.Color = fillcolor;
                                        _paintCanvas.DrawRect(target_rt, paint);
                                    }
                                }
                                paint.BlendMode = oldbm;
                                paint.Color = SKColors.Black;
                                bool containskey1;
                                //lock (_saveAutoDrawLock)
                                {
                                    containskey1 = _savedAutoDrawBitmaps.ContainsKey(cachekey);
                                }
                                if (!containskey1)
                                {
                                    try
                                    {
                                        SKBitmap newbmp = new SKBitmap(GHConstants.TileWidth, GHConstants.TileHeight);
                                        _paintBitmap.CopyTo(newbmp);
                                        newbmp.SetImmutable();
                                        usedContentsBitmap = newbmp;
                                        //lock (_saveAutoDrawLock)
                                        {
                                            if (_savedAutoDrawBitmaps.Count >= GHConstants.MaxBitmapCacheSize)
                                            {
                                                foreach (SKBitmap bmp in _savedAutoDrawBitmaps.Values)
                                                    bmp.Dispose();
                                                _savedAutoDrawBitmaps.Clear(); /* Clear the whole dictionary for the sake of ease; should almost never happen normally anyway */
                                            }
                                            _savedAutoDrawBitmaps.Add(cachekey, newbmp);
                                        }
                                    }
                                    catch (Exception ex)
                                    {
                                        Debug.WriteLine(ex.Message);
                                        usedContentsBitmap = _paintBitmap;
                                    }
                                }
                                else
                                    usedContentsBitmap = _paintBitmap;
                            }

                            /* Bottom contents */
                            int bottom_x = 20; // 21;
                            int bottom_y = 40; // 38;
                            int bottom_width = 23; // 21;
                            int bottom_height = 7; // 10;

                            int bottom_tx = 20; // 21;
                            int bottom_ty = 38; // 35;

                            source_rt.Left = bottom_x;
                            source_rt.Right = source_rt.Left + bottom_width;
                            source_rt.Top = bottom_y;
                            source_rt.Bottom = source_rt.Top + bottom_height;

                            target_rt.Left = bottom_tx * scale * targetscale;
                            target_rt.Right = (bottom_tx + bottom_width) * scale * targetscale;
                            target_rt.Top = bottom_ty * scale * targetscale;
                            target_rt.Bottom = (bottom_ty + bottom_height) * scale * targetscale;

                            semi_transparency = 0.0;
                            paint.Color = SKColors.Black.WithAlpha((byte)(0xFF * (1 - semi_transparency)));
                            using (new SKAutoCanvasRestore(canvas, true))
                            {
                                canvas.Translate(dest_x, dest_y);
                                canvas.DrawBitmap(usedContentsBitmap, source_rt, target_rt, paint);
                            }

                            /* Middle contents */
                            int full_y = 17; // 11;
                            int empty_y = 38; // 35;
                            int fill_pixel_top = (int)((double)(empty_y - full_y) * (1.0 - fill_percentage)) + full_y;
                            int fill_pixels = empty_y - fill_pixel_top;
                            if (fill_pixels > 0)
                            {
                                int middle_x = 18; // 21;
                                int middle_y = 15; // 15;
                                int middle_width = 27; //  21;
                                int middle_height = 22; // 17;

                                int middle_tx = 18; // 21;
                                int middle_ty = fill_pixel_top + 4;
                                int middle_twidth = middle_width;
                                int middle_theight = fill_pixels + 1;

                                source_rt.Left = middle_x;
                                source_rt.Right = source_rt.Left + middle_width;
                                source_rt.Top = middle_y;
                                source_rt.Bottom = source_rt.Top + middle_height;

                                target_rt.Left = middle_tx * scale * targetscale;
                                target_rt.Right = (middle_tx + middle_twidth) * scale * targetscale;
                                target_rt.Top = middle_ty * scale * targetscale;
                                target_rt.Bottom = (middle_ty + middle_theight) * scale * targetscale;

                                semi_transparency = 0.2;
                                paint.Color = SKColors.Black.WithAlpha((byte)(0xFF * (1 - semi_transparency)));
                                using (new SKAutoCanvasRestore(canvas, true))
                                {
                                    canvas.Translate(dest_x, dest_y);
                                    canvas.DrawBitmap(usedContentsBitmap, source_rt, target_rt, paint);
                                }

                                /* Top contents */
                                int top_x = 18; // 21;
                                int top_y = 4; // 0;
                                int top_width = 27; // 21;
                                int top_height = 8; // 8;

                                float top_tx_full = 17; // 21;
                                float top_tx_empty = bottom_tx; // 21;
                                float top_tx = top_tx_empty + (float)(top_tx_full - top_tx_empty) * (float)fill_percentage;

                                float top_twidth_full = top_width;
                                float top_twidth_empty = bottom_width; ;
                                float top_twidth = top_twidth_empty + (float)(top_twidth_full - top_twidth_empty) * (float)fill_percentage;

                                float top_ty = fill_pixel_top;
                                float top_theight_full = top_height;
                                float top_theight_empty = bottom_height;
                                float top_theight = top_theight_empty + (float)(top_theight_full - top_theight_empty) * (float)fill_percentage;

                                source_rt.Left = top_x;
                                source_rt.Right = source_rt.Left + top_width;
                                source_rt.Top = top_y;
                                source_rt.Bottom = source_rt.Top + top_height;

                                target_rt.Left = top_tx * scale * targetscale;
                                target_rt.Right = (top_tx + top_twidth) * scale * targetscale;
                                target_rt.Top = top_ty * scale * targetscale;
                                target_rt.Bottom = (top_ty + top_theight) * scale * targetscale;

                                semi_transparency = 0.0;
                                paint.Color = SKColors.Black.WithAlpha((byte)(0xFF * (1 - semi_transparency)));
                                using (new SKAutoCanvasRestore(canvas, true))
                                {
                                    canvas.Translate(dest_x, dest_y);
                                    canvas.DrawBitmap(usedContentsBitmap, source_rt, target_rt, paint);
                                }
                            }
                        }

                        /* Third, transparent foreground */
                        source_rt.Left = a2t_x;
                        source_rt.Right = source_rt.Left + GHConstants.TileWidth;
                        source_rt.Top = a2t_y;
                        source_rt.Bottom = source_rt.Top + GHConstants.TileHeight / 2;

                        target_rt.Left = 0;
                        target_rt.Right = GHConstants.TileWidth * scale * targetscale;
                        target_rt.Top = 0;
                        target_rt.Bottom = GHConstants.TileHeight / 2 * scale * targetscale;

                        /* Draw */
                        semi_transparency = 0.70;
                        paint.Color = SKColors.Black.WithAlpha((byte)(0xFF * (1 - semi_transparency)));
                        using (new SKAutoCanvasRestore(canvas, true))
                        {
                            canvas.Translate(dest_x, dest_y);
                            GHApp.MaybeFixRects(ref source_rt, ref target_rt, targetscale, usingGL, fixRects);
                            canvas.DrawImage(TileMap[a2_sheet_idx], source_rt, target_rt,
#if GNH_MAUI
                                new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest),
#endif
                                paint);
                        }

                        /* Fourth, opaque foreground */
                        paint.Color = SKColors.Black;

                        source_rt.Left = a2t_x;
                        source_rt.Right = source_rt.Left + GHConstants.TileWidth;
                        source_rt.Top = a2t_y + GHConstants.TileHeight / 2;
                        source_rt.Bottom = source_rt.Top + GHConstants.TileHeight / 2;

                        target_rt.Left = 0;
                        target_rt.Right = jar_width;
                        target_rt.Top = 0;
                        target_rt.Bottom = jar_height;

                        /* Draw to _paintBitmap */
                        SavedAutodrawBitmap cachekey2 = new SavedAutodrawBitmap(autodraw, fill_percentage, 1);
                        SKBitmap usedForegroundBitmap;
                        SKBitmap cachedFGBitmap = null;
                        bool getsuccessful2;
                        //lock (_saveAutoDrawLock)
                        {
                            getsuccessful2 = _savedAutoDrawBitmaps.TryGetValue(cachekey2, out cachedFGBitmap);
                        }
                        if (getsuccessful2 && cachedFGBitmap != null)
                        {
                            usedForegroundBitmap = cachedFGBitmap;
                        }
                        else
                        {
                            oldbm = paint.BlendMode;
                            draw_color = GHApp._autodraws[autodraw].parameter2;
                            blue = (byte)(draw_color & 0xFFUL);
                            green = (byte)((draw_color & 0xFF00UL) >> 8);
                            red = (byte)((draw_color & 0xFF0000UL) >> 16);
                            SKColor capcolor = new SKColor(red, green, blue);
                            using (SKCanvas _paintCanvas = new SKCanvas(_paintBitmap))
                            {
                                _paintCanvas.Clear(SKColors.Transparent);
                                _paintCanvas.DrawImage(TileMap[a2_sheet_idx], source_rt, target_rt,
#if GNH_MAUI
                                    new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest),
#endif
                                    paint);
                                paint.Color = capcolor;
                                paint.BlendMode = SKBlendMode.Modulate;
                                _paintCanvas.DrawRect(target_rt, paint);
                            }
                            paint.BlendMode = oldbm;
                            paint.Color = SKColors.Black;
                            bool containskey2;
                            //lock (_saveAutoDrawLock)
                            {
                                containskey2 = _savedAutoDrawBitmaps.ContainsKey(cachekey2);
                            }
                            if (!containskey2)
                            {
                                try
                                {
                                    SKBitmap newbmp = new SKBitmap(GHConstants.TileWidth, GHConstants.TileHeight);
                                    _paintBitmap.CopyTo(newbmp);
                                    newbmp.SetImmutable();
                                    usedForegroundBitmap = newbmp;
                                    //lock (_saveAutoDrawLock)
                                    {
                                        if (_savedAutoDrawBitmaps.Count >= GHConstants.MaxBitmapCacheSize)
                                        {
                                            foreach (SKBitmap bmp in _savedAutoDrawBitmaps.Values)
                                                bmp.Dispose();
                                            _savedAutoDrawBitmaps.Clear(); /* Clear the whole dictionary for the sake of ease; should almost never happen normally anyway */
                                        }
                                        _savedAutoDrawBitmaps.Add(cachekey2, newbmp);
                                    }
                                }
                                catch (Exception ex)
                                {
                                    Debug.WriteLine(ex.Message);
                                    usedForegroundBitmap = _paintBitmap;
                                }
                            }
                            else
                                usedForegroundBitmap = _paintBitmap;
                        }

                        source_rt.Left = 0;
                        source_rt.Right = source_rt.Left + GHConstants.TileWidth;
                        source_rt.Top = 0;
                        source_rt.Bottom = source_rt.Top + GHConstants.TileHeight / 2;

                        target_rt.Left = 0;
                        target_rt.Right = jar_width * scale * targetscale;
                        target_rt.Top = 0;
                        target_rt.Bottom = jar_height * scale * targetscale;

                        using (new SKAutoCanvasRestore(canvas, true))
                        {
                            canvas.Translate(dest_x, dest_y);
                            canvas.DrawBitmap(usedForegroundBitmap, source_rt, target_rt, paint);
                        }

                    }
                    paint.Color = SKColors.Black;
                }

                /*
                * AUTODRAW END
                */
            }

            /* Item property marks */
            if (((layer_idx == (int)layer_types.LAYER_OBJECT || layer_idx == (int)layer_types.LAYER_COVER_OBJECT) && otmp_round != null &&
            (otmp_round.Poisoned || otmp_round.ElementalEnchantment > 0 || otmp_round.MythicPrefix > 0 || otmp_round.MythicSuffix > 0 || otmp_round.Eroded != 0 || otmp_round.Eroded2 != 0 || otmp_round.Exceptionality > 0))
            ||
            ((layer_idx == (int)layer_types.LAYER_MISSILE) &&
                (_mapData[mapx, mapy].Layers.missile_poisoned != 0 || _mapData[mapx, mapy].Layers.missile_elemental_enchantment > 0
                    || _mapData[mapx, mapy].Layers.missile_eroded != 0 || _mapData[mapx, mapy].Layers.missile_eroded2 != 0 ||
                    _mapData[mapx, mapy].Layers.missile_exceptionality > 0 || _mapData[mapx, mapy].Layers.missile_mythic_prefix > 0 || _mapData[mapx, mapy].Layers.missile_mythic_suffix > 0))
            )
            {
                float y_start = scaled_y_padding;
                if (!is_inventory)
                {
                    if (tileflag_halfsize)
                    {
                        y_start += height / 2;
                    }
                    else
                    {
                        if (tileflag_normalobjmissile && !tileflag_fullsizeditem)
                            y_start += height / 4;
                        else
                            y_start += 0;
                    }
                }
                float x_start = scaled_x_padding;
                int mark_width = 8;
                int marks_per_row = GHConstants.TileWidth / mark_width;
                int mark_height = 24;
                int src_x = 0;
                int src_y = 0;
                int cnt = 0;
                bool poisoned = (layer_idx == (int)layer_types.LAYER_MISSILE ? _mapData[mapx, mapy].Layers.missile_poisoned != 0 : otmp_round.Poisoned);
                byte elemental_enchantment = (layer_idx == (int)layer_types.LAYER_MISSILE ? _mapData[mapx, mapy].Layers.missile_elemental_enchantment : otmp_round.ElementalEnchantment);
                byte exceptionality = (layer_idx == (int)layer_types.LAYER_MISSILE ? _mapData[mapx, mapy].Layers.missile_exceptionality : otmp_round.Exceptionality);
                byte mythic_prefix = (layer_idx == (int)layer_types.LAYER_MISSILE ? _mapData[mapx, mapy].Layers.missile_mythic_prefix : otmp_round.MythicPrefix);
                byte mythic_suffix = (layer_idx == (int)layer_types.LAYER_MISSILE ? _mapData[mapx, mapy].Layers.missile_mythic_suffix : otmp_round.MythicSuffix);
                byte eroded = (layer_idx == (int)layer_types.LAYER_MISSILE ? _mapData[mapx, mapy].Layers.missile_eroded : otmp_round.Eroded);
                byte eroded2 = (layer_idx == (int)layer_types.LAYER_MISSILE ? _mapData[mapx, mapy].Layers.missile_eroded2 : otmp_round.Eroded2);
                bool corrodeable = (layer_idx == (int)layer_types.LAYER_MISSILE ? (_mapData[mapx, mapy].Layers.missile_flags & (ulong)LayerMissileFlags.MISSILE_FLAGS_CORRODEABLE) != 0 : otmp_round.OtypData.corrodeable != 0);
                bool rottable = (layer_idx == (int)layer_types.LAYER_MISSILE ? (_mapData[mapx, mapy].Layers.missile_flags & (ulong)LayerMissileFlags.MISSILE_FLAGS_ROTTABLE) != 0 : otmp_round.OtypData.rottable != 0);
                bool flammable = (layer_idx == (int)layer_types.LAYER_MISSILE ? (_mapData[mapx, mapy].Layers.missile_flags & (ulong)LayerMissileFlags.MISSILE_FLAGS_FLAMMABLE) != 0 : otmp_round.OtypData.flammable != 0);
                bool rustprone = (layer_idx == (int)layer_types.LAYER_MISSILE ? (_mapData[mapx, mapy].Layers.missile_flags & (ulong)LayerMissileFlags.MISSILE_FLAGS_RUSTPRONE) != 0 : otmp_round.OtypData.rustprone != 0);
                bool poisonable = (layer_idx == (int)layer_types.LAYER_MISSILE ? (_mapData[mapx, mapy].Layers.missile_flags & (ulong)LayerMissileFlags.MISSILE_FLAGS_POISONABLE) != 0 : otmp_round.OtypData.poisonable != 0);
                float dest_x = 0, dest_y = 0;

                for (item_property_mark_types ipm_idx = 0; ipm_idx < item_property_mark_types.MAX_ITEM_PROPERTY_MARKS; ipm_idx++)
                {
                    if (cnt >= 8)
                        break;

                    int src_tile = (int)game_ui_tile_types.ITEM_PROPERTY_MARKS + (int)ipm_idx / GHConstants.MAX_UI_TILE_8_x_24_COMPONENTS;
                    src_x = (((int)ipm_idx % GHConstants.MAX_UI_TILE_8_x_24_COMPONENTS) % marks_per_row) * mark_width;
                    src_y = (((int)ipm_idx % GHConstants.MAX_UI_TILE_8_x_24_COMPONENTS) / marks_per_row) * mark_height;
                    dest_x = 0;
                    dest_y = 0;

                    switch (ipm_idx)
                    {
                        case item_property_mark_types.ITEM_PROPERTY_MARK_POISONED:
                            if (!(poisoned && poisonable))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_DEATH_MAGICAL:
                            if (elemental_enchantment != (byte)elemental_enchantment_types.DEATH_ENCHANTMENT)
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_FLAMING:
                            if (elemental_enchantment != (byte)elemental_enchantment_types.FIRE_ENCHANTMENT)
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_FREEZING:
                            if (elemental_enchantment != (byte)elemental_enchantment_types.COLD_ENCHANTMENT)
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_ELECTRIFIED:
                            if (elemental_enchantment != (byte)elemental_enchantment_types.LIGHTNING_ENCHANTMENT)
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_EXCEPTIONAL:
                            if (exceptionality != (byte)exceptionality_types.EXCEPTIONALITY_EXCEPTIONAL)
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_ELITE:
                            if (exceptionality != (byte)exceptionality_types.EXCEPTIONALITY_ELITE)
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_CELESTIAL:
                            if (exceptionality != (byte)exceptionality_types.EXCEPTIONALITY_CELESTIAL)
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_PRIMORDIAL:
                            if (exceptionality != (byte)exceptionality_types.EXCEPTIONALITY_PRIMORDIAL)
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_INFERNAL:
                            if (exceptionality != (byte)exceptionality_types.EXCEPTIONALITY_INFERNAL)
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_MYTHIC:
                            if ((mythic_prefix == 0 && mythic_suffix == 0) || (mythic_prefix > 0 && mythic_suffix > 0))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_LEGENDARY:
                            if (mythic_prefix == 0 || mythic_suffix == 0)
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_CORRODED:
                            if (!(eroded2 == 1 && corrodeable))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_ROTTED:
                            if (!(eroded2 == 1 && rottable))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_BURNT:
                            if (!(eroded == 1 && flammable))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_RUSTY:
                            if (!(eroded == 1 && rustprone))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_VERY_CORRODED:
                            if (!(eroded2 == 2 && corrodeable))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_VERY_ROTTED:
                            if (!(eroded2 == 2 && rottable))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_VERY_BURNT:
                            if (!(eroded == 2 && flammable))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_VERY_RUSTY:
                            if (!(eroded == 2 && rustprone))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_THOROUGHLY_CORRODED:
                            if (!(eroded2 == 3 && corrodeable))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_THOROUGHLY_ROTTED:
                            if (!(eroded2 == 3 && rottable))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_THOROUGHLY_BURNT:
                            if (!(eroded == 3 && flammable))
                                continue;
                            break;
                        case item_property_mark_types.ITEM_PROPERTY_MARK_THOROUGHLY_RUSTY:
                            if (!(eroded == 3 && rustprone))
                                continue;
                            break;
                        case item_property_mark_types.MAX_ITEM_PROPERTY_MARKS:
                        default:
                            continue;
                    }

                    int item_xpos = ((int)GHConstants.TileWidth) / 2 - mark_width + (cnt % 2 != 0 ? 1 : -1) * ((cnt + 1) / 2) * mark_width;

                    dest_y = y_start + scaled_tile_height / 2 - (targetscale * scale * (float)(mark_height / 2));
                    dest_x = x_start + (targetscale * scale * (float)item_xpos);

                    int source_glyph = src_tile + GHApp.UITileOff;
                    int atile = GHApp.Glyph2Tile[source_glyph];
                    int a_sheet_idx = GHApp.TileSheetIdx(atile);
                    int at_x = GHApp.TileSheetX(atile);
                    int at_y = GHApp.TileSheetY(atile);

                    SKRect source_rt = new SKRect();
                    source_rt.Left = at_x + src_x;
                    source_rt.Right = source_rt.Left + mark_width;
                    source_rt.Top = at_y + src_y;
                    source_rt.Bottom = source_rt.Top + mark_height;

                    SKRect target_rt = new SKRect();

                    target_rt.Left = tx + dest_x;
                    target_rt.Right = target_rt.Left + targetscale * scale * source_rt.Width;
                    target_rt.Top = ty + dest_y;
                    target_rt.Bottom = target_rt.Top + targetscale * scale * source_rt.Height;

#if GNH_MAP_PROFILING && DEBUG
                    StartProfiling(GHProfilingStyle.Bitmap);
#endif
                    GHApp.MaybeFixRects(ref source_rt, ref target_rt, targetscale, usingGL, fixRects);
                    canvas.DrawImage(TileMap[a_sheet_idx], source_rt, target_rt
#if GNH_MAUI
                        , new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest)
#endif
                    );
#if GNH_MAP_PROFILING && DEBUG
                    StopProfiling(GHProfilingStyle.Bitmap);
#endif

                    cnt++;
                }
            }
        }

        private void DrawChain(SKCanvas canvas, SKPaint paint, int mapx, int mapy, int autodraw, bool autodraw_u_punished, float width, float height, float ty, float tx, float scale, float targetscale, bool usingGL, bool highFilterQuality, bool fixRects)
        {
            int u_x = _local_ux;
            int u_y = _local_uy;
            if (_uChain != null && _uBall != null && (_mapData[mapx, mapy].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_CAN_SEE) != 0)
            {
                int chain_x = _uChain.OtypData.obj_loc_x;
                int chain_y = _uChain.OtypData.obj_loc_y;
                int ball_x = _uBall.OtypData.obj_loc_x;
                int ball_y = _uBall.OtypData.obj_loc_y;
                if (GHUtils.isok(u_x, u_y) && GHUtils.isok(chain_x, chain_y) && GHUtils.isok(ball_x, ball_y))
                {
                    bool is_chain = (GHApp._autodraws[autodraw].draw_type == (int)autodraw_drawing_types.AUTODRAW_DRAW_CHAIN);
                    int chain_u_dx = (int)(u_x - chain_x);
                    int chain_u_dy = (int)(u_y - chain_y);
                    int chain_ball_dx = (int)(ball_x - chain_x);
                    int chain_ball_dy = (int)(ball_y - chain_y);
                    int u_ball_dx = (int)(u_x - chain_x);
                    int u_ball_dy = (int)(u_y - chain_y);

                    int source_glyph = autodraw_u_punished || autodraw == 0 ? (int)game_ui_tile_types.ITEM_AUTODRAW_GRAPHICS + GHApp.UITileOff : GHApp._autodraws[autodraw].source_glyph;
                    int dir_idx = GHApp._autodraws[autodraw].flags;
                    int atile = GHApp.Glyph2Tile[source_glyph];
                    int a_sheet_idx = GHApp.TileSheetIdx(atile);
                    int at_x = GHApp.TileSheetX(atile);
                    int at_y = GHApp.TileSheetY(atile);
                    float adscale = scale * targetscale;

                    for (int n = 0; n < 2; n++)
                    {
                        int relevant_dx = autodraw_u_punished ? Math.Sign(n == 0 ? -chain_u_dx : 0) : is_chain ? Math.Sign(n == 0 ? chain_u_dx : chain_ball_dx) : Math.Sign(n == 0 ? 0 : -chain_ball_dx);
                        int relevant_dy = autodraw_u_punished ? Math.Sign(n == 0 ? -chain_u_dy : 0) : is_chain ? Math.Sign(n == 0 ? chain_u_dy : chain_ball_dy) : Math.Sign(n == 0 ? 1 : -chain_ball_dy);
                        bool hflip_link = !((relevant_dx > 0) != (relevant_dy > 0));
                        bool vflip_link = false;
                        int link_source_width = 16;
                        int link_source_height = 16;
                        float link_diff_x = relevant_dx != 0 && relevant_dy != 0 ? 5.35f : 10.0f;
                        float link_diff_y = relevant_dx != 0 && relevant_dy != 0 ? link_diff_x * 1.5f : 10.0f;
                        int mid_x = GHConstants.TileWidth / 2;
                        int mid_y = GHConstants.TileHeight / 2;
                        int dist_x = relevant_dx > 0 ? GHConstants.TileWidth - mid_x : mid_x;
                        int dist_y = relevant_dy > 0 ? GHConstants.TileHeight - mid_y : mid_y;
                        int ball_scale_additional_dist_y = (int)((float)(GHConstants.TileHeight / 2) * (1.0f - scale));
                        int ball_additional_scale_links = (int)Math.Ceiling((float)ball_scale_additional_dist_y / (float)(link_source_height / 2));
                        int links = 2 + 1 + ball_additional_scale_links + (int)Math.Min((float)(dist_y - link_source_height / 2) / link_diff_y, (float)(dist_x - link_source_width / 2) / link_diff_x);

                        if (!is_chain && !autodraw_u_punished && n == 0 && links > 1)
                            links = 1 + ball_additional_scale_links;
                        else if (autodraw_u_punished && n == 1 && links > 1)
                            links = 1;

                        if (dir_idx == 0)
                        {
                            if (relevant_dx != 0 || relevant_dy != 0)
                            {
                                for (int m = 0; m < links; m++)
                                {
                                    bool used_hflip_link = hflip_link;
                                    if (m >= links && (relevant_dx < 0 || relevant_dy < 0))
                                        used_hflip_link = !((-relevant_dx > 0) != (-relevant_dy > 0));

                                    int source_width = link_source_width;
                                    int source_height = link_source_height;
                                    int within_tile_source_x = relevant_dx != 0 && relevant_dy != 0 ? 32 : relevant_dy != 0 ? 16 : 0;
                                    int within_tile_source_y = 23 + ((m % 2) == 1 ? link_source_height : 0);
                                    float target_left_added = width / 2 - ((float)source_width * adscale / 2.0f) + (((float)relevant_dx * link_diff_x * (float)m) * adscale);
                                    float target_top_added = height / 2 - ((float)source_height * adscale / 2.0f) + (((float)relevant_dy * link_diff_y * (float)m) * adscale);
                                    if (target_left_added < 0)
                                    {
                                        /* Cut off from left ==> Move source x right and reduce width to fix, flipped: just reduce width */
                                        if (!used_hflip_link)
                                            within_tile_source_x += (int)((float)-target_left_added / adscale);

                                        source_width -= (int)(-target_left_added / adscale);
                                        if (source_width <= 0)
                                            continue;
                                        target_left_added = 0;
                                    }
                                    if (target_top_added < 0)
                                    {
                                        within_tile_source_y += (int)((float)-target_top_added / adscale);
                                        source_height -= (int)((float)-target_top_added / adscale);
                                        if (source_height <= 0)
                                            continue;
                                        target_top_added = 0;
                                    }
                                    float target_x = tx + target_left_added;
                                    float target_y = ty + target_top_added;
                                    float target_width = ((float)source_width * adscale);
                                    float target_height = ((float)source_height * adscale);
                                    if (target_x + target_width > tx + width)
                                    {
                                        /* Cut off from right ==>Just reduce width to fix, flipped: Move source x right and reduce width to fix */
                                        int source_diff = (int)((target_x + target_width - (tx + width)) / adscale);
                                        if (used_hflip_link)
                                            within_tile_source_x += source_diff;

                                        source_width -= source_diff;
                                        if (source_width <= 0)
                                            continue;
                                        target_width -= (target_x + target_width - (tx + width));
                                    }
                                    if (target_y + target_height > (ty + height))
                                    {
                                        int source_diff = (int)((target_y + target_height - (ty + height)) / adscale);
                                        source_height -= source_diff;
                                        if (source_height <= 0)
                                            continue;
                                        target_height -= (target_y + target_height - (ty + height));
                                    }

                                    int source_x = at_x + within_tile_source_x;
                                    int source_y = at_y + within_tile_source_y;
                                    SKRect sourcerect = new SKRect(source_x, source_y, source_x + source_width, source_y + source_height);
                                    SKRect targetrect = new SKRect(0, 0, target_width, target_height);
                                    using (SKAutoCanvasRestore autorestore = new SKAutoCanvasRestore(canvas))
                                    {
                                        canvas.Translate(target_x + (hflip_link ? target_width : 0), target_y + (vflip_link ? target_height : 0));
                                        canvas.Scale(hflip_link ? -1 : 1, vflip_link ? -1 : 1, 0, 0);
                                        GHApp.MaybeFixRects(ref sourcerect, ref targetrect, targetscale, usingGL, fixRects);
                                        canvas.DrawImage(TileMap[a_sheet_idx], sourcerect, targetrect,
#if GNH_MAUI
                                            new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest),
#endif
                                            paint);
                                    }
                                }
                            }
                        }
                        else if (dir_idx > 0)
                        {
                            if (relevant_dx != 0 && relevant_dy != 0)
                            {
                                int added_source_x = 0, added_source_y = 0;
                                float added_target_x = 0, added_target_y = 0;
                                bool draw_link = false;

                                if (relevant_dx < 0 && relevant_dy < 0)
                                {
                                    if (dir_idx == 2)
                                    {
                                        added_source_x = 8;
                                        added_source_y = 8;
                                        added_target_x = GHConstants.TileWidth - 8;
                                        added_target_y = 0;
                                        draw_link = true;
                                    }
                                    else if (dir_idx == 3)
                                    {
                                        added_source_x = 0;
                                        added_source_y = 0;
                                        added_target_x = 0;
                                        added_target_y = GHConstants.TileHeight - 8;
                                        draw_link = true;
                                    }
                                }
                                else if (relevant_dx > 0 && relevant_dy < 0)
                                {
                                    if (dir_idx == 4)
                                    {
                                        added_source_x = 8;
                                        added_source_y = 8;
                                        added_target_x = 0;
                                        added_target_y = 0;
                                        draw_link = true;
                                    }
                                    else if (dir_idx == 3)
                                    {
                                        added_source_x = 0;
                                        added_source_y = 0;
                                        added_target_x = GHConstants.TileWidth - 8;
                                        added_target_y = GHConstants.TileHeight - 8;
                                        draw_link = true;
                                    }
                                }
                                else if (relevant_dx < 0 && relevant_dy > 0)
                                {
                                    if (dir_idx == 2)
                                    {
                                        added_source_x = 0;
                                        added_source_y = 0;
                                        added_target_x = GHConstants.TileWidth - 8;
                                        added_target_y = GHConstants.TileHeight - 8;
                                        draw_link = true;
                                    }
                                    else if (dir_idx == 1)
                                    {
                                        added_source_x = 8;
                                        added_source_y = 8;
                                        added_target_x = 0;
                                        added_target_y = 0;
                                        draw_link = true;
                                    }
                                }
                                else if (relevant_dx > 0 && relevant_dy > 0)
                                {
                                    if (dir_idx == 4)
                                    {
                                        added_source_x = 0;
                                        added_source_y = 0;
                                        added_target_x = 0;
                                        added_target_y = GHConstants.TileHeight - 8;
                                        draw_link = true;
                                    }
                                    else if (dir_idx == 1)
                                    {
                                        added_source_x = 8;
                                        added_source_y = 8;
                                        added_target_x = GHConstants.TileWidth - 8;
                                        added_target_y = 0;
                                        draw_link = true;
                                    }
                                }
                                if (draw_link)
                                {
                                    int source_width = 8;
                                    int source_height = 8;
                                    int within_tile_source_x = 32 + added_source_x;
                                    int within_tile_source_y = 23 + ((links + 1 % 2) == 1 ? link_source_height : 0) + added_source_y;
                                    float target_x = tx + ((float)(added_target_x) * adscale);
                                    float target_y = ty + ((float)(added_target_y) * adscale);
                                    float target_width = ((float)source_width * adscale);
                                    float target_height = ((float)source_height * adscale);
                                    int source_x = at_x + within_tile_source_x;
                                    int source_y = at_y + within_tile_source_y;

                                    SKRect sourcerect = new SKRect(source_x, source_y, source_x + source_width, source_y + source_height);
                                    SKRect targetrect = new SKRect(0, 0, target_width, target_height);
                                    using (SKAutoCanvasRestore autorestore = new SKAutoCanvasRestore(canvas))
                                    {
                                        canvas.Translate(target_x + (hflip_link ? target_width : 0), target_y + (vflip_link ? target_height : 0));
                                        canvas.Scale(hflip_link ? -1 : 1, vflip_link ? -1 : 1, 0, 0);
                                        GHApp.MaybeFixRects(ref sourcerect, ref targetrect, targetscale, usingGL, fixRects);
                                        canvas.DrawImage(TileMap[a_sheet_idx], sourcerect, targetrect,
#if GNH_MAUI
                                            new SKSamplingOptions(highFilterQuality ? SKFilterMode.Linear : SKFilterMode.Nearest),
#endif
                                            paint);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        public double CurrentPageWidth { get { return _currentPageWidth; } }
        public double CurrentPageHeight { get { return _currentPageHeight; } }

        private double _currentPageWidth = 0;
        private double _currentPageHeight = 0;

        //private readonly object _isLandScapeLock = new object();
        private int _isLandScape = 0;
        public bool IsLandscape { get { return Interlocked.CompareExchange(ref _isLandScape, 0, 0) != 0; } set { Interlocked.Exchange(ref _isLandScape, value ? 1 : 0); } }

        protected override void OnSizeAllocated(double width, double height)
        {
            base.OnSizeAllocated(width, height);
            if (width != _currentPageWidth || height != _currentPageHeight)
            {
                _currentPageWidth = width;
                _currentPageHeight = height;

                IsLandscape = width > height;

                if (TipView.IsVisible)
                    TipView.InvalidateSurface();

                UpdateButtonAndUISizes();
                IsSizeAllocatedProcessed = true;
            }
        }

        public void UpdateButtonAndUISizes()
        {
            double width = _currentPageWidth;
            double height = _currentPageHeight;
            if (width == 0 || height == 0)
                return;

            bool usingDesktopButtons = DesktopButtons;
            bool usingSimpleCmdLayout = UseSimpleCmdLayout;
            float inverseCanvasScale = GHApp.DisplayDensity;
            float customScale = GHApp.CustomScreenScale;
            ButtonGridStats buttonStats = OrderStoneButtons(width, height);

            GameMenuButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            ESCButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            ToggleAutoCenterModeButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            LookModeButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            ToggleTravelModeButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            ToggleIgnoreModeButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            ToggleAutoDigButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            ToggleZoomMiniButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            ToggleZoomAlternateButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);

            //SimpleGameMenuButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, inverseCanvasScale, customScale);
            //SimpleESCButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, inverseCanvasScale, customScale);
            //SimpleToggleAutoCenterModeButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, inverseCanvasScale, customScale);
            //SimpleLookModeButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, inverseCanvasScale, customScale);
            //SimpleToggleZoomMiniButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, inverseCanvasScale, customScale);

#if GNH_MAUI
            YnWidthGrid.MaximumWidthRequest = 600 * customScale;
            PopupWidthGrid.MaximumWidthRequest = 600 * customScale;
            GetLineWidthGrid.MaximumWidthRequest = 440 * customScale;
            GetLineFrame.Padding = new Thickness(12 * customScale);
            MenuCountWidthGrid.MaximumWidthRequest = 360 * customScale;
            MenuCountFrame.Padding = new Thickness(12 * customScale);
#else
            YnWidthGrid.WidthRequest = 600 * customScale;
            PopupWidthGrid.WidthRequest = 600 * customScale;
            GetLineWidthGrid.WidthRequest = 440 * customScale;
            MenuCountWidthGrid.WidthRequest = 360 * customScale;
#endif
            YnTitleLabel.FontSize = 22 * customScale;
            YnQuestionLabel.FontSize = 19 * customScale;
            YnImage.WidthRequest = 32 * customScale;
            YnImage.HeightRequest = 48 * customScale;
            ZeroButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            FirstButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            SecondButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            ThirdButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            FourthButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);

            PopupTitleLabel.FontSize = 20 * customScale;
            PopupLabel.FontSize = 16 * customScale;
            PopupImage.WidthRequest = 32 * customScale;
            PopupImage.HeightRequest = 48 * customScale;
            PopupOkButton.FontSize = 19 * customScale;
            PopupOkButton.WidthRequest = 170 * customScale;
            PopupOkButton.HeightRequest = 60 * customScale;

            GetLineCaption.FontSize = 20 * customScale;
            GetLineEntryText.FontSize = 20 * customScale;
            GetLineEntryText.WidthRequest = 320 * customScale;
            GetLineQuestionMarkButton.FontSize = 18 * customScale;
            GetLineQuestionMarkButton.WidthRequest = 50 * customScale;
            GetLineQuestionMarkButton.HeightRequest = 50 * customScale;
            GetLineAutoComplete.FontSize = 18 * customScale;
            GetLineButtonGrid.WidthRequest = 360 * customScale;
            GetLineButtonRowDefinition.Height = 65 * customScale;
            GetLineOkButton.FontSize = 19 * customScale;
            GetLineOkButton.WidthRequest = 135 * customScale;
            GetLineOkButton.HeightRequest = 60 * customScale;
            GetLineCancelButton.FontSize = 19 * customScale;
            GetLineCancelButton.WidthRequest = 135 * customScale;
            GetLineCancelButton.HeightRequest = 60 * customScale;

            MenuCountCaption.FontSize = 20 * customScale;
            CountPicker.FontSize = 15 * customScale;
            CountPicker.WidthRequest = 180 * customScale;
            MenuCountEntry.FontSize = 15 * customScale;
            MenuCountEntry.WidthRequest = 180 * customScale;
            MenuCountButtonGrid.WidthRequest = 360 * customScale;
            MenuCountButtonRowDefinition.Height = 65 * customScale;
            MenuCountOkButton.FontSize = 19 * customScale;
            MenuCountOkButton.WidthRequest = 135 * customScale;
            MenuCountOkButton.HeightRequest = 60 * customScale;
            MenuCountCancelButton.FontSize = 19 * customScale;
            MenuCountCancelButton.WidthRequest = 135 * customScale;
            MenuCountCancelButton.HeightRequest = 60 * customScale;

            foreach (View v in UpperCmdGrid.Children)
            {
                LabeledImageButton lib = (LabeledImageButton)v;
                lib.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            }
            foreach (View v in LowerCmdGrid.Children)
            {
                LabeledImageButton lib = (LabeledImageButton)v;
                lib.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            }
            foreach (View v in SimpleCmdGrid.Children)
            {
                LabeledImageButton lib = (LabeledImageButton)v;
                lib.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            }

            LabeledImageButton firstchild = (LabeledImageButton)UpperCmdGrid.Children[0];
            UpperCmdGrid.HeightRequest = firstchild.GridHeight;
            LowerCmdGrid.HeightRequest = firstchild.GridHeight;

            LabeledImageButton simplefirstchild = (LabeledImageButton)SimpleCmdGrid.Children[0];
            SimpleCmdGrid.HeightRequest = simplefirstchild.GridHeight;

            lAbilitiesButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            lWornItemsButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            lRowAbilitiesButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            lRowWornItemsButton.SetSideSize(width, height, usingDesktopButtons, usingSimpleCmdLayout, buttonStats.Rows, inverseCanvasScale, customScale);
            //double statusbarheight = GetStatusBarHeight(); /* Requires lInventoryButton size having set to determine scaling */
            double statusbarheight = GetStatusBarHeightEx2(inverseCanvasScale, customScale, width, height); // GetStatusBarHeightEx(width, height, usingDesktopButtons, usingSimpleCmdLayout, inverseCanvasScale, customScale);
            lAbilitiesButton.HeightRequest = statusbarheight;
            lWornItemsButton.HeightRequest = statusbarheight;
            StoneButtonGrid.Margin = new Thickness(0, statusbarheight, 0, 0);
            //UpperCmdLayout.Margin = new Thickness(0, statusbarheight, 0, 0);
            //SimpleUpperCmdLayout.Margin = new Thickness(0, statusbarheight, 0, 0);

            MenuHeaderLabel.Margin = UIUtils.GetHeaderMarginWithBorder(MenuBackground.BorderStyle, width, height);
            MenuCloseGrid.Margin = UIUtils.GetFooterMarginWithBorder(MenuBackground.BorderStyle, width, height);
            Thickness smallthick = UIUtils.GetSmallBorderThickness(width, height, 1.5);
            TextCanvas.Margin = smallthick;
            TextWindowGlyphImage.Margin = smallthick;
            Thickness subthick = smallthick;
            subthick.Top = MenuSubtitleLabel.Margin.Top;
            subthick.Bottom = MenuSubtitleLabel.Margin.Bottom;
            MenuSubtitleLabel.Margin = subthick;
            Thickness glyphthick = smallthick;
            glyphthick.Top = MenuWindowGlyphImage.Margin.Top;
            glyphthick.Bottom = MenuWindowGlyphImage.Margin.Bottom;
            MenuWindowGlyphImage.Margin = glyphthick;

            lock (_statusOffsetLock)
            {
                _statusOffsetY = 0;
            }
            lock (_messageScrollLock)
            {
                _messageScrollOffset = 0;
                InterlockedMessageScrollOffset = _messageScrollOffset;
            }
            lock (_menuScrollLock)
            {
                _menuScrollOffset = 0;
                InterlockedMenuScrollOffset = _menuScrollOffset;
            }
            lock (_menuPositionLock)
            {
                Array.Clear(_savedMenuScrollOffset, 0, _savedMenuScrollOffset.Length);
            }
            lock (_textScrollLock)
            {
                _textScrollOffset = 0;
                InterlockedTextScrollOffset = _textScrollOffset;
            }

            bool useTwoRows = UIUtils.UseTwoButtonRows(width, height, lInventoryButton.GridWidth, usingDesktopButtons, usingSimpleCmdLayout);
            if (!useTwoRows)
            {
                /* One row */
                ButtonRowStack.Orientation = StackOrientation.Horizontal;
                SimpleButtonRowStack.Orientation = StackOrientation.Horizontal;
            }
            else
            {
                /* Two rows */
                ButtonRowStack.Orientation = StackOrientation.Vertical;
                SimpleButtonRowStack.Orientation = StackOrientation.Vertical;
            }

            //if (width > height)
            //{
            //    /* Landscape */
            //    ModeLayout.Orientation = StackOrientation.Vertical;
            //    ModeSubLayout1.Orientation = StackOrientation.Horizontal;
            //    ModeSubLayout2.Orientation = StackOrientation.Horizontal;
            //    GameMenuLayout.Orientation = StackOrientation.Horizontal;

            //    SimpleModeLayout.Orientation = StackOrientation.Vertical;
            //    SimpleModeSubLayout1.Orientation = StackOrientation.Horizontal;
            //    SimpleModeSubLayout2.Orientation = StackOrientation.Horizontal;
            //    SimpleGameMenuLayout.Orientation = StackOrientation.Horizontal;
            //}
            //else
            //{
            //    /* Portrait */
            //    ModeLayout.Orientation = StackOrientation.Vertical;
            //    ModeSubLayout1.Orientation = StackOrientation.Vertical;
            //    ModeSubLayout2.Orientation = StackOrientation.Vertical;
            //    GameMenuLayout.Orientation = StackOrientation.Horizontal;

            //    SimpleModeLayout.Orientation = StackOrientation.Vertical;
            //    SimpleModeSubLayout1.Orientation = StackOrientation.Vertical;
            //    SimpleModeSubLayout2.Orientation = StackOrientation.Vertical;
            //    SimpleGameMenuLayout.Orientation = StackOrientation.Horizontal;
            //}

            RefreshMenuRowCounts = true;
            RefreshMsgHistoryRowCounts = true;
        }

        public struct ButtonGridStats
        {
            public int Columns;
            public int Rows;
            public int Buttons;

            public ButtonGridStats(int columns, int rows, int buttons)
            {
                Columns = columns;
                Rows = rows;
                Buttons = buttons;
            }
        }

        private ButtonGridStats CalculateStoneButtonGridSize(double width, double height)
        {
            bool isLandscape = width > height;
            bool isWideLandscape = width > GHConstants.WideLandscapeThreshold * height;
            int visibleButtons = 5;
            if (ShowAltZoomButton)
                visibleButtons++;
            if (ShowTravelModeButton)
                visibleButtons++;
            if (ShowAutoDigButton)
                visibleButtons++;
            if (ShowIgnoreStoppingButton)
                visibleButtons++;
            int noOfColumns = isWideLandscape ? (visibleButtons + 1) / 2 : visibleButtons <= 6 ? 2 : 3;
            int noOfRows = isWideLandscape ? 2 : isLandscape ? 3 : Math.Min(5, visibleButtons - 1);
            return new ButtonGridStats(noOfColumns, noOfRows, visibleButtons);
        }

        private ButtonGridStats OrderStoneButtons(double width, double height)
        {
            if (width == 0 || height == 0)
                return new ButtonGridStats(1, 1, 0);
            bool isLandscape = width > height;
            bool isWideLandscape = width > GHConstants.WideLandscapeThreshold * height;
            int visibleButtons = 5;
            GameMenuButton.IsVisible = true;
            ESCButton.IsVisible = true;
            ToggleAutoCenterModeButton.IsVisible = true;
            ToggleZoomMiniButton.IsVisible = true;
            LookModeButton.IsVisible = true;

            bool isAltZoomVisible = false;
            bool isTravelModeVisible = false;
            if (ShowAltZoomButton)
            {
                isAltZoomVisible = true;
                ToggleZoomAlternateButton.IsVisible = true;
                visibleButtons++;
            }
            else
            {
                ToggleZoomAlternateButton.IsVisible = false;
            }
            if (ShowTravelModeButton)
            {
                isTravelModeVisible = true;
                ToggleTravelModeButton.IsVisible = true;
                visibleButtons++;
            }
            else
            {
                ToggleTravelModeButton.IsVisible = false;
            }
            //if (!UseSimpleCmdLayout)
            //{
            //    isAltZoomVisible = isTravelModeVisible = true;
            //    ToggleZoomAlternateButton.IsVisible = true;
            //    ToggleTravelModeButton.IsVisible = true;
            //    visibleButtons += 2;
            //}
            //else
            //{
            //    ToggleZoomAlternateButton.IsVisible = false;
            //    ToggleTravelModeButton.IsVisible = false;
            //}

            bool isAutoDigVisible = false;
            bool isIgnoreVisible = false;
            if (ShowAutoDigButton)
            {
                isAutoDigVisible = true;
                ToggleAutoDigButton.IsVisible = true;
                visibleButtons++;
            }
            else
            {
                ToggleAutoDigButton.IsVisible = false;
            }

            if (ShowIgnoreStoppingButton)
            {
                isIgnoreVisible = true;
                ToggleIgnoreModeButton.IsVisible = true;
                visibleButtons++;
            }
            else
            {
                ToggleIgnoreModeButton.IsVisible = false;
            }


            int noOfColumns = isWideLandscape ? (visibleButtons + 1) / 2 : visibleButtons <= 6 ? 2 : 3;
            int noOfRows = isWideLandscape ? 2 : isLandscape ? 3 : Math.Min(5, visibleButtons - 1);

            bool[,] populated = new bool[noOfColumns, noOfRows];

            StoneButtonGrid.RowDefinitions.Clear();
            StoneButtonGrid.ColumnDefinitions.Clear();
            for (int i = 0; i < noOfRows; i++)
            {
                StoneButtonGrid.RowDefinitions.Add(new RowDefinition());
            }
            for (int i = 0; i < noOfColumns; i++)
            {
                StoneButtonGrid.ColumnDefinitions.Add(new ColumnDefinition());
            }

            List<SimpleImageButton> dynamicallyPlacedList = new List<SimpleImageButton>();
            /* Game menu is always top left */
            Grid.SetColumn(GameMenuButton, 0);
            Grid.SetRow(GameMenuButton, 0);
            populated[0, 0] = true;

            /* ESC button is always right of game menu */
            Grid.SetColumn(ESCButton, 1);
            Grid.SetRow(ESCButton, 0);
            populated[1, 0] = true;

            int autoCenterX = -1, autoCenterY = -1;
            int mapMiniX = -1, mapMiniY = -1;
            int lookX = -1, lookY = -1;
            bool dynamicLookPlacement = false;

#if false // Code for placing autocenter button first
            if (GHConstants.StoneButtonOrderPlaceAutoCenterFirst)
            {
                /* Auto center button is always either right or below of ESC button */
                if (noOfColumns > 2)
                {
                    autoCenterX = 2;
                    autoCenterY = 0;
                }
                else
                {
                    autoCenterX = 1;
                    autoCenterY = 1;
                }
                Grid.SetColumn(ToggleAutoCenterModeButton, autoCenterX);
                Grid.SetRow(ToggleAutoCenterModeButton, autoCenterY);
                populated[autoCenterX, autoCenterY] = true;

                /* Minimap button is either right, below or left of the Auto center button */
                if (autoCenterY == 0 && autoCenterX < noOfColumns - 1) // Right
                {
                    mapMiniX = autoCenterX + 1;
                    mapMiniY = autoCenterY;
                }
                else if (autoCenterY == 0 || (autoCenterX == 0 && autoCenterY < noOfRows - 1) || autoCenterY < noOfRows - 2) // Below
                {
                    mapMiniX = autoCenterX;
                    mapMiniY = autoCenterY + 1;
                }
                else  // Left
                {
                    mapMiniX = autoCenterX - 1;
                    mapMiniY = autoCenterY;
                }
                Grid.SetColumn(ToggleZoomMiniButton, mapMiniX);
                Grid.SetRow(ToggleZoomMiniButton, mapMiniY);
                populated[mapMiniX, mapMiniY] = true;

                /* Alternate map zoom button is either right, below or left of the minimap button, unless there is no button above this location */
                if (isAltZoomVisible)
                {
                    int altZoomX, altZoomY;
                    if (mapMiniY == 0 && mapMiniX < noOfColumns - 1) // Right of the minimap button
                    {
                        altZoomX = mapMiniX + 1;
                        altZoomY = mapMiniY;
                        if (mapMiniX < noOfColumns - 2)
                        {
                            lookX = mapMiniX + 2;
                            lookY = mapMiniY;
                        }
                        else
                        {
                            lookX = mapMiniX + 1;
                            lookY = mapMiniY + 1;
                        }
                    }
                    else if (mapMiniX == noOfColumns - 1 && (mapMiniY < noOfRows - 2 || mapMiniY == 0)) // Below the minimap button, there's also space for look button below
                    {
                        altZoomX = mapMiniX;
                        altZoomY = mapMiniY + 1;  /* Below miniMap */
                        if (mapMiniY < noOfRows - 2) /* Below altZoom */
                        {
                            lookX = mapMiniX;
                            lookY = mapMiniY + 2;
                        }
                        else if (altZoomX - 1 >= 0 && !populated[altZoomX - 1, altZoomY]) /* Left of altZoom if not populated */
                        {
                            lookX = altZoomX - 1;
                            lookY = altZoomY;
                        }
                        else // Fail safe
                        {
                            dynamicallyPlacedList.Add(LookModeButton);
                            dynamicLookPlacement = true;
                        }
                    }
                    else
                    {
                        altZoomX = mapMiniX - 1;
                        altZoomY = mapMiniY;
                        if (altZoomX - 1 >= 0 && altZoomY - 1 >= 0 && !populated[altZoomX - 1, altZoomY - 1])  // Top-left of the altZoom button
                        {
                            lookX = altZoomX - 1;
                            lookY = altZoomY - 1;
                        }
                        else if (altZoomX - 1 >= 0 && !populated[altZoomX - 1, altZoomY])  // Left of the altZoom button
                        {
                            lookX = altZoomX - 1;
                            lookY = altZoomY;
                        }
                        else // Fail safe
                        {
                            dynamicallyPlacedList.Add(LookModeButton);
                            dynamicLookPlacement = true;
                        }
                    }
                    Grid.SetColumn(ToggleZoomAlternateButton, altZoomX);
                    Grid.SetRow(ToggleZoomAlternateButton, altZoomY);
                    populated[altZoomX, altZoomY] = true;
                    if (!dynamicLookPlacement)
                    {
                        Grid.SetColumn(LookModeButton, lookX);
                        Grid.SetRow(LookModeButton, lookY);
                        populated[lookX, lookY] = true;
                    }
                }
                else
                {
                    if (mapMiniY == 0 && mapMiniX < noOfColumns - 1) // Right of the minimap button
                    {
                        lookX = mapMiniX + 1;
                        lookY = mapMiniY;
                    }
                    else if (mapMiniY < noOfRows - 1) // Below the minimap button
                    {
                        if (mapMiniX == noOfColumns - 1)
                        {
                            lookX = mapMiniX;
                            lookY = mapMiniY + 1;
                        }
                        else if (autoCenterY + 1 < noOfRows && !populated[autoCenterX, autoCenterY + 1])
                        {
                            lookX = autoCenterX;
                            lookY = autoCenterY + 1;
                        }
                        else // Fail safe
                        {
                            dynamicallyPlacedList.Add(LookModeButton);
                            dynamicLookPlacement = true;
                        }
                    }
                    else if (mapMiniX - 1 >= 0)
                    {
                        lookX = mapMiniX - 1;
                        lookY = mapMiniY;
                    }
                    else // Fail safe
                    {
                        dynamicallyPlacedList.Add(LookModeButton);
                        dynamicLookPlacement = true;
                    }
                    if (!dynamicLookPlacement)
                    {
                        Grid.SetColumn(LookModeButton, lookX);
                        Grid.SetRow(LookModeButton, lookY);
                        populated[lookX, lookY] = true;
                    }
                }
            }
            else
#endif
            {
                bool autoCenterPlaced = false;
                /* Minimap is place all the way to the right, and topmost row if there are only two rows, otherwise second topmost row */
                if (noOfColumns > 2)
                {
                    if (noOfRows > 2) /* We have space for alt zoom or look mode below */
                    {
                        mapMiniX = noOfColumns - 1;
                        mapMiniY = 1;

                        /* In this case, autocenter goes above minimap */
                        autoCenterPlaced = true;
                        autoCenterX = noOfColumns - 1;
                        autoCenterY = 0;
                        Grid.SetColumn(ToggleAutoCenterModeButton, autoCenterX);
                        Grid.SetRow(ToggleAutoCenterModeButton, autoCenterY);
                        populated[autoCenterX, autoCenterY] = true;
                    }
                    else
                    {
                        mapMiniX = noOfColumns - 1;
                        mapMiniY = 0;
                    }
                }
                else
                {
                    if (noOfRows > 3) /* We have space for alt zoom or look mode below */
                    {
                        mapMiniX = 1;
                        mapMiniY = 2;

                        /* In this case, autocenter goes above minimap */
                        autoCenterPlaced = true;
                        autoCenterX = 1;
                        autoCenterY = 1;
                        Grid.SetColumn(ToggleAutoCenterModeButton, autoCenterX);
                        Grid.SetRow(ToggleAutoCenterModeButton, autoCenterY);
                        populated[autoCenterX, autoCenterY] = true;
                    }
                    else
                    {
                        mapMiniX = 1;
                        mapMiniY = 1;
                    }
                }
                Grid.SetColumn(ToggleZoomMiniButton, mapMiniX);
                Grid.SetRow(ToggleZoomMiniButton, mapMiniY);
                populated[mapMiniX, mapMiniY] = true;

                bool lookPlaced = false;
                if (mapMiniY == 0) /* Try to fill first the first row, as mapMiniX is as right as possible */
                {
                    if (!autoCenterPlaced && mapMiniX >= 1 && !populated[mapMiniX - 1, mapMiniY])
                    {
                        autoCenterPlaced = true;
                        autoCenterX = mapMiniX - 1;
                        autoCenterY = mapMiniY;
                        Grid.SetColumn(ToggleAutoCenterModeButton, autoCenterX);
                        Grid.SetRow(ToggleAutoCenterModeButton, autoCenterY);
                        populated[autoCenterX, autoCenterY] = true;
                    }
                    //if (autoCenterPlaced && mapMiniX >= 2 && !populated[mapMiniX - 2, mapMiniY])
                    //{
                    //    lookPlaced = true;
                    //    dynamicLookPlacement = true; /* Prevent travel mode being placed relative to LookModeButton */
                    //    lookX = mapMiniX - 2;
                    //    lookY = mapMiniY;
                    //    Grid.SetColumn(LookModeButton, lookX);
                    //    Grid.SetRow(LookModeButton, lookY);
                    //    populated[lookX, lookY] = true;
                    //}
                }

                /* Alternate map zoom button is either right, below or left of the minimap button, unless there is no button above this location */
                int altZoomX = -1, altZoomY = -1;
                bool dynamicAltZoomPlacement = false;
                if (isAltZoomVisible)
                {
                    if (mapMiniY == 0 && mapMiniX < noOfColumns - 1) // Right of the minimap button
                    {
                        altZoomX = mapMiniX + 1;
                        altZoomY = mapMiniY;
                    }
                    else if (mapMiniX == noOfColumns - 1 && (mapMiniY < noOfRows - 1 || mapMiniY == 0))  /* Below miniMap */
                    {
                        altZoomX = mapMiniX;
                        altZoomY = mapMiniY + 1;
                    }
                    else if (mapMiniX >= 1 && !populated[mapMiniX - 1, mapMiniY])  /* Left of the miniMap */
                    {
                        altZoomX = mapMiniX - 1;
                        altZoomY = mapMiniY;
                    }
                    else
                    {
                        dynamicAltZoomPlacement = true;
                        dynamicallyPlacedList.Add(ToggleZoomAlternateButton);
                    }
                    if (!dynamicAltZoomPlacement && altZoomX >= 0 && altZoomY >= 0)
                    {
                        Grid.SetColumn(ToggleZoomAlternateButton, altZoomX);
                        Grid.SetRow(ToggleZoomAlternateButton, altZoomY);
                        populated[altZoomX, altZoomY] = true;
                    }
                }

                if (!lookPlaced)
                {
                    /* Look is allocated dynamically */
                    dynamicallyPlacedList.Add(LookModeButton);
                    dynamicLookPlacement = true;
                }
                if (!autoCenterPlaced)
                {
                    /* AutoCenter is allocated dynamically */
                    dynamicallyPlacedList.Add(ToggleAutoCenterModeButton);
                }
            }

            int travelX = -1, travelY = -1;
            bool dynamicTravelPlacement = false;
            if (isTravelModeVisible)
            {
                if (!dynamicLookPlacement && lookX >= 0 && lookY >= 0)
                {
                    if (lookY == 0 && lookX < noOfColumns - 1 && !populated[lookX + 1, lookY]) // Right of the look button
                    {
                        travelX = lookX + 1;
                        travelY = lookY;
                    }
                    else if (lookX == noOfColumns -1 && lookY < noOfRows - 1 && !populated[lookX, lookY + 1]) // Below the look button
                    {
                        travelX = lookX;
                        travelY = lookY + 1;
                    }
                    else if (lookX - 1 >= 0 && !populated[lookX - 1, lookY])
                    {
                        travelX = lookX - 1;
                        travelY = lookY;
                    }
                    else
                    {
                        dynamicallyPlacedList.Add(ToggleTravelModeButton);
                        dynamicTravelPlacement = true;
                    }
                    if (!dynamicTravelPlacement)
                    {
                        Grid.SetColumn(ToggleTravelModeButton, travelX);
                        Grid.SetRow(ToggleTravelModeButton, travelY);
                        populated[travelX, travelY] = true;
                    }
                }
                else
                {
                    dynamicallyPlacedList.Add(ToggleTravelModeButton);
                    dynamicTravelPlacement = true;
                }
            }
            if (isIgnoreVisible)
                dynamicallyPlacedList.Add(ToggleIgnoreModeButton);
            if (isAutoDigVisible)
                dynamicallyPlacedList.Add(ToggleAutoDigButton);

            if (dynamicallyPlacedList.Count > 0)
            {
                int i = 0;
                bool allPlaced = false;
#if false
                if (isLandscape)
                {
                    for (int y = 0; y < noOfRows; y++)
                    {
                        for (int x = noOfColumns - 1; x >= 0; x--)
                        {
                            if (!populated[x, y])
                            {
                                Grid.SetColumn(dynamicallyPlacedList[i], x);
                                Grid.SetRow(dynamicallyPlacedList[i], y);
                                populated[x, y] = true;
                                i++;
                                if (i >= dynamicallyPlacedList.Count)
                                {
                                    allPlaced = true;
                                    break;
                                }
                            }
                        }
                        if (allPlaced)
                            break;
                    }
                }
                else
#endif
                {
                    for (int x = noOfColumns - 1; x >= 0; x--)
                    {
                        for (int y = 0; y < noOfRows; y++)
                        {
                            if (!populated[x, y])
                            {
                                Grid.SetColumn(dynamicallyPlacedList[i], x);
                                Grid.SetRow(dynamicallyPlacedList[i], y);
                                populated[x, y] = true;
                                i++;
                                if (i >= dynamicallyPlacedList.Count)
                                {
                                    allPlaced = true;
                                    break;
                                }
                            }
                        }
                        if (allPlaced)
                            break;
                    }
                }
            }

            return new ButtonGridStats(noOfColumns, noOfRows, visibleButtons);
        }

        //public float GetStatusBarSkiaHeight()
        //{
        //    float statusbarheight;
        //    using (GHSkiaFontPaint textPaint = new GHSkiaFontPaint())
        //    {
        //        textPaint.Typeface = GHApp.LatoRegular;
        //        textPaint.TextSize = _statusbar_basefontsize * GetTextScale();
        //        float rowheight = textPaint.FontSpacing;
        //        statusbarheight = rowheight * 2 + _statusbar_vmargin * 2 + _statusbar_rowmargin;
        //    }
        //    return statusbarheight;
        //}

        //public float GetStatusBarSkiaHeightEx(double canvasViewWidth, double canvasViewHeight, bool usingDesktopButtons, bool usingSimpleCmdLayout)
        //{
        //    float textScale = GetTextScaleEx(canvasViewWidth, canvasViewHeight, usingDesktopButtons, usingSimpleCmdLayout);
        //    return GetStatusBarSkiaHeightEx(textScale);
        //}

        //public float GetStatusBarSkiaHeightEx(double canvasViewWidth, double canvasViewHeight, bool usingDesktopButtons, bool usingSimpleCmdLayout, float inverseCanvasScale, float customScale)
        //{
        //    float textScale = GetTextScaleEx(canvasViewWidth, canvasViewHeight, usingDesktopButtons, usingSimpleCmdLayout, inverseCanvasScale, customScale);
        //    return GetStatusBarSkiaHeightEx(textScale);
        //}

        //public float GetStatusBarSkiaHeightEx2(float inverseCanvasScale, float customScale)
        //{
        //    float textScale = UIUtils.CalculateTextScale(inverseCanvasScale, customScale);
        //    return GetStatusBarSkiaHeightEx(textScale);
        //}

        //public float GetStatusBarSkiaHeightEx2()
        //{
        //    float textScale = UIUtils.CalculateTextScale(GHApp.DisplayDensity, GHApp.CustomScreenScale);
        //    return GetStatusBarSkiaHeightEx(textScale);
        //}

        //public float GetStatusBarSkiaHeightEx(float textScale)
        //{
        //    float statusbarheight;
        //    using (GHSkiaFontPaint textPaint = new GHSkiaFontPaint())
        //    {
        //        textPaint.Typeface = GHApp.LatoRegular;
        //        textPaint.TextSize = GHConstants.StatusBarBaseFontSize * textScale;
        //        float rowheight = textPaint.FontSpacing;
        //        statusbarheight = rowheight * 2 + GHConstants.StatusBarRowMargin * 2 + GHConstants.StatusBarVerticalMargin;
        //    }
        //    return statusbarheight;
        //}

        //public double GetCanvasScale()
        //{
        //    return 1.0 / GHApp.DisplayDensity;
        //    //if (MainCanvasView.CanvasSize.Width <= 0 || MainCanvasView.CanvasSize.Height <= 0)
        //    //    return 1.0;
        //    //return Math.Sqrt(MainCanvasView.Width / (double)MainCanvasView.CanvasSize.Width * MainCanvasView.Height / (double)MainCanvasView.CanvasSize.Height);
        //}

        //public float GetInverseCanvasScale()
        //{
        //    return GHApp.DisplayDensity;
        //    //return (float)(1.0 / GetCanvasScale());
        //}

        //public double GetStatusBarHeight()
        //{
        //    double sb_xheight;
        //    float statusbarheight = GetStatusBarSkiaHeight();
        //    double scale = GetCanvasScale();
        //    sb_xheight = scale * (double)statusbarheight;
        //    return sb_xheight;
        //}

        //public double GetStatusBarHeightEx(double canvasViewWidth, double canvasViewHeight, bool usingDesktopButtons, bool usingSimpleCmdLayout)
        //{
        //    return GetStatusBarHeightEx(canvasViewWidth, canvasViewHeight, usingDesktopButtons, usingSimpleCmdLayout, GHApp.DisplayDensity, GHApp.CustomScreenScale);
        //}

        //public double GetStatusBarHeightEx(double canvasViewWidth, double canvasViewHeight, bool usingDesktopButtons, bool usingSimpleCmdLayout, float inverseCanvasScale, float customScale)
        //{
        //    if(inverseCanvasScale == 0.0f) 
        //        inverseCanvasScale = 1.0f;
        //    float statusbarheight = GetStatusBarSkiaHeightEx(canvasViewWidth, canvasViewHeight, usingDesktopButtons, usingSimpleCmdLayout, inverseCanvasScale, customScale);
        //    return (double)statusbarheight / (double)inverseCanvasScale;
        //}

        //public double GetStatusBarHeightEx2()
        //{
        //    return GetStatusBarHeightEx2(GHApp.DisplayDensity, GHApp.CustomScreenScale);
        //}

        public double GetStatusBarHeightEx2(float inverseCanvasScale, float customScale, double canvasViewWidth, double canvasViewHeight)
        {
            if (inverseCanvasScale == 0.0f)
                inverseCanvasScale = 1.0f;
            float statusbarheight = UIUtils.CalculateStatusBarSkiaHeight(inverseCanvasScale, customScale, canvasViewWidth, canvasViewHeight);
            return (double)statusbarheight / (double)inverseCanvasScale;
        }

        private SKImage GetStatIcon(int i)
        {
            SKImage statIcon;
            switch (i)
            {
                default:
                case 0:
                    statIcon = GHApp._statusStrBitmap;
                    break;
                case 1:
                    statIcon = GHApp._statusDexBitmap;
                    break;
                case 2:
                    statIcon = GHApp._statusConBitmap;
                    break;
                case 3:
                    statIcon = GHApp._statusIntBitmap;
                    break;
                case 4:
                    statIcon = GHApp._statusWisBitmap;
                    break;
                case 5:
                    statIcon = GHApp._statusChaBitmap;
                    break;
            }
            return statIcon;
        }

        private SKImage GetAlignmentIcon(string alignment)
        {
            return GHApp._statusAlignmentLawfulBitmap;
            //if (alignment == null || alignment.Length < 3)
            //    return GHApp._statusAlignmentUnknownBitmap;
            //else
            //{
            //    string lcAlign = alignment.Substring(0, 3).ToLower();
            //    if (lcAlign == "law")
            //        return GHApp._statusAlignmentLawfulBitmap;
            //    else if (lcAlign == "neu")
            //        return GHApp._statusAlignmentNeutralBitmap;
            //    else if (lcAlign == "cha")
            //        return GHApp._statusAlignmentChaoticBitmap;
            //    else
            //        return GHApp._statusAlignmentUnknownBitmap;
            //}
        }

        private ConcurrentDictionary<long, TouchEntry> TouchDictionary = new ConcurrentDictionary<long, TouchEntry>();
        private readonly object _mapOffsetLock = new object();
        public float _mapOffsetX = 0;
        public float _mapOffsetY = 0;
        public float _mapMiniOffsetX = 0;
        public float _mapMiniOffsetY = 0;
        private readonly object _statusOffsetLock = new object();
        public float _statusOffsetY = 0;
        public float _statusLargestBottom = 0;
        public float _statusClipBottom = 0;
        private bool _touchMoved = false;
        private bool _touchWithinSkillButton = false;
        private bool _touchWithinPrevWepButton = false;
        private bool _touchWithinHealthOrb = false;
        private bool _touchWithinManaOrb = false;
        private bool _touchWithinStatusBar = false;
        private uint _touchWithinPet = 0;
        private bool _touchWithinYouButton = false;
        private int _touchWithinContextButton = 0;
        private object _savedSender = null;
        private SKTouchEventArgs _savedEventArgs = null;


        private float _interlockedMessageScrollOffset = 0;
        private float InterlockedMessageScrollOffset { get { return Interlocked.CompareExchange(ref _interlockedMessageScrollOffset, 0.0f, 0.0f); } set { Interlocked.Exchange(ref _interlockedMessageScrollOffset, value); } }
        public float _interlockedMessageSmallestTop = 0;
        private float InterlockedMessageSmallestTop { get { return Interlocked.CompareExchange(ref _interlockedMessageSmallestTop, 0.0f, 0.0f); } set { Interlocked.Exchange(ref _interlockedMessageSmallestTop, value); } }
        private readonly object _messageScrollLock = new object();
        public float _messageScrollOffset = 0;
        private float _messageScrollSpeed = 0; /* pixels per second */
        private bool _messageScrollSpeedRecordOn = false;
        private DateTime _messageScrollSpeedStamp;
        List<TouchSpeedRecord> _messageScrollSpeedRecords = new List<TouchSpeedRecord>();
        private bool _messageScrollSpeedOn = false;
        private DateTime _messageScrollSpeedReleaseStamp;


        private void canvasView_Touch(object sender, SKTouchEventArgs e)
        {
            canvasView_Touch_MainPage(sender, e);
        }

        private readonly object _uiRectLock = new object();
        private SKRect _uiStatusBarRect;
        private SKRect _uiHealthRect;
        private SKRect _uiManaRect;
        private SKRect _uiSkillRect;
        private SKRect _uiPrevWepRect;
        private SKRect _uiYouRect;

        private SKRect _uiLocalStatusBarRect;
        private SKRect _uiLocalHealthRect;
        private SKRect _uiLocalManaRect;
        private SKRect _uiLocalSkillRect;
        private SKRect _uiLocalPrevWepRect;
        private SKRect _uiLocalYouRect;

        private void canvasView_Touch_MainPage(object sender, SKTouchEventArgs e)
        {
            GHGame curGame = GHApp.CurrentGHGame;
            if (curGame != null)
            {
                bool lockTaken = false;
                //lock (_uiRectLock)
                try
                {
                    Monitor.TryEnter(_uiRectLock, ref lockTaken);
                    if (lockTaken)
                    {
                        _uiLocalStatusBarRect = _uiStatusBarRect;
                        _uiLocalHealthRect = _uiHealthRect;
                        _uiLocalManaRect = _uiManaRect;
                        _uiLocalSkillRect = _uiSkillRect;
                        _uiLocalPrevWepRect = _uiPrevWepRect;
                        _uiLocalYouRect = _uiYouRect;
                    }
                }
                finally
                {
                    if (lockTaken)
                        Monitor.Exit(_uiRectLock);
                }
                lockTaken = false;

                switch (e?.ActionType)
                {
                    case SKTouchAction.Entered:
                        break;
                    case SKTouchAction.Pressed:
                        _savedSender = null;
                        _savedEventArgs = null;
                        _touchWithinSkillButton = false;
                        _touchWithinPrevWepButton = false;
                        _touchWithinHealthOrb = false;
                        _touchWithinManaOrb = false;
                        _touchWithinStatusBar = false;
                        _touchWithinPet = 0;
                        _touchWithinYouButton = false;
                        _touchWithinContextButton = 0;

                        if (TouchDictionary.ContainsKey(e.Id))
                            TouchDictionary[e.Id] = new TouchEntry(e.Location, DateTime.Now);
                        else
                            TouchDictionary.TryAdd(e.Id, new TouchEntry(e.Location, DateTime.Now));

                        if (TouchDictionary.Count > 1)
                            _touchMoved = true;
                        else if (!ForceAllMessages && !ShowExtendedStatusBar)
                        {
                            uint m_id = 0;
                            int cmd = 0;
                            if (_uiLocalSkillRect.Contains(e.Location))
                            {
                                _touchWithinSkillButton = true;
                            }
                            else if (_uiLocalPrevWepRect.Contains(e.Location))
                            {
                                _touchWithinPrevWepButton = true;
                            }
                            else if (_uiLocalHealthRect.Contains(e.Location))
                            {
                                _touchWithinHealthOrb = true;
                            }
                            else if (_uiLocalManaRect.Contains(e.Location))
                            {
                                _touchWithinManaOrb = true;
                            }
                            else if (_uiLocalStatusBarRect.Contains(e.Location))
                            {
                                _touchWithinStatusBar = true;
                            }
                            else if ((cmd = PointWithinContextMenuButton(e.Location)) != 0)
                            {
                                _touchWithinContextButton = cmd;
                            }
                            else if (!ShowDirections && !ShowNumberPad && ShowPets && (m_id = PetRectContains(e.Location)) != 0)
                            {
                                _touchWithinPet = m_id;
                            }
                            else if (!MapLookMode && !MapTravelMode)
                            {
                                _savedSender = sender;
                                _savedEventArgs = e;
#if GNH_MAUI
                                var timer = Microsoft.Maui.Controls.Application.Current.Dispatcher.CreateTimer();
                                timer.Interval = TimeSpan.FromSeconds(GHConstants.MoveByHoldingDownThreshold);
                                timer.IsRepeating = true;
                                timer.Tick += (s, e) => { if(!DoMoveByHoldingDown()) timer.Stop(); };
                                timer.Start();
#else
                                Device.StartTimer(TimeSpan.FromSeconds(GHConstants.MoveByHoldingDownThreshold), () =>
                                {
                                    return DoMoveByHoldingDown();
                                });
#endif
                            }
                        }
                        else if (ShowExtendedStatusBar)
                        {
                            if (_uiLocalYouRect.Contains(e.Location))
                            {
                                _touchWithinYouButton = true;
                            }
                        }
                        else if (ForceAllMessages)
                        {
                            lock (_messageScrollLock)
                            {
                                _messageScrollSpeed = 0;
                                _messageScrollSpeedOn = false;
                                _messageScrollSpeedRecordOn = false;
                                _messageScrollSpeedRecords.Clear();
                            }
                        }
                        e.Handled = true;
                        break;
                    case SKTouchAction.Moved:
                        {
                            TouchEntry entry;
                            bool res = TouchDictionary.TryGetValue(e.Id, out entry);
                            if (res)
                            {
                                SKPoint anchor = entry.Location;

                                float diffX = e.Location.X - anchor.X;
                                float diffY = e.Location.Y - anchor.Y;
                                float dist = (float)Math.Sqrt((Math.Pow(diffX, 2) + Math.Pow(diffY, 2)));

                                if (TouchDictionary.Count == 1)
                                {
                                    if (_touchWithinSkillButton || _touchWithinPrevWepButton || _touchWithinHealthOrb || _touchWithinManaOrb || _touchWithinStatusBar || (_touchWithinPet > 0 && !ShowDirections && !ShowNumberPad) || _touchWithinYouButton || _touchWithinContextButton != 0)
                                    {
                                        /* Do nothing */
                                    }
                                    else if (!MapLookMode && !MapTravelMode && !ForceAllMessages && !ShowExtendedStatusBar)
                                    {
                                        /* Move the save location */
                                        _savedSender = sender;
                                        _savedEventArgs = e;
                                    }
                                    else if (/*!ZoomMiniMode && */ (dist > GHConstants.MoveDistanceThreshold ||
                                        (DateTime.Now.Ticks - entry.PressTime.Ticks) / TimeSpan.TicksPerMillisecond > GHConstants.MoveOrPressTimeThreshold
                                           ))
                                    {
                                        /* Just one finger => Move the map */
                                        if (diffX != 0 || diffY != 0)
                                        {
                                            if (ShowExtendedStatusBar)
                                            {
                                                lock (_statusOffsetLock)
                                                {
                                                    if (diffY < 0)
                                                    {
                                                        if (_statusLargestBottom > _statusClipBottom)
                                                        {
                                                            _statusOffsetY += -Math.Min(_statusLargestBottom - _statusClipBottom, -diffY);
                                                        }
                                                    }
                                                    else
                                                        _statusOffsetY += diffY;

                                                    if (_statusOffsetY > 0)
                                                    {
                                                        _statusOffsetY = 0;
                                                    }
                                                }
                                            }
                                            else if (ForceAllMessages)
                                            {
                                                //lock (_messageScrollLock)
                                                //{
                                                //    if (diffY > 0)
                                                //    {
                                                //        if (_messageSmallestTop < 0)
                                                //        {
                                                //            _messageScrollOffset += Math.Min(-_messageSmallestTop, diffY);
                                                //        }
                                                //    }
                                                //    else
                                                //        _messageScrollOffset += diffY;

                                                //    if (_messageScrollOffset < 0)
                                                //    {
                                                //        _messageScrollOffset = 0;
                                                //    }
                                                //}

                                                DateTime now = DateTime.Now;
                                                /* Do not scroll within button press time threshold, unless large move */
                                                long millisecs_elapsed = (now.Ticks - entry.PressTime.Ticks) / TimeSpan.TicksPerMillisecond;
                                                if (dist > GHConstants.MoveDistanceThreshold || millisecs_elapsed > GHConstants.MoveOrPressTimeThreshold)
                                                {
                                                    float canvasheight;
                                                    lock (_savedCanvasLock)
                                                    {
                                                        canvasheight = _savedCanvasHeight;
                                                    }
                                                    lock (_messageScrollLock)
                                                    {
                                                        float topScrollLimit = Math.Max(0, -InterlockedMessageSmallestTop);
                                                        float stretchLimit = GHConstants.ScrollStretchLimit * canvasheight;
                                                        float stretchConstant = GHConstants.ScrollConstantStretch * canvasheight;
                                                        float adj_factor = 1.0f;
                                                        if (_messageScrollOffset > topScrollLimit)
                                                            adj_factor = _messageScrollOffset >= topScrollLimit + stretchLimit ? 0 : (1 - ((_messageScrollOffset - topScrollLimit + stretchConstant) / (stretchLimit + stretchConstant)));
                                                        else if (_messageScrollOffset < 0)
                                                            adj_factor = _messageScrollOffset < 0 - stretchLimit ? 0 : (1 - ((0 - (_messageScrollOffset - stretchConstant)) / (stretchLimit + stretchConstant)));

                                                        float adj_diffY = diffY * adj_factor;
                                                        _messageScrollOffset += adj_diffY;

                                                        if (_messageScrollOffset > stretchLimit + topScrollLimit)
                                                            _messageScrollOffset = stretchLimit;
                                                        else if (_messageScrollOffset < 0 - stretchLimit)
                                                            _messageScrollOffset = 0 - stretchLimit;
                                                        else
                                                        {
                                                            /* Calculate duration since last touch move */
                                                            float duration = 0;
                                                            if (!_messageScrollSpeedRecordOn)
                                                            {
                                                                duration = (float)millisecs_elapsed / 1000f;
                                                                _messageScrollSpeedRecordOn = true;
                                                            }
                                                            else
                                                            {
                                                                duration = ((float)(now.Ticks - _messageScrollSpeedStamp.Ticks) / TimeSpan.TicksPerMillisecond) / 1000f;
                                                            }
                                                            _messageScrollSpeedStamp = now;

                                                            /* Discard speed records to the opposite direction */
                                                            if (_messageScrollSpeedRecords.Count > 0)
                                                            {
                                                                int prevsgn = Math.Sign(_messageScrollSpeedRecords[0].Distance);
                                                                if (diffY != 0 && prevsgn != 0 && Math.Sign(diffY) != prevsgn)
                                                                    _messageScrollSpeedRecords.Clear();
                                                            }

                                                            /* Add a new speed record */
                                                            _messageScrollSpeedRecords.Insert(0, new TouchSpeedRecord(diffY, duration, now));

                                                            /* Discard too old records */
                                                            while (_messageScrollSpeedRecords.Count > 0)
                                                            {
                                                                long lastrecord_ms = (now.Ticks - _messageScrollSpeedRecords[_messageScrollSpeedRecords.Count - 1].TimeStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                                                                if (lastrecord_ms > GHConstants.ScrollRecordThreshold)
                                                                    _messageScrollSpeedRecords.RemoveAt(_messageScrollSpeedRecords.Count - 1);
                                                                else
                                                                    break;
                                                            }

                                                            /* Sum up the distances and durations of current records to get an average */
                                                            float totaldistance = 0;
                                                            float totalsecs = 0;
                                                            foreach (TouchSpeedRecord r in _messageScrollSpeedRecords)
                                                            {
                                                                totaldistance += r.Distance;
                                                                totalsecs += r.Duration;
                                                            }
                                                            _messageScrollSpeed = totaldistance / Math.Max(0.001f, totalsecs);
                                                            _messageScrollSpeedOn = false;
                                                        }
                                                        InterlockedMessageScrollOffset = _messageScrollOffset;
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                float mapWidth;
                                                float mapHeight;
                                                lock (_tileSizeLock)
                                                {
                                                    mapWidth = _mapWidth;
                                                    mapHeight = _mapHeight;
                                                }
                                                lock (_mapOffsetLock)
                                                {
                                                    if (ZoomMiniMode)
                                                    {
                                                        _mapMiniOffsetX += diffX;
                                                        _mapMiniOffsetY += diffY;
                                                        if (mapWidth > 0 && Math.Abs(_mapMiniOffsetX) > 1 * mapWidth)
                                                        {
                                                            _mapMiniOffsetX = 1 * mapWidth * Math.Sign(_mapMiniOffsetX);
                                                        }
                                                        if (mapHeight > 0 && Math.Abs(_mapMiniOffsetY) > 1 * mapHeight)
                                                        {
                                                            _mapMiniOffsetY = 1 * mapHeight * Math.Sign(_mapMiniOffsetY);
                                                        }
                                                    }
                                                    else
                                                    {
                                                        _mapOffsetX += diffX;
                                                        _mapOffsetY += diffY;
                                                        if (mapWidth > 0 && Math.Abs(_mapOffsetX) > 10 * mapWidth)
                                                        {
                                                            _mapOffsetX = 10 * mapWidth * Math.Sign(_mapOffsetX);
                                                        }
                                                        if (mapHeight > 0 && Math.Abs(_mapOffsetY) > 10 * mapHeight)
                                                        {
                                                            _mapOffsetY = 10 * mapHeight * Math.Sign(_mapOffsetY);
                                                        }
                                                    }
                                                }
                                            }

                                            TouchDictionary[e.Id].Location = e.Location;
                                            _touchMoved = true;
                                        }
                                    }

                                }
                                else if (TouchDictionary.Count == 2)
                                {
                                    _savedSender = null;
                                    _savedEventArgs = null;
                                    _touchWithinSkillButton = false;
                                    _touchWithinPrevWepButton = false;
                                    _touchWithinHealthOrb = false;
                                    _touchWithinManaOrb = false;
                                    _touchWithinStatusBar = false;
                                    _touchWithinPet = 0;
                                    _touchWithinYouButton = false;
                                    _touchWithinContextButton = 0;

                                    SKPoint prevloc = TouchDictionary[e.Id].Location;
                                    SKPoint curloc = e.Location;
                                    SKPoint otherloc;

                                    var keys = TouchDictionary.Keys;
                                    long other_key = 0;
                                    foreach (long key in keys)
                                    {
                                        if (key != e.Id)
                                        {
                                            other_key = key;
                                            break;
                                        }
                                    }

                                    if (other_key != 0 /* && !ZoomMiniMode */)
                                    {
                                        otherloc = TouchDictionary[other_key].Location;
                                        float prevdist = (float)Math.Sqrt((Math.Pow((double)otherloc.X - (double)prevloc.X, 2) + Math.Pow((double)otherloc.Y - (double)prevloc.Y, 2)));
                                        float curdist = (float)Math.Sqrt((Math.Pow((double)otherloc.X - (double)curloc.X, 2) + Math.Pow((double)otherloc.Y - (double)curloc.Y, 2)));
                                        if (prevdist > 0 && curdist > 0)
                                        {
                                            float ratio = curdist / prevdist;
                                            AdjustZoomByRatio(ratio, curloc, prevloc, otherloc);
                                            MapFontShowPercentageDecimal = false;
                                        }
                                    }

                                    TouchDictionary[e.Id].Location = e.Location;
                                    _touchMoved = true;
                                }
                            }
                            e.Handled = true;
                        }
                        break;
                    case SKTouchAction.Released:
                        {
                            _savedSender = null;
                            _savedEventArgs = null;

                            if(ForceAllMessages)
                            {
                                TouchEntry entry;
                                bool res = TouchDictionary.TryGetValue(e.Id, out entry);
                                if (res)
                                {
                                    long elapsedms = (DateTime.Now.Ticks - entry.PressTime.Ticks) / TimeSpan.TicksPerMillisecond;
                                    if (elapsedms <= GHConstants.MoveOrPressTimeThreshold && !_touchMoved)
                                    {
                                        ToggleMessageNumberButton_Clicked(sender, e);
                                    }
                                    else if (TouchDictionary.Count == 1) /* Not removed yet */
                                    {
                                        float canvasheight;
                                        lock (_savedCanvasLock)
                                        {
                                            canvasheight = _savedCanvasHeight;
                                        }
                                        lock (_messageScrollLock)
                                        {
                                            float topScrollLimit = Math.Max(0, -InterlockedMessageSmallestTop);
                                            long lastrecord_ms = 0;
                                            if (_messageScrollSpeedRecords.Count > 0)
                                            {
                                                lastrecord_ms = (DateTime.Now.Ticks - _messageScrollSpeedRecords[_messageScrollSpeedRecords.Count - 1].TimeStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                                            }

                                            if (_messageScrollOffset > topScrollLimit || _messageScrollOffset < 0)
                                            {
                                                if (lastrecord_ms > GHConstants.ScrollRecordThreshold
                                                    || Math.Abs(_messageScrollSpeed) < GHConstants.ScrollSpeedThreshold * canvasheight)
                                                    _messageScrollSpeed = 0;

                                                _messageScrollSpeedOn = true;
                                                _messageScrollSpeedReleaseStamp = DateTime.Now;
                                            }
                                            else if (lastrecord_ms > GHConstants.ScrollRecordThreshold)
                                            {
                                                _messageScrollSpeedOn = false;
                                                _messageScrollSpeed = 0;
                                            }
                                            else if (Math.Abs(_messageScrollSpeed) >= GHConstants.ScrollSpeedThreshold * canvasheight)
                                            {
                                                _messageScrollSpeedOn = true;
                                                _messageScrollSpeedReleaseStamp = DateTime.Now;
                                            }
                                            else
                                            {
                                                _messageScrollSpeedOn = false;
                                                _messageScrollSpeed = 0;
                                            }
                                            _messageScrollSpeedRecordOn = false;
                                            _messageScrollSpeedRecords.Clear();
                                        }
                                        _touchMoved = false;
                                    }
                                }
                            }
                            else if (_touchWithinSkillButton && !PlayingReplay)
                            {
                                GenericButton_Clicked(sender, e, (int)'S');
                            }
                            else if (_touchWithinPrevWepButton && !PlayingReplay)
                            {
                                GenericButton_Clicked(sender, e, GHUtils.Meta('P'));
                            }
                            else if (_touchWithinContextButton != 0 && !PlayingReplay)
                            {
                                GenericButton_Clicked(sender, e, _touchWithinContextButton);
                            }
                            else if (_touchWithinHealthOrb)
                            {
                                ShowMaxHealthInOrb = !ShowMaxHealthInOrb;
                            }
                            else if (_touchWithinManaOrb)
                            {
                                ShowMaxManaInOrb = !ShowMaxManaInOrb;
                            }
                            else if (_touchWithinStatusBar)
                            {
                                ShowExtendedStatusBar = !ShowExtendedStatusBar;
                                //if (ShowExtendedStatusBar)
                                //    ToggleShowUI();
                                lock (_statusOffsetLock)
                                {
                                    _statusOffsetY = 0.0f;
                                }
                            }
                            else if (_touchWithinYouButton && !PlayingReplay)
                            {
                                ShowExtendedStatusBar = false;
                                GenericButton_Clicked(sender, e, (int)'}');
                            }
                            else if (_touchWithinPet > 0 && !ShowDirections && !ShowNumberPad && !PlayingReplay)
                            {
                                curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SetPetMID, _touchWithinPet));
                                curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.GetChar, (int)'{'));
                            }
                            else if (!PlayingReplay || ShowExtendedStatusBar)
                            {
                                TouchEntry entry;
                                bool res = TouchDictionary.TryGetValue(e.Id, out entry);
                                if (res)
                                {
                                    long elapsedms = (DateTime.Now.Ticks - entry.PressTime.Ticks) / TimeSpan.TicksPerMillisecond;

                                    if (elapsedms <= GHConstants.MoveOrPressTimeThreshold && !_touchMoved)
                                    {
                                        if (ShowExtendedStatusBar)
                                        {
                                            ShowExtendedStatusBar = false;
                                            lock (_statusOffsetLock)
                                            {
                                                _statusOffsetY = 0.0f;
                                            }
                                        }
                                        else
                                            IssueNHCommandViaTouch(sender, e);
                                    }
                                }
                            }
                            if (TouchDictionary.ContainsKey(e.Id))
                            {
                                TouchEntry removedEntry;
                                TouchDictionary.TryRemove(e.Id, out removedEntry);
                            }
                            else
                                TouchDictionary.Clear(); /* Something's wrong; reset the touch dictionary */

                            if (TouchDictionary.Count == 0)
                                _touchMoved = false;

                            e.Handled = true;
                        }
                        break;
                    case SKTouchAction.Cancelled:
                        if (TouchDictionary.ContainsKey(e.Id))
                        {
                            TouchEntry removedEntry;
                            TouchDictionary.TryRemove(e.Id, out removedEntry);
                        }
                        else
                            TouchDictionary.Clear(); /* Something's wrong; reset the touch dictionary */

                        if(ForceAllMessages)
                        {
                            float canvasheight;
                            lock (_savedCanvasLock)
                            {
                                canvasheight = _savedCanvasHeight;
                            }
                            lock (_messageScrollLock)
                            {
                                float topScrollLimit = Math.Max(0, -InterlockedMessageSmallestTop);
                                if (_messageScrollOffset > topScrollLimit || _messageScrollOffset < 0)
                                {
                                    long lastrecord_ms = 0;
                                    if (_messageScrollSpeedRecords.Count > 0)
                                    {
                                        lastrecord_ms = (DateTime.Now.Ticks - _messageScrollSpeedRecords[_messageScrollSpeedRecords.Count - 1].TimeStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                                    }

                                    if (lastrecord_ms > GHConstants.ScrollRecordThreshold
                                        || Math.Abs(_messageScrollSpeed) < GHConstants.ScrollSpeedThreshold * canvasheight)
                                        _messageScrollSpeed = 0;

                                    _messageScrollSpeedOn = true;
                                    _messageScrollSpeedReleaseStamp = DateTime.Now;
                                }
                            }
                        }
                        e.Handled = true;
                        break;
                    case SKTouchAction.Exited:
                        break;
                    case SKTouchAction.WheelChanged:
                        break;
                    default:
                        break;
                }
            }
        }

        private readonly object _uiContextMenuRectLock = new object();
        private List<ContextMenuButton> _uiContextMenuData = new List<ContextMenuButton>(10);
        private List<SKRect> _uiContextMenuRects = new List<SKRect>(10);

        private int PointWithinContextMenuButton(SKPoint point)
        {
            lock (_uiContextMenuRectLock)
            {
                int cbIdx = -1;
                foreach (ContextMenuButton cmb in _uiContextMenuData)
                {
                    cbIdx++;
                    if (cbIdx < _uiContextMenuRects.Count && _uiContextMenuRects[cbIdx].Contains(point))
                        return cmb?.BtnCommand ?? 0;
                }
            }
            return 0;

        }

        private bool _showUI = true;
        private void ToggleShowUI()
        {
            MainThread.BeginInvokeOnMainThread(() =>
            {
                _showUI = !_showUI;
                UIGrid.IsVisible = _showUI;
                if (!DesktopButtons)
                {
                    lWornItemsButton.IsVisible = _showUI;
                    lAbilitiesButton.IsVisible = _showUI;
                }
            });
        }

        private void AdjustZoomByRatio(float ratio, SKPoint curloc, SKPoint prevloc, SKPoint otherloc)
        {
            float curfontsize = ZoomMiniMode ? MapFontMiniRelativeSize : ZoomAlternateMode ? MapFontAlternateSize : MapFontSize;
            float newfontsize = curfontsize * ratio;
            SetZoomFontSize(newfontsize, curloc, prevloc, otherloc);
        }

        private void SetZoomFontSize(float newfontsize, SKPoint curloc, SKPoint prevloc, SKPoint otherloc)
        {
            float curfontsize = ZoomMiniMode ? MapFontMiniRelativeSize : ZoomAlternateMode ? MapFontAlternateSize : MapFontSize;
            if (ZoomMiniMode)
            {
                if (newfontsize > GHConstants.MaximumMapMiniRelativeFontSize)
                    newfontsize = GHConstants.MaximumMapMiniRelativeFontSize;
                if (newfontsize < GHConstants.MinimumMapMiniRelativeFontSize)
                    newfontsize = GHConstants.MinimumMapMiniRelativeFontSize;
            }
            else
            {
                if (newfontsize > GHConstants.MaximumMapFontSize)
                    newfontsize = GHConstants.MaximumMapFontSize;
                if (newfontsize < GHConstants.MinimumMapFontSize)
                    newfontsize = GHConstants.MinimumMapFontSize;
            }

            float newratio = newfontsize / Math.Max(1f, curfontsize);
            float mapFontAscent = UsedMapFontAscent;
            if (ZoomMiniMode)
                MapFontMiniRelativeSize = newfontsize;
            else if (ZoomAlternateMode)
                MapFontAlternateSize = newfontsize;
            else
                MapFontSize = newfontsize;

            float usedTileWidth;
            float usedTileHeight;
            float mapWidth;
            float mapHeight;
            lock (_tileSizeLock)
            {
                usedTileWidth = _usedTileWidth;
                usedTileHeight = _usedTileHeight;
                mapWidth = _mapWidth;
                mapHeight = _mapHeight;
            }

            if (ZoomMiniMode)
            {
                lock (_mapOffsetLock)
                {
                    _mapMiniOffsetX *= newratio;
                    _mapMiniOffsetY *= newratio;
                    if (mapWidth > 0 && Math.Abs(_mapMiniOffsetX) > 1 * mapWidth)
                    {
                        _mapMiniOffsetX = 1 * mapWidth * Math.Sign(_mapMiniOffsetX);
                    }
                    if (mapHeight > 0 && Math.Abs(_mapMiniOffsetY) > 1 * mapHeight)
                    {
                        _mapMiniOffsetY = 1 * mapHeight * Math.Sign(_mapMiniOffsetY);
                    }
                }
            }
            else
            {
                float width = usedTileWidth;
                float height = usedTileHeight;
                float mapwidth = width * (GHConstants.MapCols - 1);
                float mapheight = height * (GHConstants.MapRows);
                float canvaswidth;
                float canvasheight;
                lock (_savedCanvasLock)
                {
                    canvaswidth = _savedCanvasWidth;
                    canvasheight = _savedCanvasHeight;
                }
                if (canvaswidth <= 0 || canvasheight <= 0)
                    return;

                float offsetX, offsetY, usedOffsetX, usedOffsetY;
                GetMapOffsets(canvaswidth, canvasheight, mapwidth, mapheight, width, height, out offsetX, out offsetY, out usedOffsetX, out usedOffsetY);
                float totalOffsetX = offsetX + usedOffsetX;
                float totalOffsetY = offsetY + usedOffsetY + mapFontAscent;
                SKPoint oldLoc = new SKPoint((prevloc.X + otherloc.X) / 2, (prevloc.Y + otherloc.Y) / 2);
                SKPoint newLoc = new SKPoint((curloc.X + otherloc.X) / 2, (curloc.Y + otherloc.Y) / 2);
                float newTotalOffsetX = newLoc.X - (oldLoc.X - totalOffsetX) * newratio;
                float newTotalOffsetY = newLoc.Y - (oldLoc.Y - totalOffsetY) * newratio;
                float newWidth = width * newratio;
                float newHeight = height * newratio;
                float newMapwidth = newWidth * (GHConstants.MapCols - 1);
                float newMapheight = newHeight * (GHConstants.MapRows);
                float newMapFontAscent = mapFontAscent * newratio;
                float newOffsetX, newOffsetY, newUsedOffsetX, newUsedOffsetY;
                GetMapOffsets(canvaswidth, canvasheight, newMapwidth, newMapheight, newWidth, newHeight, out newOffsetX, out newOffsetY, out newUsedOffsetX, out newUsedOffsetY);

                lock (_mapOffsetLock)
                {
                    _mapOffsetX = newTotalOffsetX - newOffsetX;
                    _mapOffsetY = newTotalOffsetY - newOffsetY - newMapFontAscent;
                    if (mapWidth > 0 && Math.Abs(_mapOffsetX) > 10 * mapWidth)
                    {
                        _mapOffsetX = 10 * mapWidth * Math.Sign(_mapOffsetX);
                    }
                    if (mapHeight > 0 && Math.Abs(_mapOffsetY) > 10 * mapHeight)
                    {
                        _mapOffsetY = 10 * mapHeight * Math.Sign(_mapOffsetY);
                    }
                }
            }
        }

        private void canvasView_MouseWheel(object sender, GHMouseWheelEventArgs e)
        {
            if(e.MouseWheelDelta != 0)
            {
                if (ForceAllMessages)
                {
                    ScrollMessages(e.MouseWheelDelta);
                }
                else
                {
                    float ratio = 1.1f * (float)Math.Abs(e.MouseWheelDelta) / 120;
                    float canvaswidth;
                    float canvasheight;
                    lock (_savedCanvasLock)
                    {
                        canvaswidth = _savedCanvasWidth;
                        canvasheight = _savedCanvasHeight;
                    }
                    if (canvaswidth <= 0 || canvasheight <= 0)
                        return;
                    SKPoint point = new SKPoint(canvaswidth / 2, canvasheight / 2);
                    AdjustZoomByRatio(e.MouseWheelDelta < 0 ? 1.0f / ratio : ratio, point, point, point);
                    MapFontShowPercentageDecimal = false;
                }
            }
        }

#if WINDOWS
        private readonly object _canvasPointerLock = new object();
        private bool _isCanvasHovering = false;
        private SKPoint _canvasHoverLocation = new SKPoint();
#endif

        private void canvasView_MousePointer(object sender, SKTouchEventArgs e)
        {
#if WINDOWS
            lock (_canvasPointerLock)
            {
                _canvasHoverLocation = e.Location;
                switch (e.ActionType)
                {
                    case SKTouchAction.Entered:
                    case SKTouchAction.Moved:
                        _isCanvasHovering = true;
                        break;
                    case SKTouchAction.Exited:
                    case SKTouchAction.Cancelled:
                        _isCanvasHovering = false;
                        break;
                }
            }
#endif
        }

        private void ScrollMessages(int delta)
        {
            if (delta != 0)
            {
                float canvasheight;
                lock (_savedCanvasLock)
                {
                    canvasheight = _savedCanvasHeight;
                }
                if (canvasheight <= 0)
                    return;

                lock (_messageScrollLock)
                {
                    float topScrollLimit = Math.Max(0, -InterlockedMessageSmallestTop);
                    float scrollAmount = (canvasheight * delta) / (10 * 120);
                    _messageScrollOffset += scrollAmount;

                    if (_messageScrollOffset > topScrollLimit)
                        _messageScrollOffset = topScrollLimit;
                    else if (_messageScrollOffset < 0)
                        _messageScrollOffset = 0;

                    _messageScrollSpeedOn = false;
                    _messageScrollSpeed = 0;
                    _messageScrollSpeedRecordOn = false;
                    _messageScrollSpeedRecords.Clear();
                    InterlockedMessageScrollOffset = _messageScrollOffset;
                }
            }
        }


        private bool DoMoveByHoldingDown()
        {
            if (_savedSender == null || _savedEventArgs == null)
                return false;

            IssueNHCommandViaTouch(_savedSender, _savedEventArgs);
            return true; /* Continue until cancelled */
        }

        private readonly object _uiPetRectLock = new object();
        private List<GHPetDataItem> _uiPetData = new List<GHPetDataItem>(8);
        private List<SKRect> _uiPetRects = new List<SKRect>(8);

        public uint PetRectContains(SKPoint p)
        {
            lock(_uiPetRectLock)
            {
                int pdiIdx = -1;
                foreach (GHPetDataItem pdi in _uiPetData)
                {
                    pdiIdx++;
                    if (pdiIdx < _uiPetRects.Count && _uiPetRects[pdiIdx].Contains(p))
                        return pdi?.Data.m_id ?? 0;
                }
            }
            return 0;
        }

        public void IssueNHCommandViaTouch(object sender, SKTouchEventArgs e)
        {
            GHGame curGame = GHApp.CurrentGHGame;
            int x = 0, y = 0, mod = 0;
            float canvaswidth;
            float canvasheight;
            lock(_savedCanvasLock)
            {
                canvaswidth = _savedCanvasWidth;
                canvasheight = _savedCanvasHeight;
            }
            if (canvaswidth <= 0 || canvasheight <= 0)
                return;

            float usedTileWidth;
            float usedTileHeight;
            float mapWidth;
            float mapHeight;
            lock (_tileSizeLock)
            {
                usedTileWidth = _usedTileWidth;
                usedTileHeight = _usedTileHeight;
                mapWidth = _mapWidth;
                mapHeight = _mapHeight;
            }
            float offsetX = (canvaswidth - mapWidth) / 2;
            float offsetY = (canvasheight - mapHeight) / 2;

            if (ZoomMiniMode)
            {
                lock (_mapOffsetLock)
                {
                    offsetX -= _mapOffsetX;
                    offsetY -= _mapOffsetY;
                    offsetX += _mapMiniOffsetX;
                    offsetY += _mapMiniOffsetY;
                }
            }
            else
            {
                lock (_clipLock)
                {
                    if (_clipX > 0 && (mapWidth > canvaswidth || mapHeight > canvasheight))
                    {
                        offsetX -= (_clipX - (GHConstants.MapCols - 1) / 2) * usedTileWidth;
                        offsetY -= (_clipY - GHConstants.MapRows / 2) * usedTileHeight;
                    }
                }
            }

            lock (_mapOffsetLock)
            {
                offsetX += _mapOffsetX;
                offsetY += _mapOffsetY + UsedMapFontAscent;
            }

            if (usedTileWidth > 0)
                x = (int)((e.Location.X - offsetX) / usedTileWidth);
            if (usedTileHeight > 0)
                y = (int)((e.Location.Y - offsetY) / usedTileHeight);

            if (!ShowDirections && !ShowNumberPad && !(MapWalkMode && WalkArrows))
            {
                if (x > 0 && x < GHConstants.MapCols && y >= 0 && y < GHConstants.MapRows)
                {
                    if (MapLookMode)
                        mod = (int)NhGetPosMods.ClickLook;
                    else if (e.MouseButton == SKMouseButton.Right)
                        mod = (int)NhGetPosMods.ClickSecondary;
                    else if (e.MouseButton == SKMouseButton.Middle)
                        mod = (int)NhGetPosMods.ClickTertiary;
                    else if (MapTravelMode)
                        mod = (int)NhGetPosMods.ClickPrimary;
                    else
                        mod = (int)NhGetPosMods.ClickMove;

                    curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.Location, x, y, mod));
                }
            }
            else
            {
                float buttonsize = ShowNumberPad ? GHConstants.NumberButtonSize : ShowDirections ? GHConstants.ArrowButtonSize : GHConstants.MoveArrowButtonSize;
                SKRect canvasRect;
                lock (_canvasButtonLock)
                {
                    canvasRect = _canvasButtonRect;
                }
                //lock (_canvasButtonLock)
                {
                    if (e.Location.X >= canvasRect.Left && e.Location.X <= canvasRect.Right && e.Location.Y >= canvasRect.Top && e.Location.Y <= canvasRect.Bottom)
                    {
                        int resp = 0;
                        SKPoint RectLoc = new SKPoint(e.Location.X - canvasRect.Left, e.Location.Y - canvasRect.Top);

                        if (RectLoc.Y < canvasRect.Height * buttonsize && RectLoc.X < canvasRect.Width * buttonsize)
                            resp += -7;
                        else if (RectLoc.Y < canvasRect.Height * buttonsize && RectLoc.X > canvasRect.Width * (1.0f - buttonsize))
                            resp += -9;
                        else if (RectLoc.Y > canvasRect.Height * (1.0f - buttonsize) && RectLoc.X < canvasRect.Width * buttonsize)
                            resp += -1;
                        else if (RectLoc.Y > canvasRect.Height * (1.0f - buttonsize) && RectLoc.X > canvasRect.Width * (1.0f - buttonsize))
                            resp += -3;
                        else if (RectLoc.Y < canvasRect.Height * buttonsize)
                            resp += -8; //ch = "k";
                        else if (RectLoc.Y > canvasRect.Height * (1.0f - buttonsize))
                            resp += -2; // ch = "j";
                        else if (RectLoc.X < canvasRect.Width * buttonsize)
                            resp += -4; // ch = "h";
                        else if (RectLoc.X > canvasRect.Width * (1.0f - buttonsize))
                            resp += -6; // ch = "l";
                        else
                        {
                            int ux, uy;
                            lock (_uLock)
                            {
                                ux = _ux;
                                uy = _uy;
                            }
                            if (ShowDirections && GHUtils.isok(ux, uy) && GHUtils.isok(x, y))
                            {
                                int dx = x - ux;
                                int dy = y - uy;
                                if (Math.Abs(x - ux) <= 1 && Math.Abs(y - uy) <= 1)
                                {
                                    int dres = -1 * (5 + dx - 3 * dy);
                                    if (dres == -5)
                                        resp = GHConstants.SelfChar; /* '.', or self */
                                    else
                                        resp += dres;
                                }
                                else
                                    return;
                            }
                            else
                            {
                                if (ShowNumberPad)
                                    resp += -5;
                                else
                                    resp = GHConstants.SelfChar; /* '.', or self */
                            }
                        }

                        if (ShowNumberPad && resp <= -1 && resp >= -9)
                            resp -= 10;

                        curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.GetChar, resp));
                    }
                    else if (ShowNumberPad && e.Location.X < canvasRect.Left
                        && e.Location.Y >= canvasRect.Top + canvasRect.Height * (1.0f - buttonsize)
                        && e.Location.Y <= canvasRect.Top + canvasRect.Height)
                    {
                        int resp = -10;
                        curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.GetChar, resp));
                    }
                }
            }
        }

        private bool GetMapTileHoverLocation(float hoverX, float hoverY, out int tileX, out int tileY, 
            float usedTileWidth, float usedTileHeight, float mapWidth, float mapHeight, float mapOffsetX, float mapOffsetY,
            float mapMiniOffsetX, float mapMiniOffsetY, int clipX, int clipY,
            float canvaswidth, float canvasheight, float usedMapFontAscent,
            bool showDirections, bool showNumberPad, bool zoomMiniMode, bool mapWalkMode, bool walkArrows)
        {
            if (canvaswidth <= 0 || canvasheight <= 0)
            {
                tileX = tileY = 0;
                return false;
            }

            int x = 0, y = 0;
            float offsetX = (canvaswidth - mapWidth) / 2;
            float offsetY = (canvasheight - mapHeight) / 2;

            if (zoomMiniMode)
            {
                offsetX -= mapOffsetX;
                offsetY -= mapOffsetY;
                offsetX += mapMiniOffsetX;
                offsetY += mapMiniOffsetY;
            }
            else
            {
                if (clipX > 0 && (mapWidth > canvaswidth || mapHeight > canvasheight))
                {
                    offsetX -= (clipX - (GHConstants.MapCols - 1) / 2) * usedTileWidth;
                    offsetY -= (clipY - GHConstants.MapRows / 2) * usedTileHeight;
                }
            }

            offsetX += mapOffsetX;
            offsetY += mapOffsetY + usedMapFontAscent;

            if (usedTileWidth > 0)
                x = (int)((hoverX - offsetX) / usedTileWidth);
            if (usedTileHeight > 0)
                y = (int)((hoverY - offsetY) / usedTileHeight);

            if (!GHUtils.isok(x, y))
            {
                tileX = tileY = 0;
                return false;
            }

            if (!showDirections && !showNumberPad && !(mapWalkMode && walkArrows))
            {
                tileX = x;
                tileY = y;
                return true;
            }
            else
            {
                tileX = tileY = 0;
                return false;
            }
        }

        bool DetermineHasEnlargementOrAnimationOrSpecialHeight(ref LayerInfo layers)
        {
            int gui_glyph, ntile;
            for (int i = 0; i < (int)layer_types.MAX_LAYERS; i++)
            {
                if (layers.special_monster_layer_height != 0 || layers.special_feature_doodad_layer_height != 0)
                    return true;
                gui_glyph = Math.Abs(layers.layer_gui_glyphs[i]);
                if(gui_glyph != GHApp.NoGlyph)
                {
                    ntile = GHApp.Glyph2Tile[gui_glyph];
                    if (GHApp.Tile2Enlargement[ntile] > 0 || GHApp.Tile2Animation[ntile] > 0)
                        return true;
                }
            }
            return false;
        }

        //public void SetMapSymbol(int x, int y, int glyph, int bkglyph, int c, int color, uint special, ref LayerInfo layers)
        //{
        //    long generalCounter;
        //    long mainCounter;
        //    lock (AnimationTimerLock)
        //    {
        //        generalCounter = Interlocked.CompareExchange(ref AnimationTimers.general_animation_counter, 0L, 0L);;
        //    }
        //    lock (_mainCounterLock)
        //    {
        //        mainCounter = Interlocked.CompareExchange(ref _mainCounterValue, 0L, 0L);
        //    }
        //    lock (_mapDataLock)
        //    {
        //        SetMapSymbolOnTimerUnlocked(x, y, glyph, bkglyph, c, color, special, ref layers, generalCounter, mainCounter);
        //        ClearAllObjectDataUnlocked(x, y);
        //        ClearEngravingDataUnlocked(x, y);
        //    }
        //}

        //private void SetMapSymbolOnTimerUnlocked(int x, int y, int glyph, int bkglyph, int c, int color, uint special, ref LayerInfo layers, long generalCounter, long mainCounter)
        //{
        //    if (((layers.layer_flags & (ulong)LayerFlags.LFLAGS_UXUY) != 0 && (_mapData[x, y].Layers.layer_flags & (ulong)LayerFlags.LFLAGS_UXUY) == 0) ||
        //        (layers.m_id != 0 && layers.m_id != _mapData[x, y].Layers.m_id))
        //    {
        //        /* Update counter value only if the monster just moved here, not, e.g. if it changes action in the same square,
        //         * or is printed in the same square again with the same origin coordinates. This way, the movement action is played only once. 
        //         */
        //        _mapData[x, y].GlyphPrintAnimationCounterValue = generalCounter;
        //        _mapData[x, y].GlyphPrintMainCounterValue = mainCounter;
        //    }
        //    if ((layers.layer_flags & (ulong)LayerFlags.LFLAGS_UXUY) != 0)
        //    {
        //        lock (_uLock)
        //        {
        //            _ux = x;
        //            _uy = y;
        //            _u_condition_bits = layers.condition_bits;
        //            _u_status_bits = layers.status_bits;
        //            if (layers.buff_bits != null)
        //            {
        //                for (int i = 0; i < GHConstants.NUM_BUFF_BIT_ULONGS; i++)
        //                {
        //                    _u_buff_bits[i] = layers.buff_bits[i];
        //                }
        //            }
        //        }
        //    }
        //    if (layers.o_id != 0 && layers.o_id != _mapData[x, y].Layers.o_id)
        //    {
        //        /* Update counter value only if the object just moved here, not, e.g. if it changes action in the same square,
        //         * or is printed in the same square again with the same origin coordinates. This way, the movement action is played only once. 
        //         */
        //        _mapData[x, y].GlyphObjectPrintAnimationCounterValue = generalCounter;
        //        _mapData[x, y].GlyphObjectPrintMainCounterValue = mainCounter;
        //    }

        //    /* General counter that gets always set */
        //    _mapData[x, y].GlyphGeneralPrintAnimationCounterValue = generalCounter;
        //    _mapData[x, y].GlyphGeneralPrintMainCounterValue = mainCounter;
        //    _mapData[x, y].Glyph = glyph;
        //    _mapData[x, y].BkGlyph = bkglyph;
        //    _mapData[x, y].Symbol = Char.ConvertFromUtf32(c);
        //    _mapData[x, y].Color = UIUtils.NHColor2SKColor(color, (special & 0x00002000UL) != 0 ? (int)MenuItemAttributes.AltColors : 0);
        //    _mapData[x, y].Special = special;
        //    _mapData[x, y].Layers = layers;

        //    _mapData[x, y].NeedsUpdate = true;
        //    _mapData[x, y].HasEnlargementOrAnimationOrSpecialHeight = AlternativeLayerDrawing ? DetermineHasEnlargementOrAnimationOrSpecialHeight(ref layers) : false;
        //}

        //public void ProcessPrintGlyphCallList(List<SavedPrintGlyphCall> list, List<SavedSendObjectDataCall> olist, List<SavedSendMonsterDataCall> mlist, List<SavedSendEngravingDataCall> elist)
        //{
        //    long generalCounter;
        //    long mainCounter;
        //    lock (AnimationTimerLock)
        //    {
        //        generalCounter = Interlocked.CompareExchange(ref AnimationTimers.general_animation_counter, 0L, 0L);;
        //    }
        //    lock (_mainCounterLock)
        //    {
        //        mainCounter = Interlocked.CompareExchange(ref _mainCounterValue, 0L, 0L);
        //    }
        //    lock (_mapDataLock)
        //    {
        //        for (int i = 0; i < list.Count; i++)
        //        {
        //            SavedPrintGlyphCall pg = list[i];
        //            SetMapSymbolOnTimerUnlocked(pg.X, pg.Y, pg.Glyph, pg.Bkglyph, pg.Symbol, pg.Ocolor, pg.Special, ref pg.Layers, generalCounter, mainCounter);
        //            if (GHUtils.isok(pg.X, pg.Y))
        //                _mapData[pg.X, pg.Y].Engraving = new EngravingInfo();
        //        }
        //        for (int i = 0; i < elist.Count; i++)
        //        {
        //            SavedSendEngravingDataCall e = elist[i];
        //            if (e.cmdtype == 0)

        //                if (GHUtils.isok(e.x, e.y))
        //                    _mapData[e.x, e.y].Engraving = new EngravingInfo(e.engraving_text, e.etype, e.eflags, e.gflags);
        //        }
        //    }

        //    lock (_mapDataLock)
        //    {
        //        for (int i = 0; i < list.Count; i++)
        //        {
        //            SavedPrintGlyphCall pg = list[i];
        //            int x = pg.X;
        //            int y = pg.Y;
        //            if (_objectData[x, y] != null)
        //            {
        //                if (_objectData[x, y].FloorObjectList != null)
        //                    _objectData[x, y].FloorObjectList.Clear();
        //                if (_objectData[x, y].CoverFloorObjectList != null)
        //                    _objectData[x, y].CoverFloorObjectList.Clear();
        //                if (_objectData[x, y].MemoryObjectList != null)
        //                    _objectData[x, y].MemoryObjectList.Clear();
        //                if (_objectData[x, y].CoverMemoryObjectList != null)
        //                    _objectData[x, y].CoverMemoryObjectList.Clear();
        //            }
        //        }
        //        for (int i = 0; i < olist.Count; i++)
        //        {
        //            SavedSendObjectDataCall o = olist[i];
        //            AddObjectData(o.x, o.y, o.otmp, o.cmdtype, o.where, o.otypdata, o.oflags);
        //        }
        //    }

        //    lock (_petDataLock)
        //    {
        //        for (int i = 0; i < mlist.Count; i++)
        //        {
        //            SavedSendMonsterDataCall m = mlist[i];
        //            if(m.cmdtype == 0)
        //                _petData.Add(new GHPetDataItem(m.monster_data));
        //        }
        //    }
        //}

        //public void SetMapCursor(int x, int y)
        //{
        //    lock (_mapDataLock)
        //    {
        //        _localMapCursorX = x;
        //        _localMapCursorY = y;
        //    }
        //}
        //public void UpdateCursor(int style, int force_paint, int show_on_u)
        //{
        //    lock (_mapDataLock)
        //    {
        //        _cursorType = (game_cursor_types)style;
        //        _force_paint_at_cursor = (force_paint != 0);
        //        _show_cursor_on_u = (show_on_u != 0);
        //    }
        //}

        //public void ClearMap()
        //{
        //    lock (_mapDataLock)
        //    {
        //        for (int x = 1; x < GHConstants.MapCols; x++)
        //        {
        //            for (int y = 0; y < GHConstants.MapRows; y++)
        //            {
        //                _mapData[x, y].Glyph = GHApp.UnexploredGlyph;
        //                _mapData[x, y].BkGlyph = GHApp.NoGlyph;
        //                _mapData[x, y].Symbol = "";
        //                _mapData[x, y].Color = SKColors.Black;// default(MapData);
        //                _mapData[x, y].Special = 0;
        //                _mapData[x, y].NeedsUpdate = true;
        //                _mapData[x, y].GlyphPrintAnimationCounterValue = 0;
        //                _mapData[x, y].GlyphPrintMainCounterValue = 0;
        //                _mapData[x, y].GlyphObjectPrintAnimationCounterValue = 0;
        //                _mapData[x, y].GlyphObjectPrintMainCounterValue = 0;
        //                _mapData[x, y].GlyphGeneralPrintMainCounterValue = 0;

        //                _mapData[x, y].Layers = new LayerInfo();
        //                _mapData[x, y].Layers.layer_glyphs = new int[(int)layer_types.MAX_LAYERS];
        //                _mapData[x, y].Layers.layer_gui_glyphs = new int[(int)layer_types.MAX_LAYERS];
        //                _mapData[x, y].Layers.leash_mon_x = new sbyte[GHConstants.MaxLeashed + 1];
        //                _mapData[x, y].Layers.leash_mon_y = new sbyte[GHConstants.MaxLeashed + 1];

        //                _mapData[x, y].Layers.layer_glyphs[0] = GHApp.UnexploredGlyph;
        //                _mapData[x, y].Layers.layer_gui_glyphs[0] = GHApp.UnexploredGlyph;
        //                for (int i = 1; i < (int)layer_types.MAX_LAYERS; i++)
        //                {
        //                    _mapData[x, y].Layers.layer_glyphs[i] = GHApp.NoGlyph;
        //                    _mapData[x, y].Layers.layer_gui_glyphs[i] = GHApp.NoGlyph;
        //                }

        //                _mapData[x, y].Layers.glyph = GHApp.UnexploredGlyph;
        //                _mapData[x, y].Layers.bkglyph = GHApp.NoGlyph;
        //            }
        //        }
        //    }
        //}


        public void SetTargetClip(int x, int y, bool immediate_pan, long curtimervalue)
        {
            long pantime = Math.Max(2, (long)Math.Ceiling((double)UIUtils.GetMainCanvasAnimationFrequency(MapRefreshRate) / 8.0));

            /* Copy some values to local variables to avoid nested locks */
            bool forceAscii = ForceAscii;
            GHGraphicsStyle graphicsStyle = GraphicsStyle;
            //long curtimervalue = 0;
            float usedTileWidth;
            float usedTileHeight;
            int clipX;
            int clipY;

            //lock (_mainCounterLock)
            //{
            //    curtimervalue = Interlocked.CompareExchange(ref _mainCounterValue, 0L, 0L);
            //}
            lock (_tileSizeLock)
            {
                usedTileWidth = _usedTileWidth;
                usedTileHeight = _usedTileHeight;
            }
            lock (_clipLock)
            {
                clipX = _clipX;
                clipY = _clipY;

                /* Can set these here already a bit in advance */
                _clipX = x;
                _clipY = y;
            }

            float newClipX;
            float newClipY;
            lock (_mapOffsetLock)
            {
                if (immediate_pan || graphicsStyle == GHGraphicsStyle.ASCII || forceAscii)
                {
                    _targetClipOn = false;
                    newClipX = 0;
                    newClipY = 0;
                }
                else
                {
                    _targetClipOn = true;
                    newClipX = _mapOffsetX + (float)(x - clipX) * usedTileWidth;
                    newClipY = _mapOffsetY + (float)(y - clipY) * usedTileHeight;
                    _targetClipStartCounterValue = curtimervalue;
                    _targetClipPanTime = pantime; // GHConstants.DefaultPanTime;
                }

                _originMapOffsetWithNewClipX = newClipX;
                _originMapOffsetWithNewClipY = newClipY;
                _mapOffsetX = newClipX;
                _mapOffsetY = newClipY;
            }
        }

        //public void ClearAllObjectDataUnlocked(int x, int y)
        //{
        //    if (_objectData[x, y] != null)
        //    {
        //        if (_objectData[x, y].FloorObjectList != null)
        //            _objectData[x, y].FloorObjectList.Clear();
        //        if (_objectData[x, y].CoverFloorObjectList != null)
        //            _objectData[x, y].CoverFloorObjectList.Clear();
        //        if (_objectData[x, y].MemoryObjectList != null)
        //            _objectData[x, y].MemoryObjectList.Clear();
        //        if (_objectData[x, y].CoverMemoryObjectList != null)
        //            _objectData[x, y].CoverMemoryObjectList.Clear();
        //    }
        //}

        //public void AddObjectData(int x, int y, Obj otmp, int cmdtype, int where, ObjClassData otypdata, ulong oflags)
        //{
        //    bool is_uwep = (oflags & (ulong)objdata_flags.OBJDATA_FLAGS_UWEP) != 0UL;
        //    bool is_uwep2 = (oflags & (ulong)objdata_flags.OBJDATA_FLAGS_UWEP2) != 0UL;
        //    bool is_uquiver = (oflags & (ulong)objdata_flags.OBJDATA_FLAGS_UQUIVER) != 0UL;
        //    bool is_equipped = is_uwep | is_uwep2 | is_uquiver;
        //    bool hallucinated = (oflags & (ulong)objdata_flags.OBJDATA_FLAGS_HALLUCINATION) != 0UL;
        //    bool foundthisturn = (oflags & (ulong)objdata_flags.OBJDATA_FLAGS_FOUND_THIS_TURN) != 0UL;
        //    bool isuchain = (oflags & (ulong)objdata_flags.OBJDATA_FLAGS_UCHAIN) != 0UL;
        //    bool isuball = (oflags & (ulong)objdata_flags.OBJDATA_FLAGS_UBALL) != 0UL;

        //    if (is_equipped)
        //    {
        //        AddEquippedObjectData(x, y, otmp, cmdtype, where, otypdata, oflags);
        //    }
        //    else
        //    {
        //        lock (_mapDataLock)
        //        {
        //            if (_objectData[x, y] != null)
        //            {
        //                bool is_memoryobj = (where == (int)obj_where_types.OBJ_MEMORY);
        //                bool is_drawn_in_front = (oflags & (ulong)objdata_flags.OBJDATA_FLAGS_DRAWN_IN_FRONT) != 0UL;
        //                List<ObjectDataItem> objectList = is_memoryobj ? (is_drawn_in_front ? _objectData[x, y].CoverMemoryObjectList : _objectData[x, y].MemoryObjectList) : (is_drawn_in_front ? _objectData[x, y].CoverFloorObjectList : _objectData[x, y].FloorObjectList);
        //                ObjectDataItem newItem;
        //                switch (cmdtype)
        //                {
        //                    case 1: /* Clear */
        //                        if (objectList != null)
        //                            objectList.Clear();
        //                        break;
        //                    case 2: /* Add item */
        //                        if (objectList == null)
        //                        {
        //                            if (is_memoryobj)
        //                            {
        //                                if (is_drawn_in_front)
        //                                    _objectData[x, y].CoverMemoryObjectList = new List<ObjectDataItem>(4);
        //                                else
        //                                    _objectData[x, y].MemoryObjectList = new List<ObjectDataItem>(16);
        //                            }
        //                            else
        //                            {
        //                                if (is_drawn_in_front)
        //                                    _objectData[x, y].CoverFloorObjectList = new List<ObjectDataItem>(4);
        //                                else
        //                                    _objectData[x, y].FloorObjectList = new List<ObjectDataItem>(16);
        //                            }

        //                            objectList = is_memoryobj ? (is_drawn_in_front ? _objectData[x, y].CoverMemoryObjectList : _objectData[x, y].MemoryObjectList) : (is_drawn_in_front ? _objectData[x, y].CoverFloorObjectList : _objectData[x, y].FloorObjectList);
        //                        }
        //                        newItem = new ObjectDataItem(otmp, otypdata, hallucinated, foundthisturn);
        //                        objectList.Add(newItem);
        //                        break;
        //                    case 3: /* Add container item to previous item */
        //                        if (objectList == null || objectList.Count == 0)
        //                            break;
        //                        if (objectList[objectList.Count - 1].ContainedObjs == null)
        //                            objectList[objectList.Count - 1].ContainedObjs = new List<ObjectDataItem>(16);
        //                        objectList[objectList.Count - 1].ContainedObjs.Add(new ObjectDataItem(otmp, otypdata, hallucinated));
        //                        break;
        //                    case 4: /* Clear uchain and uball */
        //                        _uChain = null;
        //                        _uBall = null;
        //                        break;
        //                    case 5: /* Add uchain or uball */
        //                        if (!is_memoryobj && (isuchain || isuball))
        //                        {
        //                            newItem = new ObjectDataItem(otmp, otypdata, hallucinated, foundthisturn);
        //                            if (isuchain)
        //                                _uChain = newItem;
        //                            if (isuball)
        //                                _uBall = newItem;
        //                        }
        //                        break;
        //                }
        //            }
        //        }
        //    }
        //}

        //public void ClearEngravingDataUnlocked(int x, int y)
        //{
        //    if (GHUtils.isok(x, y))
        //        _mapData[x, y].Engraving = new EngravingInfo();
        //}

        //public void AddEngravingData(int x, int y, string engraving_text, int etype, ulong eflags, ulong gflags)
        //{
        //    lock(_mapDataLock)
        //    {
        //        if (GHUtils.isok(x, y))
        //            _mapData[x, y].Engraving = new EngravingInfo(engraving_text, etype, eflags, gflags);
        //    }
        //}

        public void ClearConditionTexts()
        {
            lock (_conditionTextLock)
            {
                _conditionTexts.Clear();
            }
        }

        public void ClearFloatingTexts()
        {
            lock (_floatingTextLock)
            {
                _floatingTexts.Clear();
            }
        }

        public void ClearGuiEffects()
        {
            lock (_guiEffectLock)
            {
                _guiEffects.Clear();
            }
        }

        public void StartAtBlack()
        {
            FadeFrameAtStart.Opacity = 1.0;
            FadeFrameAtStart.IsVisible = true;
        }

        public async Task FadeFromBlackAtStart(uint milliseconds)
        {
            FadeFrameAtStart.Opacity = 1.0;
            await FadeFrameAtStart.FadeTo(0.0, milliseconds);
            FadeFrameAtStart.IsVisible = false;
        }

        public void SetToBlack()
        {
#if WINDOWS
            FadeFrame.Opacity = 1.0;
            FadeFrame.IsVisible = true;
#else
            MainCanvasView.Opacity = 0.0;
#endif
        }

        public async Task FadeToBlack(uint milliseconds)
        {
            MainGrid.IsEnabled = false;
#if WINDOWS
            FadeFrame.Opacity = 0.0;
            FadeFrame.IsVisible = true;
            await FadeFrame.FadeTo(1.0, milliseconds);
#else
            MainCanvasView.Opacity = 1.0;
            await MainCanvasView.FadeTo(0.0, milliseconds);
#endif
        }

        public async Task FadeFromBlack(uint milliseconds)
        {
            MainGrid.IsEnabled = true;
#if WINDOWS
            FadeFrame.Opacity = 1.0;
            await FadeFrame.FadeTo(0.0, milliseconds);
            FadeFrame.IsVisible = false;
#else
            MainCanvasView.Opacity = 0.0;
            await MainCanvasView.FadeTo(1.0, milliseconds);
#endif
        }

        public void GenericButton_Clicked(object sender, EventArgs e, int resp)
        {
            if (!((resp >= '0' && resp <= '9') || (resp <= -1 && resp >= -19)))
                ShowNumberPad = false;

            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.GetChar, resp));
        }

        private void MoreButton_Clicked(object sender, EventArgs e)
        {
            //lMoreButton.IsEnabled = false;
            ShowMoreCanvas(sender, e);
        }

        private void ShowMoreCanvas(object sender, EventArgs e)
        {
            UpdateMoreNextPrevButtonVisibility(true, true);
            MoreCommandsGrid.IsVisible = true;
            MoreCommandsFilterEntry.Text = "";
            MoreCommandsFilterEntry.IsVisible = GHApp.IsDesktop;
            MoreCommandsFilterEntry.IsEnabled = GHApp.IsDesktop;
            //MainGrid.IsVisible = false;
            RefreshScreen = false;
            IsMainCanvasOn = false;
            StopMainCanvasAnimation();
            StartCommandCanvasAnimation();
        }

        private void YnButton_Clicked(object sender, EventArgs e)
        {
            LabeledImageButton ghb = sender as LabeledImageButton;
            if (ghb != null)
                YnButton_Pressed(sender, e, ghb.GHCommand);
        }

        private void YnButton_Pressed(object sender, EventArgs e, int resp)
        {
            /* This is slightly slower and flickers less with two consecutive yn questions than a direct call to HideYnResponses() */
            GHGame curGame = GHApp.CurrentGHGame;
            if (curGame != null)
            {
                curGame.RequestQueue.Enqueue(new GHRequest(curGame, GHRequestType.HideYnResponses));
                GenericButton_Clicked(sender, e, resp);
            }
        }

        private void ESCButton_Clicked(object sender, EventArgs e)
        {
            GHApp.PlayButtonClickedSound();
            TouchDictionary.Clear();
            GenericButton_Clicked(sender, e, GHConstants.CancelChar);
        }

        public void ToggleAutoCenterMode()
        {
            ToggleAutoCenterModeButton_Clicked(ToggleAutoCenterModeButton, EventArgs.Empty);
        }

        private void ToggleAutoCenterModeButton_Clicked(object sender, EventArgs e)
        {
            GHApp.PlayMenuSelectSound();
            MapNoClipMode = !MapNoClipMode;
            if (MapNoClipMode)
            {
                ToggleAutoCenterModeButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-autocenter-off.png";
                //SimpleToggleAutoCenterModeButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-autocenter-off.png";
            }
            else
            {
                ToggleAutoCenterModeButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-autocenter-on.png";
                //SimpleToggleAutoCenterModeButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-autocenter-on.png";
                int ux, uy;
                lock (_uLock)
                {
                    ux = _ux;
                    uy = _uy;
                }
                if (sender != null && GHUtils.isok(ux, uy))
                {
                    SetTargetClip(ux, uy, false, GHApp.CurrentGHGame?.MainCounterValue ?? 0);
                }
            }
        }

        private void ToggleTravelModeButton_Clicked(object sender, EventArgs e)
        {
            GHApp.PlayMenuSelectSound();
            MapTravelMode = !MapTravelMode;
            if (MapTravelMode)
            {
                ToggleTravelModeButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-travel-on.png";
            }
            else
            {
                ToggleTravelModeButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-travel-off.png";
            }
        }

        private void LookModeButton_Clicked(object sender, EventArgs e)
        {
            GHApp.PlayMenuSelectSound();
            MapLookMode = !MapLookMode;
            if (MapLookMode)
            {
                LookModeButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-look-on.png";
                //SimpleLookModeButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-look-on.png";
            }
            else
            {
                LookModeButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-look-off.png";
                //SimpleLookModeButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-look-off.png";
            }
        }

        private void ToggleZoomMiniButton_Clicked(object sender, EventArgs e)
        {
            GHApp.PlayMenuSelectSound();
            ZoomMiniMode = !ZoomMiniMode;
            if (ZoomMiniMode)
            {
                ToggleZoomMiniButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-minimap-on.png";
                //SimpleToggleZoomMiniButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-minimap-on.png";
            }
            else
            {
                ToggleZoomMiniButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-minimap-off.png";
                //SimpleToggleZoomMiniButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-minimap-off.png";
                int ux, uy;
                lock (_uLock)
                {
                    ux = _ux;
                    uy = _uy;
                }
                if (sender != null && GHUtils.isok(ux, uy) && !MapNoClipMode)
                {
                    SetTargetClip(ux, uy, true, GHApp.CurrentGHGame?.MainCounterValue ?? 0);
                }
            }
        }

        private void ToggleZoomAlternateButton_Clicked(object sender, EventArgs e)
        {
            GHApp.PlayMenuSelectSound();
            ZoomAlternateMode = !ZoomAlternateMode;
            if (ZoomAlternateMode)
            {
                ToggleZoomAlternateButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-altmap-on.png";
                lock (_mapOffsetLock)
                {
                    if(MapFontSize > 0)
                    {
                        _mapOffsetX = _mapOffsetX * MapFontAlternateSize / MapFontSize;
                        _mapOffsetY = _mapOffsetY * MapFontAlternateSize / MapFontSize;
                    }
                }
            }
            else
            {
                ToggleZoomAlternateButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-altmap-off.png";
                lock (_mapOffsetLock)
                {
                    if (MapFontAlternateSize > 0)
                    {
                        _mapOffsetX = _mapOffsetX * MapFontSize / MapFontAlternateSize;
                        _mapOffsetY = _mapOffsetY * MapFontSize / MapFontAlternateSize;
                    }
                }

                int ux, uy;
                lock (_uLock)
                {
                    ux = _ux;
                    uy = _uy;
                }
                if (sender != null && GHUtils.isok(ux, uy) && !MapNoClipMode)
                {
                    SetTargetClip(ux, uy, true, GHApp.CurrentGHGame?.MainCounterValue ?? 0);
                }
            }

        }

        private async void GameMenuButton_Clicked(object sender, EventArgs e)
        {
            await OpenGameMenuAsync();
        }

        private async Task OpenGameMenuAsync()
        {
            GameMenuButton.IsEnabled = false;
            //SimpleGameMenuButton.IsEnabled = false;
            GHApp.PlayButtonClickedSound();

            StopMainCanvasAnimation();
            TouchDictionary.Clear();

            await ShowGameMenu();

            if (!MainCanvasView.AnimationIsRunning("GeneralAnimationCounter"))
                StartMainCanvasAnimation();

            GameMenuButton.IsEnabled = true;
            //SimpleGameMenuButton.IsEnabled = true;
        }

        private void OpenGameMenu()
        {
            try
            {
                MainThread.BeginInvokeOnMainThread(async () => 
                {
                    try
                    {
                        await OpenGameMenuAsync();
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex);
                    }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
            }
        }

        private void PopupOkButton_Clicked(object sender, EventArgs e)
        {
            GenericButton_Clicked(sender, e, GHConstants.CancelChar);
        }

        private void HidePopupGrid()
        {
            PopupGrid.IsVisible = false;
        }

        private void GHButton_Clicked(object sender, EventArgs e)
        {
            GHApp.DebugWriteRestart("GHButton_Clicked");
            LabeledImageButton lib = sender as LabeledImageButton;
            if (lib == null)
                return;
            switch ((int)lib.GHCommand)
            {
                case -102:
                    GenericButton_Clicked(sender, e, 'n');
                    GenericButton_Clicked(sender, e, -12);
                    GenericButton_Clicked(sender, e, -10);
                    GenericButton_Clicked(sender, e, 's');
                    break;
                case -103:
                    GenericButton_Clicked(sender, e, 'n');
                    GenericButton_Clicked(sender, e, -12);
                    GenericButton_Clicked(sender, e, -10);
                    GenericButton_Clicked(sender, e, -10);
                    GenericButton_Clicked(sender, e, '.');
                    break;
                case -104:
                    OpenGameMenu();
                    break;
                case -105:
                    GenericButton_Clicked(sender, e, 'n');
                    DoShowNumberPad();
                    break;
                default:
                    GenericButton_Clicked(sender, e, (int)lib.GHCommand);
                    break;
            }
        }


        private readonly SKColor _suffixTextColor = new SKColor(220, 220, 220);
        private readonly SKColor _suffixTextColorReverted = new SKColor(35, 35, 35);
        private readonly SKColor _keyIdentifierTextColor = new SKColor(192, 192, 192);
        private readonly SKColor _keyIdentifierTextColorReverted = new SKColor(64, 64, 64);

        private readonly SKColor _menuHighlightSelectedColor = new SKColor(0xFF, 0x88, 0x00, 0x88);
        private readonly SKColor _menuHighlightAutoClickedColor = new SKColor(0xFF, 0xBB, 0x00, 0x99);
        private readonly SKColor _menuHighlightHoverOverSelectableColor = new SKColor(0xFF, 0x88, 0x00, 0x44);
        private readonly SKColor _menuHighlightHoverOverAutoClickableColor = new SKColor(0xFF, 0xBB, 0x00, 0x55);
        private readonly SKColor _menuHighlightHoverOverSelectedColor = new SKColor(0xFF, 0x88, 0x00, 0xAA);
        private readonly SKColor _menuHighlightHoverOverAutoClickedColor = new SKColor(0xFF, 0xBB, 0x00, 0xAA);

        private int _firstDrawnMenuItemIdx = -1;
        private int _lastDrawnMenuItemIdx = -1;
        //private readonly object _totalMenuHeightLock = new object();
        private float _totalMenuHeight = 0;
        private float TotalMenuHeight 
        { 
            get 
            {
                //lock (_totalMenuHeightLock)
                //{
                //    return _totalMenuHeight;
                //}
                return Interlocked.CompareExchange(ref _totalMenuHeight, 0.0f, 0.0f);
            }
            set 
            { 
                //lock (_totalMenuHeightLock) 
                //{ 
                //    _totalMenuHeight = value; 
                //}
                Interlocked.Exchange(ref _totalMenuHeight, value);
            } 
        }

        private int _refreshMenuRowCounts = 1;
        //private readonly object _refreshMenuRowCountLock = new object();
        private bool RefreshMenuRowCounts { get { return Interlocked.CompareExchange(ref _refreshMenuRowCounts, 0, 0) != 0; } set { Interlocked.Exchange(ref _refreshMenuRowCounts, value ? 1 : 0); } }
        private bool _menuCanvasThreadChecked = false;

        private readonly object _savedMenuCanvasLock = new object();
        private float _savedMenuCanvasWidth = 0;
        private float _savedMenuCanvasHeight = 0;

        private void MenuCanvas_PaintSurface(object sender, SKPaintSurfaceEventArgs e)
        {
            bool isMenuOnMainThread = MainThread.IsMainThread;
            if (!_menuCanvasThreadChecked && !isMenuOnMainThread)
            {
                _menuCanvasThreadChecked = true;
                GHApp.MaybeWriteGHLog("MenuCanvas_PaintSurface not on main thread!");
            }

            if (!MenuGrid.ThreadSafeIsVisible || LoadingGrid.ThreadSafeIsVisible)
                return;

            SKSurface surface = e.Surface;
            SKCanvas canvas = surface.Canvas;
            SwitchableCanvasView referenceCanvasView = MenuCanvas;
            float canvaswidth = e.Info.Width; // referenceCanvasView.CanvasSize.Width;
            float canvasheight = e.Info.Height; // referenceCanvasView.CanvasSize.Height;
            bool lockTaken = false;
            try
            {
                Monitor.TryEnter(_savedMenuCanvasLock, ref lockTaken);
                if (lockTaken)
                {
                    _savedMenuCanvasWidth = canvaswidth;
                    _savedMenuCanvasHeight = canvasheight;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_savedMenuCanvasLock);
            }
            lockTaken = false;

            canvas.Clear();
            if (MenuDrawOnlyClear)
                return;
            //lock (_menuDrawOnlyLock)
            //{
            //    if (_menuDrawOnlyClear)
            //        return;
            //}

            if (canvaswidth <= 16 || canvasheight <= 16)
                return;

            var menuItems = referenceCanvasView.MenuItems;
            if (menuItems == null)
                return;
            //lock (MenuCanvas.MenuItemLock)
            //{
            //    if (referenceCanvasView.MenuItems == null)
            //        return;
            //}

            float scale = GHApp.DisplayDensity; // (float)Math.Sqrt((double)(canvaswidth * canvasheight / (float)(referenceCanvasView.Width * referenceCanvasView.Height)));
            float customScale = GHApp.CustomScreenScale;
            bool isHighFilterQuality = MenuHighFilterQuality;
            bool isHighlightedKeys = MenuHighlightedKeys;
            bool usingGL = MenuCanvas.UseGL;
            bool fixRects = GHApp.FixRects;
            bool revertBW = MenuCanvas.RevertBlackAndWhite;
            float x, y;
            string str;
            SKRect textBounds = new SKRect();

            using (GHSkiaFontPaint textPaint = new GHSkiaFontPaint())
            {
                textPaint.Typeface = GHApp.UnderwoodTypeface;
                textPaint.TextSize = GHConstants.MenuDefaultRowHeight * scale * customScale;
                float picturewidth = 64.0f * textPaint.FontSpacing / 48.0f;
                float picturepadding = 9 * scale * customScale;
                float leftinnerpadding = 5;
                float curmenuoffset = InterlockedMenuScrollOffset;
                //lock (_menuScrollLock)
                //{
                //    curmenuoffset = _menuScrollOffset;
                //}
                y = curmenuoffset;
                double menumarginx = MenuCanvas.MenuButtonStyle ? 30.0 : 15.0;
                double menuwidth = Math.Max(1.0, Math.Min(MenuCanvas.ThreadSafeWidth - menumarginx * 2, UIUtils.MenuViewWidthRequest(referenceCanvasView.MenuStyle) * customScale));
                float menuwidthoncanvas = (float)(menuwidth * scale);
                float leftmenupadding = Math.Max(0, (canvaswidth - menuwidthoncanvas) / 2);
                float rightmenupadding = leftmenupadding;
                float accel_fixed_width = 10;
                bool first = true;
                float bottomPadding = 0;
                float topPadding = 0;
                float maintext_x_start = 0;
                float fontspacingpadding = 0;
                bool wrapglyph = MenuCanvas.GHWindow != null ? MenuCanvas.GHWindow.WrapGlyph : false;
                float glyphpadding = 0;
                float glyphystart = scale * (float)Math.Max(0.0, MenuWindowGlyphImage.ThreadSafeY - MenuCanvas.ThreadSafeY);
                float glyphyend = scale * (float)Math.Max(0.0, MenuWindowGlyphImage.ThreadSafeY + MenuWindowGlyphImage.ThreadSafeHeight - MenuCanvas.ThreadSafeY);
                //lock (MenuCanvas.MenuItemLock)
                {
                    bool has_pictures = false;
                    bool has_identifiers = false;
                    _firstDrawnMenuItemIdx = -1;
                    _lastDrawnMenuItemIdx = -1;
                    foreach (GHMenuItem mi in menuItems)
                    {
                        if (mi.Identifier != 0 || mi.SpecialMark != '\0')
                            has_identifiers = true;

                        if (mi.IsGlyphVisible)
                            has_pictures = true;

                        if (has_identifiers && has_pictures)
                            break;
                    }

                    //lock (_refreshMenuRowCountLock)
                    {
                        int idx = -1;
                        foreach (GHMenuItem mi in menuItems)
                        {
                            idx++;
                            bool IsMiButton = mi.IsButton;
                            float extra_vertical_padding = IsMiButton ? 12f : 0f;

                            /* Padding */
                            bottomPadding = (mi.BottomPadding + extra_vertical_padding) * scale * customScale;
                            topPadding = (mi.TopPadding + extra_vertical_padding) * scale * customScale;

                            /* Text Size and Minimum Row Height */
                            if ((mi.NHAttribute & (int)MenuItemAttributes.HalfSize) != 0)
                                textPaint.TextSize = (mi.MinimumTouchableTextSize / 2) * scale * customScale;
                            else
                                textPaint.TextSize = mi.MinimumTouchableTextSize * scale * customScale;
                            float minrowheight = mi.MinimumRowHeight(textPaint.FontSpacing, bottomPadding, topPadding, canvaswidth, canvasheight);

                            x = leftmenupadding;
                            mi.DrawBounds.Left = x;
                            float mainfontsize = (float)mi.FontSize * scale * customScale;
                            float relsuffixsize = (float)mi.RelativeSuffixFontSize;
                            float suffixfontsize = relsuffixsize * mainfontsize;
                            string mainFontFamily = mi.FontFamily;
                            SKTypeface mainFont = GHApp.GetTypefaceByName(mainFontFamily);
                            textPaint.Typeface = mainFont;
                            textPaint.TextSize = mainfontsize;
                            //textPaint.TextAlign = SKTextAlign.Left;

                            if (MenuWindowGlyphImage.ThreadSafeIsVisible && wrapglyph)
                                glyphpadding = scale * (float)Math.Max(0.0, MenuCanvas.ThreadSafeX + MenuCanvas.ThreadSafeWidth - MenuWindowGlyphImage.ThreadSafeX);
                            else
                                glyphpadding = 0;

                            mi.DrawBounds.Top = y;
                            //if (mi.DrawBounds.Top >= canvasheight)
                            //    break;

                            if (first)
                            {
                                accel_fixed_width = textPaint.MeasureText("A"); // textPaint.FontMetrics.AverageCharacterWidth; // + 3 * textPaint.MeasureText(" ");
                                _firstDrawnMenuItemIdx = idx;
                                maintext_x_start = leftmenupadding + leftinnerpadding + (has_identifiers && !MenuCanvas.HideMenuLetters ? accel_fixed_width : 0) + (has_pictures ? picturepadding + picturewidth + picturepadding : !MenuCanvas.HideMenuLetters ? accel_fixed_width : 0 /*textPaint.FontMetrics.AverageCharacterWidth*/);
                                first = false;
                            }

                            int maintextrows = 1;
                            int suffixtextrows = 0;
                            int suffix2textrows = 0;

                            string[] maintextsplit = mi.MainTextSplit;
                            string[] suffixtextsplit = mi.SuffixTextSplit;
                            string[] suffix2textsplit = mi.Suffix2TextSplit;
                            List<byte[]> mainattrssplit = mi.MainSplitAttrs;
                            List<byte[]> suffixattrssplit = mi.SuffixSplitAttrs;
                            List<byte[]> suffix2attrssplit = mi.Suffix2SplitAttrs;
                            List<byte[]> maincolorssplit = mi.MainSplitColors;
                            List<byte[]> suffixcolorssplit = mi.SuffixSplitColors;
                            List<byte[]> suffix2colorssplit = mi.Suffix2SplitColors;

                            List<float> mainrowwidths = null, suffixrowwidths = null, suffix2rowwidths = null;

                            if (RefreshMenuRowCounts || !mi.TextRowCountsSet)
                            {
                                maintextrows = CountTextSplitRows(maintextsplit, maintext_x_start, canvaswidth, rightmenupadding, textPaint, mi.UseSpecialSymbols, out mainrowwidths);
                                mi.MainTextRows = maintextrows;
                                mi.MainTextRowWidths = mainrowwidths;

                                textPaint.TextSize = suffixfontsize;
                                suffixtextrows = CountTextSplitRows(suffixtextsplit, maintext_x_start, canvaswidth, rightmenupadding, textPaint, mi.UseSpecialSymbols, out suffixrowwidths);
                                mi.SuffixTextRows = suffixtextrows;
                                mi.SuffixTextRowWidths = suffixrowwidths;

                                suffix2textrows = CountTextSplitRows(suffix2textsplit, maintext_x_start, canvaswidth, rightmenupadding, textPaint, mi.UseSpecialSymbols, out suffix2rowwidths);
                                mi.Suffix2TextRows = suffix2textrows;
                                mi.Suffix2TextRowWidths = suffix2rowwidths;

                                mi.TextRowCountsSet = true;
                            }
                            else
                            {
                                maintextrows = mi.MainTextRows;
                                suffixtextrows = mi.SuffixTextRows;
                                suffix2textrows = mi.Suffix2TextRows;
                                mainrowwidths = mi.MainTextRowWidths;
                                suffixrowwidths = mi.SuffixTextRowWidths;
                                suffix2rowwidths = mi.Suffix2TextRowWidths;
                            }
                            textPaint.TextSize = mainfontsize;

                            fontspacingpadding = (textPaint.FontSpacing - (textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent)) / 2;
                            float generallinepadding = Math.Max(0.0f, (minrowheight - (textPaint.FontSpacing) * ((float)maintextrows + suffixtextrows * (mi.IsSuffixTextVisible ? relsuffixsize : 0.0f) + (mi.IsSuffix2TextVisible ? relsuffixsize : 0.0f))) / 2);

                            bool isselected = referenceCanvasView.SelectionHow == SelectionMode.Multiple ? mi.Selected :
                                referenceCanvasView.SelectionHow == SelectionMode.Single ? idx == referenceCanvasView.SelectionIndex : false;

                            float totalRowHeight = topPadding + bottomPadding + ((float)maintextrows + suffixtextrows * (mi.IsSuffixTextVisible ? relsuffixsize : 0.0f) + (mi.IsSuffix2TextVisible ? relsuffixsize : 0.0f)) * (textPaint.FontSpacing) + 2 * generallinepadding;
                            float totalRowWidth = canvaswidth - leftmenupadding - rightmenupadding;
                            float totalRowExtraSpacing = IsMiButton ? 12.0f * scale * customScale : 0f;

                            if (y + totalRowHeight <= 0 || y >= canvasheight)
                            {
                                /* Just add the total row height */
                                y += totalRowHeight;
                                mi.DrawBounds.Right = mi.DrawBounds.Left + totalRowWidth;
                                mi.DrawBounds.Bottom = mi.DrawBounds.Top + totalRowHeight;
                                y += totalRowExtraSpacing;
                            }
                            else
                            {
                                /* Selection rectangle */
                                bool isSelectable = referenceCanvasView.SelectionHow != SelectionMode.None && mi.Identifier != 0;
                                SKRect selectionrect = new SKRect(x, y, x + totalRowWidth, y + totalRowHeight);
#if WINDOWS
                                bool isHover = false;
                                lock (_menuHoverLock)
                                {
                                    isHover = _menuIsHovering && selectionrect.Contains(_menuHoverPoint);
                                }
#else
                                bool isHover = IsMiButton; /* On mobile, all buttons are normal / hover color automatically */
#endif
                                if (IsMiButton)
                                {
                                    canvas.DrawImage(isselected || mi.Highlighted ? GHApp.ButtonSelectedBitmap : isHover ? GHApp.ButtonNormalBitmap : GHApp.ButtonDisabledBitmap, selectionrect);
                                }
                                else
                                {
                                    if (isselected)
                                    {
                                        textPaint.Color = isHover ? _menuHighlightHoverOverSelectedColor : _menuHighlightSelectedColor;
                                        textPaint.Style = SKPaintStyle.Fill;
                                        canvas.DrawRect(selectionrect, textPaint.Paint);
                                    }
                                    else if (mi.Highlighted)
                                    {
                                        textPaint.Color = isHover ? _menuHighlightHoverOverAutoClickedColor : _menuHighlightAutoClickedColor;
                                        textPaint.Style = SKPaintStyle.Fill;
                                        canvas.DrawRect(selectionrect, textPaint.Paint);
                                    }
                                    else if (isHover && isSelectable)
                                    {
                                        textPaint.Color = mi.IsAutoClickOk || MenuCanvas.ClickOKOnSelection ? _menuHighlightHoverOverAutoClickableColor : _menuHighlightHoverOverSelectableColor;
                                        textPaint.Style = SKPaintStyle.Fill;
                                        canvas.DrawRect(selectionrect, textPaint.Paint);
                                    }
                                }

                                float singlelinepadding = Math.Max(0.0f, ((float)(maintextrows - 1) * (textPaint.FontSpacing)) / 2);
                                y += topPadding;
                                y += generallinepadding;
                                y += fontspacingpadding;
                                y -= textPaint.FontMetrics.Ascent;
                                x += leftinnerpadding;

                                if (has_identifiers && !MenuCanvas.HideMenuLetters)
                                {
                                    if (mi.Identifier == 0 && mi.SpecialMark != '\0')
                                        str = mi.FormattedSpecialMark;
                                    else
                                        str = mi.FormattedAccelerator;
                                    textPaint.Color = isHighlightedKeys ? (revertBW ? _keyIdentifierTextColorReverted : _keyIdentifierTextColor) : SKColors.Gray;
                                    float identifier_y =
                                        mi.IsSuffixTextVisible || mi.IsSuffix2TextVisible ? (selectionrect.Top + selectionrect.Bottom) / 2 - (textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent) / 2 - textPaint.FontMetrics.Ascent
                                        : y + singlelinepadding;
                                    if (!(y + singlelinepadding + textPaint.FontSpacing + textPaint.FontMetrics.Ascent <= 0 || y + singlelinepadding + textPaint.FontMetrics.Ascent >= canvasheight))
                                        textPaint.DrawTextOnCanvas(canvas, str, x, identifier_y);
                                    x += accel_fixed_width;
                                }

                                if (has_pictures)
                                {
                                    x += picturepadding;

                                    /* Icon */
                                    float glyph_start_y = mi.DrawBounds.Top + Math.Max(0, (totalRowHeight - minrowheight) / 2);
                                    if (mi.IsGlyphVisible && !(glyph_start_y + minrowheight <= 0 || glyph_start_y >= canvasheight))
                                    {
                                        using (new SKAutoCanvasRestore(canvas, true))
                                        {
                                            mi.GlyphImageSource.AutoSize = true;
                                            mi.GlyphImageSource.DoAutoSize();
                                            if (mi.GlyphImageSource.Height > 0)
                                            {
                                                float glyphxcenterpadding = (picturewidth - minrowheight * mi.GlyphImageSource.Width / mi.GlyphImageSource.Height) / 2;
                                                canvas.Translate(x + glyphxcenterpadding, glyph_start_y);
                                                canvas.Scale(minrowheight / mi.GlyphImageSource.Height);
                                                mi.GlyphImageSource.DrawOnCanvas(canvas, usingGL, false, isHighFilterQuality, fixRects);
                                            }
                                        }
                                    }
                                    x += picturewidth + picturepadding;
                                }
                                else if (!MenuCanvas.HideMenuLetters)
                                {
                                    x += accel_fixed_width; // textPaint.FontMetrics.AverageCharacterWidth;
                                }

                                /* Main text */
                                SKColor maincolor = UIUtils.NHColor2SKColorCore(mi.NHColor, mi.NHAttribute, revertBW && !IsMiButton, IsMiButton && isselected);
                                textPaint.Color = !IsMiButton || isHover ? maincolor : UIUtils.NonHoveringSKColorAdjustment(maincolor);

                                //int split_idx_on_row = -1;
                                bool firstprintonrow = true;
                                float start_x = x;
                                float indent_start_x = start_x;
                                string trimmed_maintext = mi.TrimmedMainText;
                                //string indentstr = GHUtils.GetIndentationString(trimmed_maintext, mi.NHAttribute);
                                //if (indentstr != "")
                                //{
                                //    indent_start_x += textPaint.MeasureText(indentstr);
                                //}
                                ReadOnlySpan<char> indentSpan;
                                GHUtils.GetIndentationSpan(trimmed_maintext, mi.NHAttribute, out indentSpan);
                                if (!indentSpan.IsEmpty)
                                    indent_start_x += textPaint.MeasureText(indentSpan);

                                string altFontFamily;
                                if(UIUtils.MaybeSmallFontFamily(mainFontFamily, textPaint.TextSize, out altFontFamily))
                                    textPaint.Typeface = GHApp.GetTypefaceByName(altFontFamily);
                                DrawTextSplit(canvas, maintextsplit, mainattrssplit, maincolorssplit, mainrowwidths, ref x, ref y, ref firstprintonrow, indent_start_x, canvaswidth, canvasheight, rightmenupadding, textPaint, mi.UseSpecialSymbols, MenuCanvas.UseTextOutline || IsMiButton, revertBW && !IsMiButton, IsMiButton, totalRowWidth, curmenuoffset, glyphystart, glyphyend, glyphpadding);
                                textPaint.Typeface = mainFont;
                                /* Rewind and next line */
                                x = start_x;
                                y += textPaint.FontMetrics.Descent + fontspacingpadding;
                                firstprintonrow = true;

                                /* Suffix text */
                                if (mi.IsSuffixTextVisible)
                                {
                                    SKColor suffixcolor = mi.UseColorForSuffixes ? maincolor : revertBW && !IsMiButton ? _suffixTextColorReverted : _suffixTextColor;
                                    textPaint.Color = !IsMiButton || isHover ? suffixcolor : UIUtils.NonHoveringSKColorAdjustment(suffixcolor);
                                    textPaint.TextSize = suffixfontsize;
                                    y += fontspacingpadding;
                                    y -= textPaint.FontMetrics.Ascent;
                                    if (UIUtils.MaybeSmallFontFamily(mainFontFamily, textPaint.TextSize, out altFontFamily))
                                        textPaint.Typeface = GHApp.GetTypefaceByName(altFontFamily);
                                    DrawTextSplit(canvas, suffixtextsplit, suffixattrssplit, suffixcolorssplit, suffixrowwidths, ref x, ref y, ref firstprintonrow, start_x, canvaswidth, canvasheight, rightmenupadding, textPaint, mi.UseSpecialSymbols, MenuCanvas.UseTextOutline || IsMiButton, revertBW && !IsMiButton, IsMiButton, totalRowWidth, curmenuoffset, glyphystart, glyphyend, glyphpadding);
                                    textPaint.Typeface = mainFont;
                                    /* Rewind and next line */
                                    x = start_x;
                                    y += textPaint.FontMetrics.Descent + fontspacingpadding;
                                    firstprintonrow = true;
                                }

                                /* Suffix 2 text */
                                if (mi.IsSuffix2TextVisible)
                                {
                                    SKColor suffix2color = mi.UseColorForSuffixes ? maincolor : revertBW && !IsMiButton ? _suffixTextColorReverted : _suffixTextColor;
                                    textPaint.Color = !IsMiButton || isHover ? suffix2color : UIUtils.NonHoveringSKColorAdjustment(suffix2color);
                                    textPaint.TextSize = suffixfontsize;
                                    fontspacingpadding = (textPaint.FontSpacing - (textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent)) / 2;
                                    y += fontspacingpadding;
                                    y -= textPaint.FontMetrics.Ascent;
                                    if (UIUtils.MaybeSmallFontFamily(mainFontFamily, textPaint.TextSize, out altFontFamily))
                                        textPaint.Typeface = GHApp.GetTypefaceByName(altFontFamily);
                                    DrawTextSplit(canvas, suffix2textsplit, suffix2attrssplit, suffix2colorssplit, suffix2rowwidths, ref x, ref y, ref firstprintonrow, start_x, canvaswidth, canvasheight, rightmenupadding, textPaint, mi.UseSpecialSymbols, MenuCanvas.UseTextOutline || IsMiButton, revertBW && !IsMiButton, IsMiButton, totalRowWidth, curmenuoffset, glyphystart, glyphyend, glyphpadding);
                                    textPaint.Typeface = mainFont;
                                    /* Rewind and next line */
                                    x = start_x;
                                    y += textPaint.FontMetrics.Descent + fontspacingpadding;
                                    firstprintonrow = true;
                                }

                                y += generallinepadding;

                                y += bottomPadding;
                                mi.DrawBounds.Bottom = y;
                                mi.DrawBounds.Right = canvaswidth - rightmenupadding;
                                _lastDrawnMenuItemIdx = idx;

                                /* Count circle */
                                if (mi.Count > 0 && !(mi.DrawBounds.Bottom <= 0 || mi.DrawBounds.Top >= canvasheight))
                                {
                                    float circleradius = mi.DrawBounds.Height * 0.90f / 2;
                                    float circlex = mi.DrawBounds.Right - circleradius - 5;
                                    float circley = (mi.DrawBounds.Top + mi.DrawBounds.Bottom) / 2;
                                    textPaint.Color = SKColors.Red;
                                    canvas.DrawCircle(circlex, circley, circleradius, textPaint.Paint);
                                    //textPaint.TextAlign = SKTextAlign.Center;
                                    textPaint.Color = SKColors.White;
                                    str = mi.Count.ToString();
                                    float maxsize = 1.0f * 2.0f * circleradius / (float)Math.Sqrt(2);
                                    textPaint.TextSize = (float)mi.FontSize * scale * customScale;
                                    textPaint.MeasureText(str, ref textBounds);
                                    float scalex = textBounds.Width / maxsize;
                                    float scaley = textBounds.Height / maxsize;
                                    float totscale = Math.Max(scalex, scaley);
                                    textPaint.TextSize = textPaint.TextSize / Math.Max(1.0f, totscale);
                                    textPaint.DrawTextOnCanvas(canvas, str, circlex, circley - (textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent) / 2 - textPaint.FontMetrics.Ascent, SKTextAlign.Center);
                                }
                                /* Num items circle */
                                else if (mi.UseNumItems && !(mi.DrawBounds.Bottom <= 0 || mi.DrawBounds.Top >= canvasheight))
                                {
                                    float circleradius = mi.DrawBounds.Height * 0.90f / 2;
                                    float circlex = mi.DrawBounds.Right - circleradius - 5;
                                    float circley = (mi.DrawBounds.Top + mi.DrawBounds.Bottom) / 2;
                                    textPaint.Color = revertBW ? _numItemsBackgroundColor : _numItemsBackgroundColorDarkMode;
                                    textPaint.Style = SKPaintStyle.Fill;
                                    canvas.DrawCircle(circlex, circley, circleradius, textPaint.Paint);
                                    textPaint.Style = SKPaintStyle.Fill;
                                    //textPaint.TextAlign = SKTextAlign.Center;
                                    textPaint.Color = revertBW ? SKColors.Black : SKColors.White;
                                    str = mi.NumItems.ToString();
                                    float maxsize = 1.0f * 2.0f * circleradius / (float)Math.Sqrt(2);
                                    textPaint.TextSize = (float)mi.FontSize * scale * customScale;
                                    textPaint.MeasureText(str, ref textBounds);
                                    float scalex = textBounds.Width / maxsize;
                                    float scaley = textBounds.Height / maxsize;
                                    float totscale = Math.Max(scalex, scaley);
                                    textPaint.TextSize = textPaint.TextSize / Math.Max(1.0f, totscale);
                                    textPaint.DrawTextOnCanvas(canvas, str, circlex, circley - (textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent) / 2 - textPaint.FontMetrics.Ascent, SKTextAlign.Center);
                                }

                                /* Space between buttons / rows */
                                y += totalRowExtraSpacing;
                            }
                        }
                        if(IsLandscape ? canvaswidth > canvasheight : canvaswidth <= canvasheight)
                            RefreshMenuRowCounts = false;
                    }
                    TotalMenuHeight = y - curmenuoffset;
                }
            }
            canvas.Flush();
        }
        private readonly SKColor _numItemsBackgroundColor = new SKColor(228, 203, 158);
        private readonly SKColor _numItemsBackgroundColorDarkMode = new SKColor(2, 2, 2);

        private int CountTextSplitRows(string[] textsplit, float x_start, float canvaswidth, float rightmenupadding, GHSkiaFontPaint textPaint, bool usespecialsymbols, out List<float> rowWidths)
        {
            if (textsplit == null)
            {
                rowWidths = new List<float>(1);
                return 0;
            }

            rowWidths = new List<float>();
            int rows = 1;
            float calc_x_start = x_start;
            int rowidx = -1;
            float spacelength = textPaint.MeasureText(" ");
            float curendpos = calc_x_start;

            for (int s_idx = 0, s_cnt = textsplit.Length; s_idx < s_cnt; s_idx++)
            {
                string s = textsplit[s_idx];
                bool nowrap = false;
                if (string.IsNullOrWhiteSpace(s))
                    nowrap = true;
                rowidx++;
                SKImage symbolbitmap = null;
                float printlength = 0;
                float marginlength = 0;
                SKRect source_rect = new SKRect();
                if (usespecialsymbols && (symbolbitmap = GHApp.GetSpecialSymbol(s, out source_rect)) != null)
                {
                    float bmpheight = textPaint.FontMetrics.Descent / 2 - textPaint.FontMetrics.Ascent;
                    float bmpwidth = bmpheight * source_rect.Width / Math.Max(1f, source_rect.Height);
                    float bmpmargin = bmpheight / 8;
                    printlength = bmpwidth;
                    marginlength = bmpmargin;
                }
                else
                {
                    printlength = textPaint.MeasureText(s);
                    marginlength = spacelength;
                }
                float endposition = calc_x_start + printlength;
                bool pastend = endposition > canvaswidth - rightmenupadding;
                if (pastend && rowidx > 0 & !nowrap)
                {
                    rowWidths.Add(curendpos - x_start);
                    rows++;
                    curendpos = x_start + printlength;
                    rowidx = 0;
                }
                else
                {
                    curendpos = endposition;
                }
                calc_x_start = curendpos + marginlength;
            }
            rowWidths.Add(curendpos - x_start);
            return rows;
        }



        //public SKImage GetGameSpecialSymbol(string str, out SKRect source_rect)
        //{
        //    return GetGameSpecialSymbolFromSpan(str != null ? str.AsSpan() : ReadOnlySpan<char>.Empty, out source_rect);
        //}

        public SKImage GetGameSpecialSymbol(ReadOnlySpan<char> str, out SKRect source_rect)
        {
            source_rect = new SKRect();
            if (str.IsEmpty || !str.StartsWith("&"
#if !GNH_MAUI
                .AsSpan()
#endif
                ))
                return null;
            else if (str.StartsWith("&status-"
#if !GNH_MAUI
                    .AsSpan()
#endif
                    ) && str.Length > 8)
            {
                int status_mark = 0;
                GHSubstring substr = new GHSubstring(str, 8).Substring(0, str.Length - 8 - 1);
                if (int.TryParse(substr.Value, out status_mark))
                {
                    int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                    int mglyph = (int)game_ui_tile_types.STATUS_MARKS + status_mark / GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS + GHApp.UITileOff;
                    int mtile = GHApp.Glyph2Tile[mglyph];
                    int sheet_idx = GHApp.TileSheetIdx(mtile);
                    int tile_x = GHApp.TileSheetX(mtile);
                    int tile_y = GHApp.TileSheetY(mtile);
                    int within_tile_x = (status_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) % tiles_per_row;
                    int within_tile_y = (status_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) / tiles_per_row;
                    int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                    int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                    source_rect.Left = c_x;
                    source_rect.Right = c_x + GHConstants.StatusMarkWidth;
                    source_rect.Top = c_y;
                    source_rect.Bottom = c_y + GHConstants.StatusMarkHeight;

                    return TileMap[sheet_idx];
                }
                return null;
            }
            else if (str.StartsWith("&cond-"
#if !GNH_MAUI
                    .AsSpan()
#endif
                    ) && str.Length > 6)
            {
                int condition_mark = 0;
                GHSubstring substr = new GHSubstring(str, 6).Substring(0, str.Length - 6 - 1);
                if (int.TryParse(substr.Value, out condition_mark))
                {
                    int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                    int mglyph = (int)game_ui_tile_types.CONDITION_MARKS + condition_mark / GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS + GHApp.UITileOff;
                    int mtile = GHApp.Glyph2Tile[mglyph];
                    int sheet_idx = GHApp.TileSheetIdx(mtile);
                    int tile_x = GHApp.TileSheetX(mtile);
                    int tile_y = GHApp.TileSheetY(mtile);
                    int within_tile_x = (condition_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) % tiles_per_row;
                    int within_tile_y = (condition_mark % GHConstants.MAX_UI_TILE_16_x_16_COMPONENTS) / tiles_per_row;
                    int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                    int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                    source_rect.Left = c_x;
                    source_rect.Right = c_x + GHConstants.StatusMarkWidth;
                    source_rect.Top = c_y;
                    source_rect.Bottom = c_y + GHConstants.StatusMarkHeight;

                    return TileMap[sheet_idx];
                }
                return null;
            }
            else if (str.StartsWith("&buff-"
#if !GNH_MAUI
                    .AsSpan()
#endif
                    ) && str.Length > 6)
            {
                int propidx = 0;
                GHSubstring substr = new GHSubstring(str, 6).Substring(0, str.Length - 6 - 1);
                if (int.TryParse(substr.Value, out propidx))
                {
                    if (propidx <= GHConstants.LAST_PROP)
                    {
                        int tiles_per_row = GHConstants.TileWidth / GHConstants.StatusMarkWidth;
                        int mglyph = (propidx - 1) / GHConstants.BUFFS_PER_TILE + GHApp.BuffTileOff;
                        int mtile = GHApp.Glyph2Tile[mglyph];
                        int sheet_idx = GHApp.TileSheetIdx(mtile);
                        int tile_x = GHApp.TileSheetX(mtile);
                        int tile_y = GHApp.TileSheetY(mtile);

                        int buff_mark = (propidx - 1) % GHConstants.BUFFS_PER_TILE;
                        int within_tile_x = buff_mark % tiles_per_row;
                        int within_tile_y = buff_mark / tiles_per_row;
                        int c_x = tile_x + within_tile_x * GHConstants.StatusMarkWidth;
                        int c_y = tile_y + within_tile_y * GHConstants.StatusMarkHeight;

                        source_rect.Left = c_x;
                        source_rect.Right = c_x + GHConstants.StatusMarkWidth;
                        source_rect.Top = c_y;
                        source_rect.Bottom = c_y + GHConstants.StatusMarkHeight;

                        return TileMap[sheet_idx];
                    }
                }
                return null;
            }
            else
            {
                SKImage bitmap = GHApp.GetSpecialSymbol(str, out source_rect);
                return bitmap;
            }
        }

        private void DrawTextSpan(SKCanvas canvas, ReadOnlySpan<char> textSpan, ReadOnlySpan<byte> attrs, ReadOnlySpan<byte> colors, List<float> rowwidths, ref float x, ref float y, ref bool isfirstprintonrow, float indent_start_x, float canvaswidth, float canvasheight, float rightmenupadding, GHSkiaFontPaint textPaint, bool usespecialsymbols, bool usetextoutline, bool revertblackandwhite, bool centertext, float totalrowwidth, float curmenuoffset, float glyphystart, float glyphyend, float glyphpadding, bool addSpace, float spaceLength)
        {
            if (textSpan.IsEmpty)
                return;

#if !GNH_MAUI
            SKColor oldColor = textPaint.Paint.Color;
            SKFilterQuality oldFilterQuality = textPaint.Paint.FilterQuality;
#endif
            int rowidx = 0;
            SKColor orig_color = textPaint.Color;
            GHSubstring printedsubline = new GHSubstring("");

            bool nowrap = false;
            if (textSpan.Length == 0 || textSpan[0] == ' ')
                nowrap = true;

            float centering_padding = 0.0f;
            if (centertext && rowwidths != null && rowidx < rowwidths.Count)
            {
                centering_padding = (totalrowwidth - rowwidths[rowidx]) / 2;
            }

            if (isfirstprintonrow)
                x += centering_padding;

            float endposition = x;
            float usedglyphpadding = 0.0f;
            if (y - curmenuoffset + textPaint.FontMetrics.Ascent <= glyphyend
                && y - curmenuoffset + textPaint.FontMetrics.Descent >= glyphystart)
                usedglyphpadding = glyphpadding;

            SKImage symbolbitmap = null;
            SKRect source_rect = new SKRect();
            if (usespecialsymbols && (symbolbitmap = GetGameSpecialSymbol(textSpan, out source_rect)) != null)
            {
                textPaint.Color = orig_color;
                float bmpheight = textPaint.FontMetrics.Descent / 2 - textPaint.FontMetrics.Ascent;
                float bmpwidth = bmpheight * (float)symbolbitmap.Width / (float)Math.Max(1, symbolbitmap.Height);
                float bmpmargin = bmpheight / 8;
                endposition = x + bmpwidth + bmpmargin;
                bool pastend = x + bmpwidth > canvaswidth - usedglyphpadding - rightmenupadding;
                if (pastend && !isfirstprintonrow && !nowrap)
                {
                    x = indent_start_x;
                    y += textPaint.FontSpacing;
                    isfirstprintonrow = true;
                    endposition = x + bmpwidth + bmpmargin;
                }
                if (!(y + textPaint.FontSpacing + textPaint.FontMetrics.Ascent <= 0 || y + textPaint.FontMetrics.Ascent >= canvasheight))
                {
                    float bmpx = x;
                    float bmpy = y + textPaint.FontMetrics.Ascent;
                    SKRect bmptargetrect = new SKRect(bmpx, bmpy, bmpx + bmpwidth, bmpy + bmpheight);
#if !GNH_MAUI
                    textPaint.Paint.Color = SKColors.White;
                    textPaint.Paint.FilterQuality = SKFilterQuality.High;
#endif
                    canvas.DrawImage(symbolbitmap, source_rect, bmptargetrect,
#if GNH_MAUI
                            new SKSamplingOptions(SKFilterMode.Linear));
#else
                        textPaint.Paint);
                    textPaint.Paint.FilterQuality = oldFilterQuality;
                    textPaint.Paint.Color = oldColor;
#endif
                }
                isfirstprintonrow = false;
            }
            else
            {
                int char_idx = 0;
                bool do_once_empty_string = textSpan.Length == 0;
                while (char_idx < textSpan.Length || do_once_empty_string)
                {
                    do_once_empty_string = false;
                    int charidx_len = 0;
                    int new_nhcolor = !colors.IsEmpty && colors.Length > 0 && char_idx < colors.Length ? colors[char_idx] : (int)NhColor.NO_COLOR;
                    int new_nhattr = !attrs.IsEmpty && attrs.Length > 0 && char_idx < attrs.Length ? attrs[char_idx] : 0;
                    int char_idx2 = char_idx;
                    int new_nhcolor2 = new_nhcolor;
                    int new_nhattr2 = new_nhattr;

                    while (char_idx2 < textSpan.Length && new_nhcolor == new_nhcolor2 && new_nhattr == new_nhattr2)
                    {
                        char_idx2++;
                        new_nhcolor2 = !colors.IsEmpty && colors.Length > 0 && char_idx2 < colors.Length ? colors[char_idx2] : (int)NhColor.NO_COLOR;
                        new_nhattr2 = !attrs.IsEmpty && attrs.Length > 0 && char_idx2 < attrs.Length ? attrs[char_idx2] : 0;
                        charidx_len = char_idx2 - char_idx;
                    }

                    SKColor new_skcolor = UIUtils.NHColor2SKColorCore(new_nhcolor, new_nhattr, revertblackandwhite, false);
                    printedsubline.SetValue(textSpan, char_idx, charidx_len);
                    if (new_nhcolor != (int)NhColor.NO_COLOR)
                        textPaint.Color = new_skcolor;

                    float printlength = textPaint.MeasureText(printedsubline.Value);
                    endposition = x + printlength;
                    bool pastend = x + printlength > canvaswidth - usedglyphpadding - rightmenupadding;
                    if (pastend && !isfirstprintonrow && !nowrap)
                    {
                        rowidx++;
                        isfirstprintonrow = true;

                        x = indent_start_x;

                        if (centertext && rowwidths != null && rowidx < rowwidths.Count)
                            centering_padding = (totalrowwidth - rowwidths[rowidx]) / 2;
                        x += centering_padding;

                        y += textPaint.FontSpacing;
                        endposition = x + printlength;
                    }

                    if (!(y + textPaint.FontSpacing + textPaint.FontMetrics.Ascent <= 0 || y + textPaint.FontMetrics.Ascent >= canvasheight))
                    {
                        if (usetextoutline)
                        {
                            SKColor oldcolor = textPaint.Color;
                            textPaint.Color = revertblackandwhite ? SKColors.White : SKColors.Black;
                            textPaint.StrokeWidth = textPaint.TextSize / 10;
                            textPaint.Style = SKPaintStyle.Stroke;
                            textPaint.DrawTextOnCanvas(canvas, printedsubline.Value, x, y);
                            textPaint.Color = oldcolor;
                            textPaint.Style = SKPaintStyle.Fill;
                            textPaint.StrokeWidth = 0;
                        }
                        textPaint.DrawTextOnCanvas(canvas, printedsubline.Value, x, y);
                    }

                    if (new_nhcolor != (int)NhColor.NO_COLOR)
                        textPaint.Color = orig_color;

                    isfirstprintonrow = false;
                    char_idx += charidx_len;
                    x += printlength;
                }

                if (addSpace)
                    endposition += spaceLength;
            }

            x = endposition;
        }

        private int SpanIndexOf(ReadOnlySpan<char> textSpan, char c, int startIndex)
        {
            for (int i = startIndex, len = textSpan.Length; i < len; i++)
                if (textSpan[i] == c)
                    return i;

            return -1;
        }

        private void DrawSplittableText(SKCanvas canvas, ReadOnlySpan<char> textSpan, byte[] attrs, byte[] colors, List<float> rowwidths, ref float x, ref float y, ref bool isfirstprintonrow, float indent_start_x, float canvaswidth, float canvasheight, float rightmenupadding, GHSkiaFontPaint textPaint, bool usespecialsymbols, bool usetextoutline, bool revertblackandwhite, bool centertext, float totalrowwidth, float curmenuoffset, float glyphystart, float glyphyend, float glyphpadding)
        {
            int idx, startIdx = 0, len = textSpan.Length;
            do
            {
                idx = SpanIndexOf(textSpan, ' ', startIdx);
                DrawTextSpan(canvas, idx < 0 ? textSpan.Slice(startIdx) : textSpan.Slice(startIdx, idx + 1 - startIdx), 
                    attrs != null ? (idx < 0 ? attrs.AsSpan(startIdx) : attrs.AsSpan(startIdx, idx + 1 - startIdx)) : ReadOnlySpan<byte>.Empty, 
                    colors != null ? (idx < 0 ? colors.AsSpan(startIdx) : colors.AsSpan(startIdx, idx + 1 - startIdx)) : ReadOnlySpan<byte>.Empty, 
                    rowwidths, ref x, ref y, ref isfirstprintonrow, indent_start_x, canvaswidth, canvasheight, rightmenupadding, textPaint, usespecialsymbols, 
                    usetextoutline, revertblackandwhite, centertext, totalrowwidth, curmenuoffset, glyphystart, glyphyend, glyphpadding, false, 0.0f);
                startIdx = idx < 0 || idx == len - 1 ? -1 : idx + 1;
            } 
            while (startIdx >= 0);
        }

        private void DrawTextSplit(SKCanvas canvas, string[] textsplit, List<byte[]> attrs_list, List<byte[]> colors_list, List<float> rowwidths, ref float x, ref float y, ref bool isfirstprintonrow, float indent_start_x, float canvaswidth, float canvasheight, float rightmenupadding, GHSkiaFontPaint textPaint, bool usespecialsymbols, bool usetextoutline, bool revertblackandwhite, bool centertext, float totalrowwidth, float curmenuoffset, float glyphystart, float glyphyend, float glyphpadding)
        {
            if (textsplit == null)
                return;

//#if !GNH_MAUI
//            SKColor oldColor = textPaint.Paint.Color;
//            SKFilterQuality oldFilterQuality = textPaint.Paint.FilterQuality;
//#endif
            float spacelength = textPaint.MeasureText(" ");
            //int idx = 0;
            //int rowidx = 0;
            //SKColor orig_color = textPaint.Color;
            //GHSubstring printedsubline = new GHSubstring("");
            for (int idx = 0, cnt = textsplit.Length; idx < cnt; idx++)
            {
                string split_str = textsplit[idx];
                byte[] attrs = attrs_list != null && idx < attrs_list.Count ? attrs_list[idx] : null;
                byte[] colors = colors_list != null && idx < colors_list.Count ? colors_list[idx] : null;

                DrawTextSpan(canvas, split_str
#if !GNH_MAUI
                    .AsSpan()
#endif
                    , attrs, colors, rowwidths, ref x, ref y, ref isfirstprintonrow, indent_start_x, canvaswidth, canvasheight, rightmenupadding, textPaint, usespecialsymbols, usetextoutline, revertblackandwhite, centertext, totalrowwidth, curmenuoffset, glyphystart, glyphyend, glyphpadding, idx < textsplit.Length - 1, spacelength);

//                bool nowrap = false;
//                if (string.IsNullOrWhiteSpace(split_str))
//                    nowrap = true;

//                float centering_padding = 0.0f;
//                if(centertext && rowwidths != null && rowidx < rowwidths.Count)
//                {
//                    centering_padding = (totalrowwidth - rowwidths[rowidx]) / 2;
//                }

//                if(isfirstprintonrow)
//                    x += centering_padding;

//                float endposition = x;
//                float usedglyphpadding = 0.0f;
//                if (y - curmenuoffset + textPaint.FontMetrics.Ascent <= glyphyend
//                    && y - curmenuoffset + textPaint.FontMetrics.Descent >= glyphystart)
//                    usedglyphpadding = glyphpadding;

//                SKImage symbolbitmap = null;
//                SKRect source_rect = new SKRect();
//                if(usespecialsymbols && (symbolbitmap = GetGameSpecialSymbol(split_str, out source_rect)) != null)
//                {
//                    textPaint.Color = orig_color;
//                    float bmpheight = textPaint.FontMetrics.Descent / 2 - textPaint.FontMetrics.Ascent;
//                    float bmpwidth = bmpheight * (float)symbolbitmap.Width / (float)Math.Max(1, symbolbitmap.Height);
//                    float bmpmargin = bmpheight / 8;
//                    endposition = x + bmpwidth + bmpmargin;
//                    bool pastend = x + bmpwidth > canvaswidth - usedglyphpadding - rightmenupadding;
//                    if (pastend && !isfirstprintonrow && !nowrap)
//                    {
//                        x = indent_start_x;
//                        y += textPaint.FontSpacing;
//                        isfirstprintonrow = true;
//                        endposition = x + bmpwidth + bmpmargin;
//                    }
//                    if (!(y + textPaint.FontSpacing + textPaint.FontMetrics.Ascent <= 0 || y + textPaint.FontMetrics.Ascent >= canvasheight))
//                    {
//                        float bmpx = x;
//                        float bmpy = y + textPaint.FontMetrics.Ascent;
//                        SKRect bmptargetrect = new SKRect(bmpx, bmpy, bmpx + bmpwidth, bmpy + bmpheight);
//#if !GNH_MAUI
//                        textPaint.Paint.Color = SKColors.White;
//                        textPaint.Paint.FilterQuality = SKFilterQuality.High;
//#endif
//                        canvas.DrawImage(symbolbitmap, source_rect, bmptargetrect,
//#if GNH_MAUI
//                            new SKSamplingOptions(SKFilterMode.Linear));
//#else
//                            textPaint.Paint);
//                        textPaint.Paint.FilterQuality = oldFilterQuality;
//                        textPaint.Paint.Color = oldColor;
//#endif
//                    }
//                    isfirstprintonrow = false;
//                }
//                else
//                {
//                    int char_idx = 0;
//                    bool do_once_empty_string =  split_str.Length == 0;
//                    while (char_idx < split_str.Length || do_once_empty_string)
//                    {
//                        do_once_empty_string = false;
//                        int charidx_len = 0;
//                        int new_nhcolor = colors != null && colors.Length > 0 && char_idx < colors.Length ? colors[char_idx] : (int)NhColor.NO_COLOR;
//                        int new_nhattr = attrs != null && attrs.Length > 0 && char_idx < attrs.Length ? attrs[char_idx] : 0;
//                        int char_idx2 = char_idx;
//                        int new_nhcolor2 = new_nhcolor;
//                        int new_nhattr2 = new_nhattr;

//                        while (char_idx2 < split_str.Length && new_nhcolor == new_nhcolor2 && new_nhattr == new_nhattr2)
//                        {
//                            char_idx2++;
//                            new_nhcolor2 = colors != null && colors.Length > 0 && char_idx2 < colors.Length ? colors[char_idx2] : (int)NhColor.NO_COLOR;
//                            new_nhattr2 = attrs != null && attrs.Length > 0 && char_idx2 < attrs.Length ? attrs[char_idx2] : 0;
//                            charidx_len = char_idx2 - char_idx;
//                        }

//                        SKColor new_skcolor = UIUtils.NHColor2SKColorCore(new_nhcolor, new_nhattr, revertblackandwhite, false);
//                        printedsubline.SetValue(split_str, char_idx, charidx_len);
//                        if (new_nhcolor != (int)NhColor.NO_COLOR)
//                            textPaint.Color = new_skcolor;

//                        float printlength = textPaint.MeasureText(printedsubline.Value);
//                        endposition = x + printlength;
//                        bool pastend = x + printlength > canvaswidth - usedglyphpadding - rightmenupadding;
//                        if (pastend && !isfirstprintonrow && !nowrap)
//                        {
//                            rowidx++;
//                            isfirstprintonrow = true;

//                            x = indent_start_x;

//                            if (centertext && rowwidths != null && rowidx < rowwidths.Count)
//                                centering_padding = (totalrowwidth - rowwidths[rowidx]) / 2;
//                            x += centering_padding;

//                            y += textPaint.FontSpacing;
//                            endposition = x + printlength;
//                        }

//                        if (!(y + textPaint.FontSpacing + textPaint.FontMetrics.Ascent <= 0 || y + textPaint.FontMetrics.Ascent >= canvasheight))
//                        {
//                            if (usetextoutline)
//                            {
//                                SKColor oldcolor = textPaint.Color;
//                                textPaint.Color = revertblackandwhite ? SKColors.White : SKColors.Black;
//                                textPaint.StrokeWidth = textPaint.TextSize / 10;
//                                textPaint.Style = SKPaintStyle.Stroke;
//                                textPaint.DrawTextOnCanvas(canvas, printedsubline.Value, x, y);
//                                textPaint.Color = oldcolor;
//                                textPaint.Style = SKPaintStyle.Fill;
//                                textPaint.StrokeWidth = 0;
//                            }
//                            textPaint.DrawTextOnCanvas(canvas, printedsubline.Value, x, y);
//                        }

//                        if (new_nhcolor != (int)NhColor.NO_COLOR)
//                            textPaint.Color = orig_color;

//                        isfirstprintonrow = false;
//                        char_idx += charidx_len;
//                        x += printlength;
//                    }
//                    if (idx < textsplit.Length - 1)
//                        endposition += spacelength;
//                }

//                x = endposition;
                //idx++;
            }
        }

        private float _interlockedMenuScrollOffset = 0;
        private float InterlockedMenuScrollOffset { get { return Interlocked.CompareExchange(ref _interlockedMenuScrollOffset, 0.0f, 0.0f); } set { Interlocked.Exchange(ref _interlockedMenuScrollOffset, value); } }
        private readonly object _menuScrollLock = new object();
        private float _menuScrollOffset = 0;
        private float _menuScrollSpeed = 0; /* pixels per second */
        private bool _menuScrollSpeedRecordOn = false;
        private DateTime _menuScrollSpeedStamp;
        List<TouchSpeedRecord> _menuScrollSpeedRecords = new List<TouchSpeedRecord>();
        private bool _menuScrollSpeedOn = false;
        private DateTime _menuScrollSpeedReleaseStamp;

        private ConcurrentDictionary<long, TouchEntry> MenuTouchDictionary = new ConcurrentDictionary<long, TouchEntry>();
        private object _savedMenuSender = null;
        private SKTouchEventArgs _savedMenuEventArgs = null;
        private DateTime _savedMenuTimeStamp;
        private bool _menuTouchMoved = false;
        private bool _menuPreviousReleaseClick = false;
        private int _menuPreviousReleaseClickIndex = -1;
        private DateTime _savedPreviousMenuReleaseTimeStamp;
        private void MenuCanvas_Touch(object sender, SKTouchEventArgs e)
        {
            if (MenuDrawOnlyClear)
                return;
            //lock (_menuDrawOnlyLock)
            //{
            //    if (_menuDrawOnlyClear)
            //        return;
            //}
            //float canvasheight = MenuCanvas.ThreadSafeCanvasSize.Height;
            float canvasheight;
            lock (_savedMenuCanvasLock)
            {
                canvasheight = _savedMenuCanvasHeight;
            }
            float bottomScrollLimit = Math.Min(0, canvasheight - TotalMenuHeight);
            switch (e?.ActionType)
            {
                case SKTouchAction.Entered:
                    break;
                case SKTouchAction.Pressed:
                    _savedMenuSender = null;
                    _savedMenuEventArgs = null;
                    _savedMenuTimeStamp = DateTime.Now;

                    if (MenuTouchDictionary.ContainsKey(e.Id))
                        MenuTouchDictionary[e.Id] = new TouchEntry(e.Location, DateTime.Now);
                    else
                        MenuTouchDictionary.TryAdd(e.Id, new TouchEntry(e.Location, DateTime.Now));

                    lock(_menuScrollLock)
                    {
                        _menuScrollSpeed = 0;
                        _menuScrollSpeedOn = false;
                        _menuScrollSpeedRecordOn = false;
                        _menuScrollSpeedRecords.Clear();
                    }

                    if (MenuTouchDictionary.Count > 1)
                    {
                        _menuTouchMoved = true;
                        _menuPreviousReleaseClick = false;
                        _menuPreviousReleaseClickIndex = -1;
                        _savedPreviousMenuReleaseTimeStamp = new DateTime();
                    }
                    else
                    {
                        _savedMenuSender = sender;
                        _savedMenuEventArgs = e;

                        HighlightMenuItems(e.Location);

                        if (MenuCanvas.AllowLongTap)
                        {
#if GNH_MAUI
                            var timer = Microsoft.Maui.Controls.Application.Current.Dispatcher.CreateTimer();
                            timer.Interval = TimeSpan.FromSeconds(GHConstants.LongMenuTapThreshold);
                            timer.IsRepeating = false;
                            timer.Tick += (s, e) => { DoLongMenuTap(); };
                            timer.Start();
#else
                            Device.StartTimer(TimeSpan.FromSeconds(GHConstants.LongMenuTapThreshold), () =>
                            {
                                DoLongMenuTap();
                                return false;
                            });
#endif
                        }
                    }

                    e.Handled = true;
                    break;
                case SKTouchAction.Moved:
                    {
                        TouchEntry entry;
                        bool res = MenuTouchDictionary.TryGetValue(e.Id, out entry);
                        if (res)
                        {
                            SKPoint anchor = entry.Location;

                            float diffX = e.Location.X - anchor.X;
                            float diffY = e.Location.Y - anchor.Y;
                            float dist = (float)Math.Sqrt((Math.Pow(diffX, 2) + Math.Pow(diffY, 2)));

                            if (MenuTouchDictionary.Count == 1)
                            {
                                /* Just one finger => Scroll the menu */
                                if (diffX != 0 || diffY != 0)
                                {
                                    HighlightMenuItems(e.Location);

                                    DateTime now = DateTime.Now;
                                    /* Do not scroll within button press time threshold, unless large move */
                                    long millisecs_elapsed = (now.Ticks - entry.PressTime.Ticks) / TimeSpan.TicksPerMillisecond;
                                    if (dist > GHConstants.MoveDistanceThreshold || millisecs_elapsed > GHConstants.MoveOrPressTimeThreshold)
                                    {
                                        lock (_menuScrollLock)
                                        {
                                            float stretchLimit = GHConstants.ScrollStretchLimit * canvasheight;
                                            float stretchConstant = GHConstants.ScrollConstantStretch * canvasheight;
                                            float adj_factor = 1.0f;
                                            if (_menuScrollOffset > 0)
                                                adj_factor = _menuScrollOffset >= stretchLimit ? 0 : (1 - ((_menuScrollOffset + stretchConstant) / (stretchLimit + stretchConstant)));
                                            else if (_menuScrollOffset < bottomScrollLimit)
                                                adj_factor = _menuScrollOffset < bottomScrollLimit - stretchLimit ? 0 : (1 - ((bottomScrollLimit - (_menuScrollOffset - stretchConstant)) / (stretchLimit + stretchConstant)));
                                            
                                            float adj_diffY = diffY * adj_factor;
                                            _menuScrollOffset += adj_diffY;
                                            
                                            if (_menuScrollOffset > stretchLimit)
                                                _menuScrollOffset = stretchLimit;
                                            else if (_menuScrollOffset < bottomScrollLimit - stretchLimit)
                                                _menuScrollOffset = bottomScrollLimit - stretchLimit;
                                            else
                                            {
                                                /* Calculate duration since last touch move */
                                                float duration = 0;
                                                if (!_menuScrollSpeedRecordOn)
                                                {
                                                    duration = (float)millisecs_elapsed / 1000f;
                                                    _menuScrollSpeedRecordOn = true;
                                                }
                                                else
                                                {
                                                    duration = ((float)(now.Ticks - _menuScrollSpeedStamp.Ticks) / TimeSpan.TicksPerMillisecond) / 1000f;
                                                }
                                                _menuScrollSpeedStamp = now;

                                                /* Discard speed records to the opposite direction */
                                                if (_menuScrollSpeedRecords.Count > 0)
                                                {
                                                    int prevsgn = Math.Sign(_menuScrollSpeedRecords[0].Distance);
                                                    if (diffY != 0 && prevsgn != 0 && Math.Sign(diffY) != prevsgn)
                                                        _menuScrollSpeedRecords.Clear();
                                                }

                                                /* Add a new speed record */
                                                _menuScrollSpeedRecords.Insert(0, new TouchSpeedRecord(diffY, duration, now));

                                                /* Discard too old records */
                                                while (_menuScrollSpeedRecords.Count > 0)
                                                {
                                                    long lastrecord_ms = (now.Ticks - _menuScrollSpeedRecords[_menuScrollSpeedRecords.Count - 1].TimeStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                                                    if (lastrecord_ms > GHConstants.ScrollRecordThreshold)
                                                        _menuScrollSpeedRecords.RemoveAt(_menuScrollSpeedRecords.Count - 1);
                                                    else
                                                        break;
                                                }

                                                /* Sum up the distances and durations of current records to get an average */
                                                float totaldistance = 0;
                                                float totalsecs = 0;
                                                foreach (TouchSpeedRecord r in _menuScrollSpeedRecords)
                                                {
                                                    totaldistance += r.Distance;
                                                    totalsecs += r.Duration;
                                                }
                                                _menuScrollSpeed = totaldistance / Math.Max(0.001f, totalsecs);
                                                _menuScrollSpeedOn = false;
                                            }
                                            InterlockedMenuScrollOffset = _menuScrollOffset;
                                        }
                                        MenuTouchDictionary[e.Id].Location = e.Location;
                                        MenuTouchDictionary[e.Id].UpdateTime = DateTime.Now;
                                        if (dist > GHConstants.MoveDistanceThreshold)
                                        {  /* Cancel any press, if long move */
                                            _menuTouchMoved = true;
                                            _savedMenuTimeStamp = DateTime.Now;
                                            _menuPreviousReleaseClick = false;
                                            _menuPreviousReleaseClickIndex = -1;
                                            _savedPreviousMenuReleaseTimeStamp = new DateTime();
                                        }
                                    }
                                }
                            }
                        }
                        e.Handled = true;
                    }
                    break;
                case SKTouchAction.Released:
                    {
                        _savedMenuSender = null;
                        _savedMenuEventArgs = null;
                        _savedMenuTimeStamp = DateTime.Now;

                        ClearHighlightMenuItems();

                        TouchEntry entry;
                        bool res = MenuTouchDictionary.TryGetValue(e.Id, out entry);
                        if (res)
                        { 
                            long nowTicks = _savedMenuTimeStamp.Ticks;
                            long elapsedms = (nowTicks - entry.PressTime.Ticks) / TimeSpan.TicksPerMillisecond;
                            if (elapsedms <= GHConstants.MoveOrPressTimeThreshold && !_menuTouchMoved && MenuCanvas.SelectionHow != SelectionMode.None)
                            {
                                if (e.MouseButton == SKMouseButton.Right)
                                {
                                    if(MenuCanvas.AllowLongTap)
                                        MenuCanvas_LongTap(sender, e);
                                }
                                else
                                {
                                    MenuClickResult clickRes = MenuCanvas_NormalClickRelease(sender, e, false);
                                    if (GHApp.OkOnDoubleClick && MenuCanvas.SelectionHow == SelectionMode.Single && e.MouseButton == SKMouseButton.Left)
                                    {
                                        long timeSincePreviousReleaseInMs = (nowTicks - _savedPreviousMenuReleaseTimeStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                                        if (!clickRes.OkClicked && MenuOKButton.IsEnabled && _menuPreviousReleaseClick &&
                                            clickRes.MenuItemClickIndex >= 0 && clickRes.MenuItemClickIndex == _menuPreviousReleaseClickIndex &&
                                            clickRes.ItemIdentifier != 0 &&
                                            timeSincePreviousReleaseInMs <= GHConstants.DoubleClickTimeThreshold)
                                        {
                                            MenuCanvas.InvalidateSurface();
                                            PressMenuOKButton();
                                            _menuPreviousReleaseClick = false;
                                            _menuPreviousReleaseClickIndex = -1;
                                            _savedPreviousMenuReleaseTimeStamp = new DateTime();
                                        }
                                        else
                                        {
                                            _menuPreviousReleaseClick = true;
                                            _menuPreviousReleaseClickIndex = clickRes.MenuItemClickIndex;
                                            _savedPreviousMenuReleaseTimeStamp = _savedMenuTimeStamp;
                                        }
                                    }
                                }
                            }
                            if (MenuTouchDictionary.ContainsKey(e.Id))
                            {
                                TouchEntry removedEntry;
                                MenuTouchDictionary.TryRemove(e.Id, out removedEntry);
                            }
                            else
                                MenuTouchDictionary.Clear(); /* Something's wrong; reset the touch dictionary */

                            if (MenuTouchDictionary.Count == 0)
                            {
                                lock(_menuScrollLock)
                                {
                                    long lastrecord_ms = 0;
                                    if(_menuScrollSpeedRecords.Count > 0)
                                    {
                                        lastrecord_ms = (DateTime.Now.Ticks - _menuScrollSpeedRecords[_menuScrollSpeedRecords.Count - 1].TimeStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                                    }

                                    if (_menuScrollOffset > 0 || _menuScrollOffset < bottomScrollLimit)
                                    {
                                        if(lastrecord_ms > GHConstants.ScrollRecordThreshold
                                            || Math.Abs(_menuScrollSpeed) < GHConstants.ScrollSpeedThreshold * canvasheight)
                                            _menuScrollSpeed = 0;

                                        _menuScrollSpeedOn = true;
                                        _menuScrollSpeedReleaseStamp = DateTime.Now;
                                    }
                                    else if(lastrecord_ms > GHConstants.ScrollRecordThreshold)
                                    {
                                        _menuScrollSpeedOn = false;
                                        _menuScrollSpeed = 0;
                                    }
                                    else if (Math.Abs(_menuScrollSpeed) >= GHConstants.ScrollSpeedThreshold * canvasheight)
                                    {
                                        _menuScrollSpeedOn = true;
                                        _menuScrollSpeedReleaseStamp = DateTime.Now;
                                    }
                                    else
                                    {
                                        _menuScrollSpeedOn = false;
                                        _menuScrollSpeed = 0;
                                    }
                                    _menuScrollSpeedRecordOn = false;
                                    _menuScrollSpeedRecords.Clear();
                                }
                                _menuTouchMoved = false;
                            }
                        }
                        e.Handled = true;
                    }
                    break;
                case SKTouchAction.Cancelled:
                    if (MenuTouchDictionary.ContainsKey(e.Id))
                    {
                        TouchEntry removedEntry;
                        MenuTouchDictionary.TryRemove(e.Id, out removedEntry);
                    }
                    else
                        MenuTouchDictionary.Clear(); /* Something's wrong; reset the touch dictionary */

                    ClearHighlightMenuItems();

                    lock (_menuScrollLock)
                    {
                        if (_menuScrollOffset > 0 || _menuScrollOffset < bottomScrollLimit)
                        {
                            long lastrecord_ms = 0;
                            if (_menuScrollSpeedRecords.Count > 0)
                            {
                                lastrecord_ms = (DateTime.Now.Ticks - _menuScrollSpeedRecords[_menuScrollSpeedRecords.Count - 1].TimeStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                            }

                            if (lastrecord_ms > GHConstants.ScrollRecordThreshold
                                || Math.Abs(_menuScrollSpeed) < GHConstants.ScrollSpeedThreshold * canvasheight)
                                _menuScrollSpeed = 0;

                            _menuScrollSpeedOn = true;
                            _menuScrollSpeedReleaseStamp = DateTime.Now;
                        }
                    }

                    e.Handled = true;
                    break;
                case SKTouchAction.Exited:
                    ClearHighlightMenuItems();
                    break;
                case SKTouchAction.WheelChanged:
                    break;
                default:
                    break;
            }
        }

        private void DoLongMenuTap()
        {
            if (_savedMenuSender == null || _savedMenuEventArgs == null)
                return;
            DateTime curtime = DateTime.Now;
            if (curtime - _savedMenuTimeStamp < TimeSpan.FromSeconds(GHConstants.LongMenuTapThreshold * 0.8))
                return; /* Changed touch position */

            MainThread.BeginInvokeOnMainThread(() =>
            {
                MenuCanvas_LongTap(_savedMenuSender, _savedMenuEventArgs);
            });
        }

        private GHMenuItem _countMenuItem = null;
        List<GHNumberPickItem> _countPickList = new List<GHNumberPickItem>();
        private void MenuCanvas_LongTap(object sender, SKTouchEventArgs e)
        {
            int selectedidx = -1;
            bool menuItemSelected = false;
            int menuItemMaxCount = 0;
            string menuItemMainText = "";
            var menuItems = MenuCanvas.MenuItems;

            //lock (MenuCanvas.MenuItemLock)
            {
                for (int idx = _firstDrawnMenuItemIdx; idx >= 0 && idx <= _lastDrawnMenuItemIdx; idx++)
                {
                    if (idx >= menuItems.Count)
                        return;
                    if (e.Location.Y >= menuItems[idx].DrawBounds.Top && e.Location.Y <= menuItems[idx].DrawBounds.Bottom)
                    {
                        selectedidx = idx;
                        break;
                    }
                }

                if (selectedidx < 0)
                    return;

                if (MenuCanvas.SelectionHow == SelectionMode.None)
                    return;

                if (menuItems[selectedidx].Identifier == 0)
                    return;

                menuItemMaxCount = menuItems[selectedidx].MaxCount;
                if (menuItemMaxCount <= 1)
                {
                    if (MenuCanvas.SpecialClickOnLongTap)
                        MenuCanvas_NormalClickRelease(sender, e, true);

                    return;
                }

                _countMenuItem = menuItems[selectedidx];
                menuItemSelected = menuItems[selectedidx].Selected;
                menuItemMainText = menuItems[selectedidx].MainText;
            }

            /* No further action upon release */
            _menuTouchMoved = true;
            _menuPreviousReleaseClick = false;
            _menuPreviousReleaseClickIndex = -1;
            _savedPreviousMenuReleaseTimeStamp = new DateTime();

            if ((MenuCanvas.SelectionHow == SelectionMode.Multiple && !menuItemSelected)
                || (MenuCanvas.SelectionHow == SelectionMode.Single && selectedidx != MenuCanvas.SelectionIndex))
                MenuCanvas_NormalClickRelease(sender, e, false); /* Normal click selection first */

            if (_countMenuItem.MaxCount > 100)
            {
                MenuCountWidthGrid.VerticalOptions = LayoutOptions.Start;
                MenuCountWidthGrid.Margin = new Thickness(0, 50, 0, 0);
                CountPicker.IsVisible = false;
                MenuCountEntry.IsVisible = true;
                MenuCountEntry.IsEnabled = true;
                if (_countMenuItem.Count == -1)
                    MenuCountEntry.Text = _countMenuItem.MaxCount.ToString();
                else
                    MenuCountEntry.Text = _countMenuItem.Count.ToString();
            }
            else
            {
                MenuCountWidthGrid.VerticalOptions = LayoutOptions.Center;
                MenuCountWidthGrid.Margin = new Thickness(0, 0, 0, 0);
                CountPicker.IsVisible = true;
                MenuCountEntry.IsVisible = false;
                MenuCountEntry.IsEnabled = false;
                _countPickList.Clear();
                _countPickList.Add(new GHNumberPickItem(-1, "All"));
                int countselindex = -1;
                if (_countMenuItem.Count == -1)
                    countselindex = 0;
                for (int i = 0; i <= menuItemMaxCount; i++)
                {
                    _countPickList.Add(new GHNumberPickItem(i));
                    if (_countMenuItem.Count == i)
                        countselindex = i + 1;
                }
                CountPicker.ItemsSource = _countPickList;
                CountPicker.ItemDisplayBinding = new Binding("Name");
                CountPicker.SelectedIndex = countselindex;
            }

            MenuCountCaption.Text = (MenuCountEntry.IsVisible ? "Type" : "Select") + " Count for " + menuItemMainText;
            MenuCountOkButton.IsEnabled = true;
            MenuCountCancelButton.IsEnabled = true;
            MenuCountGrid.IsVisible = true;
            if(MenuCountEntry.IsVisible)
            {
                if(GHApp.AutoFocusOnEntry)
                    MenuCountEntry.Focus();
            }
        }

        private void ClearHighlightMenuItems()
        {
            if (!MenuCanvas.AllowHighlight)
                return;
            //lock (MenuCanvas.MenuItemLock)
            {
                var menuItems = MenuCanvas.MenuItems;
                if (menuItems == null)
                    return;

                for (int idx = 0; idx < menuItems.Count; idx++)
                {
                    menuItems[idx].Highlighted = false;
                }
            }
        }

        private void HighlightMenuItems(SKPoint p)
        {
            if (!MenuCanvas.AllowHighlight)
                return;
            //lock (MenuCanvas.MenuItemLock)
            {
                var menuItems = MenuCanvas.MenuItems;
                if (menuItems == null)
                    return;

                for (int idx = _firstDrawnMenuItemIdx; idx >= 0 && idx <= _lastDrawnMenuItemIdx; idx++)
                {
                    if (idx >= menuItems.Count)
                        break;
                    menuItems[idx].Highlighted = false;
                    if (menuItems[idx].DrawBounds.Contains(p))
                    {
                        GHMenuItem mi = menuItems[idx];
                        if (mi.Identifier != 0 && (mi.IsAutoClickOk || MenuCanvas.ClickOKOnSelection))
                        {
                            if (MenuCanvas.SelectionHow == SelectionMode.Multiple)
                            {
                                if(!mi.Selected)
                                    mi.Highlighted = true;
                            }
                            else if (MenuCanvas.SelectionHow == SelectionMode.Single)
                            {
                                mi.Highlighted = true;
                            }
                        }
                        break;
                    }
                }
            }
        }

        private MenuClickResult MenuCanvas_NormalClickRelease(object sender, SKTouchEventArgs e, bool isLongTap)
        {
            bool doclickok = false;
            bool okClicked = false;
            int clickIdx = -1;
            long identifier = 0;
            //lock (MenuCanvas.MenuItemLock)
            {
                var menuItems = MenuCanvas.MenuItems;
                if (menuItems == null)
                    return new MenuClickResult(okClicked, clickIdx, identifier);

                for (int idx = _firstDrawnMenuItemIdx; idx >= 0 && idx <= _lastDrawnMenuItemIdx; idx++)
                {
                    if (idx >= menuItems.Count)
                        break;
                    if (menuItems[idx].DrawBounds.Contains(e.Location))
                    {
                        clickIdx = idx;
                        identifier = menuItems[idx].Identifier;
                        doclickok = ClickMenuItem(idx, isLongTap);
                        break;
                    }
                }
            }

            okClicked = doclickok && MenuOKButton.IsEnabled;
            if (okClicked)
            {
                MenuCanvas.InvalidateSurface();
                PressMenuOKButton();
            }
            return new MenuClickResult(okClicked, clickIdx, identifier);
        }

        private bool ClickMenuItem(int menuItemIdx, bool isLongTap)
        {
            bool doclickok = false;
            //lock (MenuCanvas.MenuItemLock)
            {
                var menuItems = MenuCanvas.MenuItems;
                if (menuItems == null)
                {
                    _menuCountNumber = -1;
                    return false;
                }

                if (menuItemIdx < 0 || menuItemIdx >= menuItems.Count)
                    return false;

                GHMenuItem mi = menuItems[menuItemIdx];
                if (mi.Identifier == 0)
                {
                    if (MenuCanvas.SelectionHow == SelectionMode.Multiple && (mi.Flags & (ulong)MenuFlags.MENU_FLAGS_IS_GROUP_HEADING) != 0)
                    {
                        foreach (GHMenuItem o in menuItems)
                        {
                            if (o.GroupAccelerator == mi.HeadingGroupAccelerator)
                            {
                                if (!mi.HeadingUnselectGroup)
                                {
                                    o.Selected = true;
                                    o.Count = -1;
                                }
                                else
                                {
                                    o.Selected = false;
                                    o.Count = 0;
                                }
                            }
                        }
                        mi.HeadingUnselectGroup = !mi.HeadingUnselectGroup;
                    }
                }
                else
                {
                    if (MenuCanvas.SelectionHow == SelectionMode.Multiple)
                    {
                        mi.Selected = !mi.Selected;
                        if (mi.Selected)
                        {
                            mi.Count = _menuCountNumber > 0 && _menuCountNumber < mi.MaxCount ? _menuCountNumber : -1;
                            if (mi.IsAutoClickOk)
                                doclickok = true;
                        }
                        else
                            mi.Count = 0;
                    }
                    else
                    {
                        if (MenuCanvas.SelectionIndex >= 0 && MenuCanvas.SelectionIndex < menuItems.Count && mi != menuItems[MenuCanvas.SelectionIndex])
                            menuItems[MenuCanvas.SelectionIndex].Count = 0;

                        int oldselidx = MenuCanvas.SelectionIndex;
                        MenuCanvas.SelectionIndex = menuItemIdx;
                        if (mi.Count == 0)
                            mi.Count = _menuCountNumber > 0 && _menuCountNumber < mi.MaxCount ? _menuCountNumber : isLongTap ? -2 : -1;
                        else if (isLongTap)
                            mi.Count = -2;

                        /* Else keep the current selection number */
                        if (!MenuOKButton.IsEnabled)
                            MenuOKButton.IsEnabled = true;

                        if (mi.IsAutoClickOk || MenuCanvas.ClickOKOnSelection || isLongTap)
                            doclickok = true;
                    }
                }
            }

            _menuCountNumber = -1;
            return doclickok;
        }

        private void MenuCanvas_MouseWheel(object sender, GHMouseWheelEventArgs e)
        {
            ScrollMenu(e.MouseWheelDelta);
        }

        private void ScrollMenu(int delta)
        {
            if (delta != 0)
            {
                //float canvasheight = MenuCanvas.ThreadSafeCanvasSize.Height;
                float canvasheight;
                lock (_savedMenuCanvasLock)
                {
                    canvasheight = _savedMenuCanvasHeight;
                }
                float bottomScrollLimit = Math.Min(0, canvasheight - TotalMenuHeight);
                float scrollAmount = (canvasheight * delta) / (10 * 120);
                lock (_menuScrollLock)
                {
                    _menuScrollOffset += scrollAmount;
                    if (_menuScrollOffset < bottomScrollLimit)
                        _menuScrollOffset = bottomScrollLimit;
                    if (_menuScrollOffset > 0)
                        _menuScrollOffset = 0;

                    _menuScrollSpeedOn = false;
                    _menuScrollSpeed = 0;
                    _menuScrollSpeedRecordOn = false;
                    _menuScrollSpeedRecords.Clear();
                    InterlockedMenuScrollOffset = _menuScrollOffset;
                }
            }
        }

        private bool IsTextWindowAtBottomScrollLimit()
        {
            //float canvasheight = TextCanvas.ThreadSafeCanvasSize.Height;
            float canvasheight;
            lock (_savedTextCanvasLock)
            {
                canvasheight = _savedTextCanvasHeight;
            }
            float bottomScrollLimit = Math.Min(0, canvasheight - TotalTextHeight);
            lock (_textScrollLock)
            {
                return Math.Abs(_textScrollOffset - bottomScrollLimit) < canvasheight * 0.005f; //_textScrollOffset == bottomScrollLimit
            }
        }

        private bool IsMenuAtBottomScrollLimit()
        {
            //float canvasheight = MenuCanvas.ThreadSafeCanvasSize.Height;
            float canvasheight;
            lock (_savedMenuCanvasLock)
            {
                canvasheight = _savedMenuCanvasHeight;
            }
            float bottomScrollLimit = Math.Min(0, canvasheight - TotalMenuHeight);
            lock (_menuScrollLock)
            {
                return Math.Abs(_menuScrollOffset - bottomScrollLimit) < canvasheight * 0.005f; //_menuScrollOffset == bottomScrollLimit;
            }
        }

#pragma warning disable 414
        private readonly object _menuHoverLock = new object();
        private bool _menuIsHovering = false;
        private SKPoint _menuHoverPoint = new SKPoint();

        private void MenuCanvas_MousePointer(object sender, SKTouchEventArgs e)
        {
            if (MenuDrawOnlyClear)
                return;
            //lock (_menuDrawOnlyLock)
            //{
            //    if (_menuDrawOnlyClear)
            //        return;
            //}

            lock(_menuHoverLock)
            {
                _menuHoverPoint = e.Location;
                switch (e?.ActionType)
                {
                    case SKTouchAction.Entered:
                    case SKTouchAction.Moved:
                        _menuIsHovering = true;
                        break;
                    case SKTouchAction.Cancelled:
                    case SKTouchAction.Exited:
                        _menuIsHovering = false;
                        break;

                }
            }
        }
#pragma warning restore 414


        //private readonly object _menuHideCancelledLock = new object();
        private int _menuHideCancelled = 0;
        private int _menuHideOn = 0;
        private bool MenuHideCancelled { get { return Interlocked.CompareExchange(ref _menuHideCancelled, 0, 0) != 0; } set { Interlocked.Exchange(ref _menuHideCancelled, value ? 1 : 0); } }
        private bool MenuHideOn { get { return Interlocked.CompareExchange(ref _menuHideOn, 0, 0) != 0; } set { Interlocked.Exchange(ref _menuHideOn, value ? 1 : 0); } }

        private async void MenuOKButton_Clicked(object sender, EventArgs e)
        {
            await MenuOKButtonPressedAsync();
        }
        private void PressMenuOKButton()
        {
            try
            {
                MainThread.BeginInvokeOnMainThread(async () =>
                {
                    try
                    {
                        await MenuOKButtonPressedAsync();
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex);
                    }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
            }
        }
        private async Task MenuOKButtonPressedAsync()
        {
            MenuOKButton.IsEnabled = false;
            MenuCancelButton.IsEnabled = false;
            GHApp.PlayButtonClickedSound();
            _menuCountNumber = -1;

            MenuRefresh = false;
            MenuDrawOnlyClear = true;
            //lock (_menuDrawOnlyLock)
            //{
            //    _menuRefresh = false;
            //    _menuDrawOnlyClear = true;
            //}

            lock (_menuScrollLock)
            {
                lock (_menuPositionLock)
                {
                    if (_menuPositionSavingOn[(int)MenuCanvas.MenuStyle])
                    {
                        _savedMenuScrollOffset[(int)MenuCanvas.MenuStyle] = _menuScrollOffset;
                    }
                }
                _menuScrollOffset = 0;
                _menuScrollSpeed = 0;
                _menuScrollSpeedOn = false;
                _menuScrollSpeedRecords.Clear();
                InterlockedMenuScrollOffset = _menuScrollOffset;
            }

            List<GHMenuItem> resultlist = new List<GHMenuItem>();
            var menuItems = MenuCanvas.MenuItems;
            //lock (MenuCanvas.MenuItemLock)
            if (menuItems != null)
            {
                if (MenuCanvas.SelectionHow == SelectionMode.Multiple)
                {
                    foreach (GHMenuItem mi in menuItems)
                    {
                        if (mi.Selected && mi.Count != 0)
                        {
                            resultlist.Add(mi);
                        }
                    }
                }
                else if (MenuCanvas.SelectionHow == SelectionMode.Single)
                {
                    if (MenuCanvas.SelectionIndex > -1 && MenuCanvas.SelectionIndex < menuItems.Count)
                    {
                        GHMenuItem mi = menuItems[MenuCanvas.SelectionIndex];
                        if (mi.Count != 0)
                        {
                            resultlist.Add(mi);
                        }
                    }
                }
            }

            GHGame curGame = GHApp.CurrentGHGame;
            GHWindow origWindow;
            if (MenuCanvas.GHWindow.ClonedFrom == null)
                curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.ShowMenuPage, MenuCanvas.GHWindow, resultlist, false));
            else if (MenuCanvas.GHWindow.ClonedFrom.TryGetTarget(out origWindow))
                curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.ShowMenuPage, origWindow, resultlist, false));
            else
                curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.ShowMenuPage, null, resultlist, false));

            if (!UIUtils.StyleClosesMenuUponDestroy(MenuCanvas.MenuStyle))
                await DelayedMenuHide();
        }

        private async void MenuCancelButton_Clicked(object sender, EventArgs e)
        {
            await MenuCancelButtonPressedAsync();
        }
        private void PressMenuCancelButton()
        {
            try
            {
                MainThread.BeginInvokeOnMainThread(async () =>
                {
                    try
                    {
                        await MenuCancelButtonPressedAsync();
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex);
                    }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
            }
        }
        private async Task MenuCancelButtonPressedAsync()
        {
            MenuOKButton.IsEnabled = false;
            MenuCancelButton.IsEnabled = false;
            GHApp.PlayButtonClickedSound();
            _menuCountNumber = -1;

            MenuRefresh = false;
            MenuDrawOnlyClear = true;
            //lock (_menuDrawOnlyLock)
            //{
            //    _menuRefresh = false;
            //    _menuDrawOnlyClear = true;
            //}

            lock (_menuScrollLock)
            {
                lock (_menuPositionLock)
                {
                    if (_menuPositionSavingOn[(int)MenuCanvas.MenuStyle])
                    {
                        _savedMenuScrollOffset[(int)MenuCanvas.MenuStyle] = _menuScrollOffset;
                    }
                }
                _menuScrollOffset = 0;
                _menuScrollSpeed = 0;
                _menuScrollSpeedOn = false;
                _menuScrollSpeedRecords.Clear();
                InterlockedMenuScrollOffset = _menuScrollOffset;
            }

            GHGame curGame = GHApp.CurrentGHGame;
            GHWindow origWindow;
            if (MenuCanvas.GHWindow.ClonedFrom == null)
                curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.ShowMenuPage, MenuCanvas.GHWindow, new List<GHMenuItem>(1), true));
            else if (MenuCanvas.GHWindow.ClonedFrom.TryGetTarget(out origWindow))
                curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.ShowMenuPage, origWindow, new List<GHMenuItem>(1), true));
            else
                curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.ShowMenuPage, null, new List<GHMenuItem>(1), true));

            if (!UIUtils.StyleClosesMenuUponDestroy(MenuCanvas.MenuStyle))
                await DelayedMenuHide();
        }

#if GNH_MAUI
        private readonly List<IDispatcherTimer> _menuHideTimers = new List<IDispatcherTimer>();
        private void StopMenuHideTimers()
        {
            List <IDispatcherTimer> tempList = new List<IDispatcherTimer>(_menuHideTimers);
            foreach (IDispatcherTimer t in tempList)
            {
                t.Stop();
            }
            _menuHideTimers.Clear();
        }
        private readonly List<IDispatcherTimer> _textHideTimers = new List<IDispatcherTimer>();
        private void StopTextHideTimers()
        {
            List<IDispatcherTimer> tempList = new List<IDispatcherTimer>(_textHideTimers);
            foreach (IDispatcherTimer t in tempList)
            {
                t.Stop();
            }
            _textHideTimers.Clear();
        }
#endif

        private async Task DelayedMenuHide()
        {
#if GNH_MAUI
            StopMenuHideTimers();
#endif
            //lock(_menuHideCancelledLock)
            {
                MenuHideCancelled = false;
                MenuHideOn = true;
            }

            if(GHApp.IsiOS)
            {
                MenuStack.CancelAnimations();
                await MenuStack.FadeTo(0.0, 64);
            }

#if GNH_MAUI
            var timer = Microsoft.Maui.Controls.Application.Current.Dispatcher.CreateTimer();
            timer.Interval = TimeSpan.FromSeconds(UIUtils.GetWindowHideSecs());
            timer.IsRepeating = false;
            timer.Tick += (s, e) => { DoTimedMenuHide(); };
            _menuHideTimers.Add(timer);
            timer.Start();
#else
            Device.StartTimer(TimeSpan.FromSeconds(UIUtils.GetWindowHideSecs()), () =>
            {
                DoTimedMenuHide();
                return false;
            });
#endif
        }

        private void DoTimedMenuHide()
        {
            //lock (_menuHideCancelledLock)
            {
                MenuHideOn = false;
                if (Interlocked.CompareExchange(ref _menuHideCancelled, 0, 1) == 1)
                {
                    //_menuHideCancelled = false;
                    return;
                }
            }

            MainThread.BeginInvokeOnMainThread(() =>
            {
                MenuGrid.IsVisible = false;
                //MainGrid.IsVisible = true;
                IsMainCanvasOn = true;
                StopMenuCanvasAnimation();
                MenuWindowGlyphImage.StopAnimation();
                RefreshScreen = true;
                StartMainCanvasAnimation();
            });
        }

        //private readonly object _delayedTextHideLock = new object();
        private int _delayedTextHideOn = 0;
        private int _delayedTextHideCancelled = 0;
        private bool DelayedTextHideOn { get { return Interlocked.CompareExchange(ref _delayedTextHideOn, 0, 0) != 0; } set { Interlocked.Exchange(ref _delayedTextHideOn, value ? 1 : 0); } }
        private bool DelayedTextHideCancelled { get { return Interlocked.CompareExchange(ref _delayedTextHideCancelled, 0, 0) != 0; } set { Interlocked.Exchange(ref _delayedTextHideCancelled, value ? 1 : 0); } }
        private async Task DelayedTextHide()
        {
#if GNH_MAUI
            StopTextHideTimers();
#endif
            //lock (_delayedTextHideLock)
            {
                DelayedTextHideOn = true;
                DelayedTextHideCancelled = false;
            }
            if (GHApp.IsiOS)
            {
                TextStack.CancelAnimations();
                await TextStack.FadeTo(0.0, 64);
            }
#if GNH_MAUI
            var timer = Microsoft.Maui.Controls.Application.Current.Dispatcher.CreateTimer();
            timer.Interval = TimeSpan.FromSeconds(UIUtils.GetWindowHideSecs());
            timer.IsRepeating = false;
            timer.Tick += (s, e) => { DoTimedTextHide(); };
            _textHideTimers.Add(timer);
            timer.Start();
#else
            Device.StartTimer(TimeSpan.FromSeconds(UIUtils.GetWindowHideSecs()), () =>
            {
                DoTimedTextHide();
                return false;
            });
#endif
        }

        private void DoTimedTextHide()
        {
            //lock (_delayedTextHideLock)
            {
                DelayedTextHideOn = false;
                if (Interlocked.CompareExchange(ref _delayedTextHideCancelled, 0, 1) == 1)
                {
                    //_delayedTextHideCancelled = false;
                    return;
                }
            }

            MainThread.BeginInvokeOnMainThread(() =>
            {
                TextGrid.IsVisible = false;
                //MainGrid.IsVisible = true;
                IsMainCanvasOn = true;
                TextWindowGlyphImage.StopAnimation();
                lock (_textScrollLock)
                {
                    _textScrollOffset = 0;
                    _textScrollSpeed = 0;
                    _textScrollSpeedOn = false;
                    InterlockedTextScrollOffset = _textScrollOffset;
                }
                StopTextCanvasAnimation();
                RefreshScreen = true;
                StartMainCanvasAnimation();
            });
        }

        private bool _unselectOnTap = false;

#if GNH_MAUI
        private void MenuTapGestureRecognizer_Tapped(object sender, TappedEventArgs e)
#else
        private void MenuTapGestureRecognizer_Tapped(object sender, EventArgs e)
#endif
        {
            if (PlayingReplay)
                return;

            if (MenuCanvas.SelectionHow == SelectionMode.Multiple)
            {
                var menuItems = MenuCanvas.MenuItems;
                //lock (MenuCanvas.MenuItemLock)
                {
                    foreach (GHMenuItem o in menuItems)
                    {
                        if (o.Identifier != 0)
                        {
                            if (!_unselectOnTap)
                            {
                                o.Selected = true;
                                o.Count = -1;
                            }
                            else
                            {
                                o.Selected = false;
                                o.Count = 0;
                            }
                        }
                    }
                    _unselectOnTap = !_unselectOnTap;
                }
                MenuCanvas.InvalidateSurface();
            }
        }

        private void MenuCountOkButton_Clicked(object sender, EventArgs e)
        {
            MenuCountOkButton.IsEnabled = false;
            if (_countMenuItem != null)
            {
                if (MenuCountEntry.IsVisible)
                {
                    string str = MenuCountEntry.Text;
                    int value;
                    bool res = int.TryParse(str, out value);
                    if (res)
                    {
                        if (value < 0 || value > _countMenuItem.MaxCount)
                            _countMenuItem.Count = -1;
                        else
                            _countMenuItem.Count = value;
                    }
                    else
                    {
                        MenuCountEntry.TextColor = GHColors.Red;
                        MenuCountEntry.Focus();
                        MenuCountOkButton.IsEnabled = true;
                        return;
                    }
                }
                else
                {
                    if (CountPicker.SelectedIndex >= 0 && CountPicker.SelectedIndex < _countPickList.Count)
                    {
                        //lock (MenuCanvas.MenuItemLock)
                        {
                            _countMenuItem.Count = _countPickList[CountPicker.SelectedIndex].Number;
                            _countMenuItem.Selected = _countMenuItem.Count != 0;
                        }
                    }
                }
            }
            MenuCountGrid.IsVisible = false;
            MenuCountEntry.Unfocus();
            MenuCountEntry.IsEnabled = false;
        }

        private void MenuCountCancelButton_Clicked(object sender, EventArgs e)
        {
            MenuCountCancelButton.IsEnabled = false;
            MenuCountGrid.IsVisible = false;
            MenuCountEntry.Unfocus();
            MenuCountEntry.IsEnabled = false;
        }

        private void MenuEntry_PropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (_countMenuItem != null)
            {
                MenuCountEntry.TextColor = GHColors.White;
            }
        }

        private void MenuCountEntry_Completed(object sender, EventArgs e)
        {
            if (MenuCountGrid.IsVisible && MenuCountOkButton.IsEnabled && GHApp.PressOkOnEntryCompleted)
            {
                MenuCountOkButton_Clicked(sender, e);
            }
        }


        private GlyphImageSource _textGlyphImageSource = new GlyphImageSource();

        public GlyphImageSource TextGlyphImage
        {
            get
            {
                return _textGlyphImageSource;
            }
        }

        public bool IsTextGlyphVisible
        {
            get
            {
                return (Math.Abs(_textGlyphImageSource.Glyph) > 0 && _textGlyphImageSource.Glyph != GHApp.NoGlyph);
            }
        }

        //private readonly object _totalTextHeightLock = new object();
        private float _totalTextHeight = 0;
        private float TotalTextHeight 
        { 
            get 
            {
                //lock (_totalTextHeightLock)
                //{
                //    return _totalTextHeight;
                //}
                return Interlocked.CompareExchange(ref _totalTextHeight, 0.0f, 0.0f);
            } 
            set 
            {
                //lock (_totalTextHeightLock)
                //{ 
                //    _totalTextHeight = value; 
                //} 
                Interlocked.Exchange(ref _totalTextHeight, value);
            } 
        }

        private float _interlockedTextScrollOffset = 0;
        private float InterlockedTextScrollOffset { get { return Interlocked.CompareExchange(ref _interlockedTextScrollOffset, 0.0f, 0.0f); } set { Interlocked.Exchange(ref _interlockedTextScrollOffset, value); } }
        private readonly object _textScrollLock = new object();
        private float _textScrollOffset = 0;
        private float _textScrollSpeed = 0; /* pixels per second */
        private bool _textScrollSpeedRecordOn = false;
        private DateTime _textScrollSpeedStamp;
        List<TouchSpeedRecord> _textScrollSpeedRecords = new List<TouchSpeedRecord>();
        private bool _textScrollSpeedOn = false;
        private DateTime _textScrollSpeedReleaseStamp;

        private ConcurrentDictionary<long, TouchEntry> TextTouchDictionary = new ConcurrentDictionary<long, TouchEntry>();
        private object _savedTextSender = null;
        private SKTouchEventArgs _savedTextEventArgs = null;
        private DateTime _savedTextTimeStamp;
        private bool _textTouchMoved = false;
        private bool _textCanvasThreadChecked = false;

        private readonly object _savedTextCanvasLock = new object();
        private float _savedTextCanvasWidth = 0;
        private float _savedTextCanvasHeight = 0;
        private void TextCanvas_PaintSurface(object sender, SKPaintSurfaceEventArgs e)
        {
            bool isTextOnMainThread = MainThread.IsMainThread;
            if (!_textCanvasThreadChecked && !isTextOnMainThread)
            {
                _textCanvasThreadChecked = true;
                GHApp.MaybeWriteGHLog("TextCanvas_PaintSurface not on main thread!");
            }

            if (!TextGrid.ThreadSafeIsVisible || LoadingGrid.ThreadSafeIsVisible)
                return;

            GHGame curGame = GHApp.CurrentGHGame;
            if (curGame == null)
                return;

            SKImageInfo info = e.Info;
            SKSurface surface = e.Surface;
            SKCanvas canvas = surface.Canvas;
            float canvaswidth = e.Info.Width; // TextCanvas.CanvasSize.Width;
            float canvasheight = e.Info.Height; // TextCanvas.CanvasSize.Height;
            float x = 0, y = 0;
            ReadOnlySpan<char> str;
            float canvasUIwidth = (float)TextCanvas.ThreadSafeWidth;
            float scale = canvaswidth / Math.Max(1.0f, canvasUIwidth);
            float customScale = GHApp.CustomScreenScale;
            bool lockTaken = false;
            try
            {
                Monitor.TryEnter(_savedTextCanvasLock, ref lockTaken);
                if (lockTaken)
                {
                    _savedTextCanvasWidth = canvaswidth;
                    _savedTextCanvasHeight = canvasheight;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_savedTextCanvasLock);
            }
            lockTaken = false;

            canvas.Clear();
            if (canvaswidth <= 16 || canvasheight <= 16)
                return;

            //lock (TextCanvas.MenuItemLock)
            {
                var textItems = TextCanvas.PutStrItems;
                if (textItems == null || textItems.Count == 0)
                    return;
            }

            using (GHSkiaFontPaint textPaint = new GHSkiaFontPaint())
            {
                if (TextCanvas.GHWindow != null && TextCanvas.GHWindow.Ascension)
                {
                    long counter;
                    //lock (AnimationTimerLock)
                    {
                        counter = curGame.GeneralAnimationCounter; // Interlocked.CompareExchange(ref AnimationTimers.general_animation_counter, 0L, 0L);;
                    }
                    UIUtils.DrawRandomSparkles(canvas, textPaint.Paint, canvaswidth, canvasheight, scale, counter);
                }

                textPaint.Typeface = GHApp.UnderwoodTypeface;
                textPaint.TextSize = 30 * scale;
                textPaint.Style = SKPaintStyle.Fill;
                float minrowheight = textPaint.FontSpacing;
                float leftinnerpadding = 5;
                float curmenuoffset = InterlockedTextScrollOffset;
                //lock (_textScrollLock)
                //{
                //    curmenuoffset = _textScrollOffset;
                //}
                y += curmenuoffset;
                double canvasmaxwidth = TextCanvas.GHWindow != null ? TextCanvas.GHWindow.TextWindowMaximumWidth : GHConstants.DefaultTextWindowMaxWidth;
                double menuwidth = Math.Max(1.0, Math.Min(canvasUIwidth, canvasmaxwidth) * customScale);
                float menuwidthoncanvas = (float)(menuwidth * scale);
                float leftmenupadding = Math.Max(0, (canvaswidth - menuwidthoncanvas) / 2);
                float rightmenupadding = leftmenupadding;
                float topPadding = 0;
                bool wrapglyph = TextCanvas.GHWindow != null ? TextCanvas.GHWindow.WrapGlyph : false;
                bool glyphVisible = TextWindowGlyphImage.ThreadSafeIsVisible;
                double glyphX = TextWindowGlyphImage.ThreadSafeX;
                double glyphY = TextWindowGlyphImage.ThreadSafeY;
                //double glyphWidth = TextWindowGlyphImage.ThreadSafeWidth;
                double glyphHeight = TextWindowGlyphImage.ThreadSafeHeight;
                float glyphpadding = 0;
                float glyphystart = scale * (float)Math.Max(0.0, glyphY - TextCanvas.ThreadSafeY);
                float glyphyend = scale * (float)Math.Max(0.0, glyphY + glyphHeight - TextCanvas.ThreadSafeY);
                float glyphvisiblepadding = scale * (float)Math.Max(0.0, TextCanvas.ThreadSafeX + TextCanvas.ThreadSafeWidth - glyphX);

                //lock (TextCanvas.TextItemLock)
                {
                    int j = 0;
                    y += topPadding;
                    var textItems = TextCanvas.PutStrItems;
                    foreach (GHPutStrItem putstritem in textItems)
                    {
                        int pos = 0;
                        x = leftmenupadding + leftinnerpadding;
                        x += (float)putstritem.LeftPaddingWidth * scale * customScale;
                        textPaint.Typeface = GHApp.GetTypefaceByName(putstritem.TextWindowFontFamily);
                        textPaint.TextSize = (float)putstritem.TextWindowFontSize * scale * customScale;
                        /* Heading margin, except on the first row */
                        if(putstritem.InstructionList.Count > 0 && j > 0)
                        {
                            if ((putstritem.InstructionList[0].Attributes & (int)MenuItemAttributes.HalfSize) != 0)
                            {
                                textPaint.TextSize /= 2;
                            }
                            if ((putstritem.InstructionList[0].Attributes & (int)MenuItemAttributes.Heading) != 0)
                            {
                                if ((putstritem.InstructionList[0].Attributes & (int)MenuItemAttributes.Sub) != 0)
                                    y += textPaint.FontSpacing / 3.0f;
                                else
                                    y += textPaint.FontSpacing / 2.0f;
                            }
                            else if ((putstritem.InstructionList[0].Attributes & (int)MenuItemAttributes.Title) != 0)
                            {
                                if ((putstritem.InstructionList[0].Attributes & (int)MenuItemAttributes.Sub) != 0)
                                    y += 0.0f;
                                else
                                    y += textPaint.FontSpacing / 2.0f;
                            }
                        }
                        float fontspacingpadding = (textPaint.FontSpacing - (textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent)) / 2;
                        y += fontspacingpadding;
                        y -= textPaint.FontMetrics.Ascent;
                        bool firstprintonrow = true;
                        float start_x = x;
                        float indent_start_x = start_x;
                        //string indentstr = putstritem.GetIndentationString();
                        //if(indentstr != "")
                        //{
                        //    indent_start_x += textPaint.MeasureText(indentstr);
                        //}
                        ReadOnlySpan<char> indentSpan;
                        putstritem.GetIndentationSpan(out indentSpan);
                        if (!indentSpan.IsEmpty)
                            indent_start_x += textPaint.MeasureText(indentSpan);

                        if (glyphVisible && (wrapglyph || (putstritem.InstructionList.Count > 0 && (putstritem.InstructionList[0].Attributes & (int)MenuItemAttributes.Title) != 0)))
                            glyphpadding = glyphvisiblepadding;
                        else
                            glyphpadding = 0;

                        foreach (GHPutStrInstructions instr in putstritem.InstructionList)
                        {
                            if (putstritem.Text == null)
                                str = ReadOnlySpan<char>.Empty;
                            else if (pos + instr.PrintLength <= putstritem.Text.Length)
                                str = putstritem.Text.AsSpan(pos, instr.PrintLength);
                            else if (putstritem.Text.Length - pos > 0)
                                str = putstritem.Text.AsSpan(pos, putstritem.Text.Length - pos);
                            else
                                str = ReadOnlySpan<char>.Empty;

                            pos += str.Length;

                            textPaint.Color = UIUtils.NHColor2SKColorCore(
                                instr.Color < (int)NhColor.CLR_MAX ? instr.Color : TextCanvas.RevertBlackAndWhite ? (int)NhColor.CLR_BLACK : (int)NhColor.CLR_WHITE, 
                                instr.Attributes,
                                TextCanvas.RevertBlackAndWhite, false);

                            //string[] split = str.Split(' ');
                            DrawSplittableText(canvas, str, null, null, null, ref x, ref y, ref firstprintonrow, indent_start_x, canvaswidth, canvasheight, rightmenupadding, textPaint, TextCanvas.GHWindow.UseSpecialSymbols, TextCanvas.UseTextOutline, TextCanvas.RevertBlackAndWhite, false, 0, curmenuoffset, glyphystart, glyphyend, glyphpadding);
                        }
                        j++;
                        y += textPaint.FontMetrics.Descent + fontspacingpadding;
                    }
                    TotalTextHeight = y - curmenuoffset;
                }
            }
            canvas.Flush();
        }

        private void TextCanvas_Touch(object sender, SKTouchEventArgs e)
        {
            float canvasheight;
            lock (_savedTextCanvasLock)
            {
                canvasheight = _savedTextCanvasHeight;
            }
            //lock (TextCanvas.TextItemLock)
            {
                //float canvasheight = TextCanvas.ThreadSafeCanvasSize.Height;
                float bottomScrollLimit = Math.Min(0, canvasheight - TotalTextHeight);
                switch (e?.ActionType)
                {
                    case SKTouchAction.Entered:
                        break;
                    case SKTouchAction.Pressed:
                        _savedTextSender = null;
                        _savedTextEventArgs = null;
                        _savedTextTimeStamp = DateTime.Now;

                        if (TextTouchDictionary.ContainsKey(e.Id))
                            TextTouchDictionary[e.Id] = new TouchEntry(e.Location, DateTime.Now);
                        else
                            TextTouchDictionary.TryAdd(e.Id, new TouchEntry(e.Location, DateTime.Now));

                        lock (_textScrollLock)
                        {
                            _textScrollSpeed = 0;
                            _textScrollSpeedOn = false;
                            _textScrollSpeedRecordOn = false;
                            _textScrollSpeedRecords.Clear();
                        }

                        if (TextTouchDictionary.Count > 1)
                            _textTouchMoved = true;
                        else
                        {
                            _savedTextSender = sender;
                            _savedTextEventArgs = e;
                        }

                        e.Handled = true;
                        break;
                    case SKTouchAction.Moved:
                        {
                            TouchEntry entry;
                            bool res = TextTouchDictionary.TryGetValue(e.Id, out entry);
                            if (res)
                            {
                                SKPoint anchor = entry.Location;

                                float diffX = e.Location.X - anchor.X;
                                float diffY = e.Location.Y - anchor.Y;
                                float dist = (float)Math.Sqrt((Math.Pow(diffX, 2) + Math.Pow(diffY, 2)));

                                if (TextTouchDictionary.Count == 1)
                                {
                                    if ((dist > 25 ||
                                        (DateTime.Now.Ticks - entry.PressTime.Ticks) / TimeSpan.TicksPerMillisecond > GHConstants.MoveOrPressTimeThreshold
                                           ))
                                    {
                                        /* Just one finger => Move the map */
                                        if (diffX != 0 || diffY != 0)
                                        {
                                            //lock (_textScrollLock)
                                            //{
                                            //    _textScrollOffset += diffY;
                                            //    if (_textScrollOffset > 0)
                                            //        _textScrollOffset = 0;
                                            //    else if (_textScrollOffset < bottomScrollLimit)
                                            //        _textScrollOffset = bottomScrollLimit;
                                            //}

                                            DateTime now = DateTime.Now;
                                            /* Do not scroll within button press time threshold, unless large move */
                                            long millisecs_elapsed = (now.Ticks - entry.PressTime.Ticks) / TimeSpan.TicksPerMillisecond;
                                            if (dist > GHConstants.MoveDistanceThreshold || millisecs_elapsed > GHConstants.MoveOrPressTimeThreshold)
                                            {
                                                lock (_textScrollLock)
                                                {
                                                    float stretchLimit = GHConstants.ScrollStretchLimit * canvasheight;
                                                    float stretchConstant = GHConstants.ScrollConstantStretch * canvasheight;
                                                    float adj_factor = 1.0f;
                                                    if (_textScrollOffset > 0)
                                                        adj_factor = _textScrollOffset >= stretchLimit ? 0 : (1 - ((_textScrollOffset + stretchConstant) / (stretchLimit + stretchConstant)));
                                                    else if (_textScrollOffset < bottomScrollLimit)
                                                        adj_factor = _textScrollOffset < bottomScrollLimit - stretchLimit ? 0 : (1 - ((bottomScrollLimit - (_textScrollOffset - stretchConstant)) / (stretchLimit + stretchConstant)));

                                                    float adj_diffY = diffY * adj_factor;
                                                    _textScrollOffset += adj_diffY;

                                                    if (_textScrollOffset > stretchLimit)
                                                        _textScrollOffset = stretchLimit;
                                                    else if (_textScrollOffset < bottomScrollLimit - stretchLimit)
                                                        _textScrollOffset = bottomScrollLimit - stretchLimit;
                                                    else
                                                    {
                                                        /* Calculate duration since last touch move */
                                                        float duration = 0;
                                                        if (!_textScrollSpeedRecordOn)
                                                        {
                                                            duration = (float)millisecs_elapsed / 1000f;
                                                            _textScrollSpeedRecordOn = true;
                                                        }
                                                        else
                                                        {
                                                            duration = ((float)(now.Ticks - _textScrollSpeedStamp.Ticks) / TimeSpan.TicksPerMillisecond) / 1000f;
                                                        }
                                                        _textScrollSpeedStamp = now;

                                                        /* Discard speed records to the opposite direction */
                                                        if (_textScrollSpeedRecords.Count > 0)
                                                        {
                                                            int prevsgn = Math.Sign(_textScrollSpeedRecords[0].Distance);
                                                            if (diffY != 0 && prevsgn != 0 && Math.Sign(diffY) != prevsgn)
                                                                _textScrollSpeedRecords.Clear();
                                                        }

                                                        /* Add a new speed record */
                                                        _textScrollSpeedRecords.Insert(0, new TouchSpeedRecord(diffY, duration, now));

                                                        /* Discard too old records */
                                                        while (_textScrollSpeedRecords.Count > 0)
                                                        {
                                                            long lastrecord_ms = (now.Ticks - _textScrollSpeedRecords[_textScrollSpeedRecords.Count - 1].TimeStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                                                            if (lastrecord_ms > GHConstants.ScrollRecordThreshold)
                                                                _textScrollSpeedRecords.RemoveAt(_textScrollSpeedRecords.Count - 1);
                                                            else
                                                                break;
                                                        }

                                                        /* Sum up the distances and durations of current records to get an average */
                                                        float totaldistance = 0;
                                                        float totalsecs = 0;
                                                        foreach (TouchSpeedRecord r in _textScrollSpeedRecords)
                                                        {
                                                            totaldistance += r.Distance;
                                                            totalsecs += r.Duration;
                                                        }
                                                        _textScrollSpeed = totaldistance / Math.Max(0.001f, totalsecs);
                                                        _textScrollSpeedOn = false;
                                                    }
                                                    InterlockedTextScrollOffset = _textScrollOffset;
                                                }
                                                TextTouchDictionary[e.Id].Location = e.Location;
                                                _textTouchMoved = true;
                                                _savedTextTimeStamp = DateTime.Now;
                                            }
                                        }
                                    }
                                }
                            }
                            e.Handled = true;
                        }
                        break;
                    case SKTouchAction.Released:
                        {
                            _savedTextSender = null;
                            _savedTextEventArgs = null;
                            _savedTextTimeStamp = DateTime.Now;

                            TouchEntry entry;
                            bool res = TextTouchDictionary.TryGetValue(e.Id, out entry);
                            if (res)
                            {
                                long elapsedms = (DateTime.Now.Ticks - entry.PressTime.Ticks) / TimeSpan.TicksPerMillisecond;

                                if (elapsedms <= GHConstants.MoveOrPressTimeThreshold && !_textTouchMoved)
                                {
                                    /* Normal click -- Hide the canvas */
                                    TextCanvasPressed();
                                }
                                if (TextTouchDictionary.ContainsKey(e.Id))
                                {
                                    TouchEntry removedEntry;
                                    TextTouchDictionary.TryRemove(e.Id, out removedEntry);
                                }
                                else
                                    TextTouchDictionary.Clear(); /* Something's wrong; reset the touch dictionary */

                                //if (TextTouchDictionary.Count == 0)
                                //    _textTouchMoved = false;

                                if (TextTouchDictionary.Count == 0)
                                {
                                    lock (_textScrollLock)
                                    {
                                        long lastrecord_ms = 0;
                                        if (_textScrollSpeedRecords.Count > 0)
                                        {
                                            lastrecord_ms = (DateTime.Now.Ticks - _textScrollSpeedRecords[_textScrollSpeedRecords.Count - 1].TimeStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                                        }

                                        if (_textScrollOffset > 0 || _textScrollOffset < bottomScrollLimit)
                                        {
                                            if (lastrecord_ms > GHConstants.ScrollRecordThreshold
                                                || Math.Abs(_textScrollSpeed) < GHConstants.ScrollSpeedThreshold * canvasheight)
                                                _textScrollSpeed = 0;

                                            _textScrollSpeedOn = true;
                                            _textScrollSpeedReleaseStamp = DateTime.Now;
                                        }
                                        else if (lastrecord_ms > GHConstants.ScrollRecordThreshold)
                                        {
                                            _textScrollSpeedOn = false;
                                            _textScrollSpeed = 0;
                                        }
                                        else if (Math.Abs(_textScrollSpeed) >= GHConstants.ScrollSpeedThreshold * canvasheight)
                                        {
                                            _textScrollSpeedOn = true;
                                            _textScrollSpeedReleaseStamp = DateTime.Now;
                                        }
                                        else
                                        {
                                            _textScrollSpeedOn = false;
                                            _textScrollSpeed = 0;
                                        }
                                        _textScrollSpeedRecordOn = false;
                                        _textScrollSpeedRecords.Clear();
                                    }
                                    _textTouchMoved = false;
                                }
                            }
                            e.Handled = true;
                        }
                        break;
                    case SKTouchAction.Cancelled:
                        if (TextTouchDictionary.ContainsKey(e.Id))
                        {
                            TouchEntry removedEntry;
                            TextTouchDictionary.TryRemove(e.Id, out removedEntry);
                        }
                        else
                            TextTouchDictionary.Clear(); /* Something's wrong; reset the touch dictionary */

                        lock (_textScrollLock)
                        {
                            if (_textScrollOffset > 0 || _textScrollOffset < bottomScrollLimit)
                            {
                                long lastrecord_ms = 0;
                                if (_textScrollSpeedRecords.Count > 0)
                                {
                                    lastrecord_ms = (DateTime.Now.Ticks - _textScrollSpeedRecords[_textScrollSpeedRecords.Count - 1].TimeStamp.Ticks) / TimeSpan.TicksPerMillisecond;
                                }

                                if (lastrecord_ms > GHConstants.ScrollRecordThreshold
                                    || Math.Abs(_textScrollSpeed) < GHConstants.ScrollSpeedThreshold * canvasheight)
                                    _textScrollSpeed = 0;

                                _textScrollSpeedOn = true;
                                _textScrollSpeedReleaseStamp = DateTime.Now;
                            }
                        }

                        e.Handled = true;
                        break;
                    case SKTouchAction.Exited:
                        break;
                    case SKTouchAction.WheelChanged:
                        break;
                    default:
                        break;
                }
            }
        }

        private void TextCanvasPressed()
        {
            GenericButton_Clicked(null, null, GHConstants.CancelChar);
            try
            {
                MainThread.BeginInvokeOnMainThread(async () =>
                {
                    try
                    {
                        await DelayedTextHide();
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex);
                    }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
            }
        }

        private void TextCanvas_MouseWheel(object sender, GHMouseWheelEventArgs e)
        {
            ScrollTextWindow(e.MouseWheelDelta);
        }

        private void ScrollTextWindow(int delta)
        {
            if (delta != 0)
            {
                //float canvasheight = TextCanvas.ThreadSafeCanvasSize.Height;
                float canvasheight;
                lock (_savedTextCanvasLock)
                {
                    canvasheight = _savedTextCanvasHeight;
                }
                float bottomScrollLimit = Math.Min(0, canvasheight - TotalTextHeight);
                float scrollAmount = (canvasheight * delta) / (10 * 120);
                lock (_textScrollLock)
                {
                    _textScrollOffset += scrollAmount;
                    if (_textScrollOffset < bottomScrollLimit)
                        _textScrollOffset = bottomScrollLimit;
                    if (_textScrollOffset > 0)
                        _textScrollOffset = 0;

                    _textScrollSpeedOn = false;
                    _textScrollSpeed = 0;
                    _textScrollSpeedRecordOn = false;
                    _textScrollSpeedRecords.Clear();
                    InterlockedTextScrollOffset = _textScrollOffset;
                }
            }
        }

        //private readonly object _moreCmdLock = new object();
        private int _moreCmdPage = 1;
        private float _moreCmdOffsetX = 0.0f;
        private float _moreCmdOffsetY = 0.0f;
        public int MoreCmdPage { get { return Interlocked.CompareExchange(ref _moreCmdPage, 0, 0); } set { Interlocked.Exchange(ref _moreCmdPage, value); } }
        public float MoreCmdOffsetX { get { return Interlocked.CompareExchange(ref _moreCmdOffsetX, 0.0f, 0.0f); } set { Interlocked.Exchange(ref _moreCmdOffsetX, value); } }
        public float MoreCmdOffsetY { get { return Interlocked.CompareExchange(ref _moreCmdOffsetY, 0.0f, 0.0f); } set { Interlocked.Exchange(ref _moreCmdOffsetY, value); } }
        private readonly float _moreCmdOffsetAutoSpeed = 5.0f; /* Screen widths per second */

        public readonly object CommandButtonLock = new object();
        private ConcurrentDictionary<long, TouchEntry> CommandTouchDictionary = new ConcurrentDictionary<long, TouchEntry>();
        private object _savedCommandSender = null;
        private SKTouchEventArgs _savedCommandEventArgs = null;
        private DateTime _savedCommandTimeStamp;
        private bool _commandTouchMoved = false;
        private bool _commandChangedPage = false;

        private readonly object _cmdBtnMatrixRectLock = new object();
        private SKRect _cmdBtnMatrixRect = new SKRect();
        public SKRect CmdBtnMatrixRect { get { SKRect val; lock (_cmdBtnMatrixRectLock) { val = _cmdBtnMatrixRect; } return val; } set { lock (_cmdBtnMatrixRectLock) { _cmdBtnMatrixRect = value; } } }

        //private readonly object _mainFPSCounterLock = new object();
        private long _mainFPSCounterValue = 0;
        private long MainFPSCounterValue { get { return Interlocked.CompareExchange(ref _mainFPSCounterValue, 0L, 0L); } set { Interlocked.Exchange(ref _mainFPSCounterValue, value); } }

        //private readonly object _commandFPSCounterLock = new object();
        private long _commandFPSCounterValue = 0;
        private long CommandFPSCounterValue { get { return Interlocked.CompareExchange(ref _commandFPSCounterValue, 0L, 0L); } set { Interlocked.Exchange(ref _commandFPSCounterValue, value); } }

        public int CurrentMoreButtonPageMaxNumber { get { return UseSimpleCmdLayout ? GHConstants.MoreButtonPages - 1 : GHConstants.MoreButtonPages; } }

        private bool _commandCanvasThreadChecked = false;
        //private double _commandFps = 0.0;

        private readonly object _savedCommandCanvasLock = new object();
        private float _savedCommandCanvasWidth = 0;
        private float _savedCommandCanvasHeight = 0;
        private void CommandCanvas_PaintSurface(object sender, SKPaintSurfaceEventArgs e)
        {
            bool isCommandOnMainThread = MainThread.IsMainThread;
            if (!_commandCanvasThreadChecked && !isCommandOnMainThread)
            {
                _commandCanvasThreadChecked = true;
                GHApp.MaybeWriteGHLog("CommandCanvas_PaintSurface not on main thread!");
            }

            if (!MoreCommandsGrid.ThreadSafeIsVisible || LoadingGrid.ThreadSafeIsVisible)
                return;

            SKImageInfo info = e.Info;
            SKSurface surface = e.Surface;
            SKCanvas canvas = surface.Canvas;
            float canvaswidth = e.Info.Width; // CommandCanvas.CanvasSize.Width;
            float canvasheight = e.Info.Height; // CommandCanvas.CanvasSize.Height;
            float scale = canvaswidth / Math.Max(1f, (float)CommandCanvas.ThreadSafeWidth);
            bool isLandscape = canvaswidth > canvasheight;
            bool lockTaken = false;
            try
            {
                Monitor.TryEnter(_savedCommandCanvasLock, ref lockTaken);
                if (lockTaken)
                {
                    _savedCommandCanvasWidth = canvaswidth;
                    _savedCommandCanvasHeight = canvasheight;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_savedCommandCanvasLock);
            }
            lockTaken = false;

            canvas.Clear(SKColors.Black);
            if (canvaswidth <= 16 || canvasheight <= 16)
                return;

            SKColor nonFilteredColor = SKColors.White.WithAlpha(32);
            CmdBtnMatrixRect = new SKRect();
            string filter = MoreCommandsFilterEntry.Text;
            bool useFilter;

            if (string.IsNullOrWhiteSpace(filter))
                useFilter = false;
            else
                useFilter = true;

            using (GHSkiaFontPaint textPaint = new GHSkiaFontPaint())
            {
                float cmdOffsetX = MoreCmdOffsetX;
                int curpage = MoreCmdPage;
                int pagemin = cmdOffsetX > 0 ? Math.Max(EnableWizardMode ? 0 : 1, curpage - 1) : curpage;
                int pagemax = cmdOffsetX < 0 ? Math.Min(CurrentMoreButtonPageMaxNumber - 1, curpage + 1) : curpage;

                float smalldotheight = Math.Min(canvaswidth, canvasheight) / 120 * scale;
                float largedotheight = smalldotheight * 2;
                float dotmargin = smalldotheight;

                textPaint.Style = SKPaintStyle.Fill;
                for (int i = (EnableWizardMode ? 0 : 1); i < CurrentMoreButtonPageMaxNumber; i++)
                {
                    int numdots = CurrentMoreButtonPageMaxNumber - (EnableWizardMode ? 0 : 1);
                    int dotidx = (EnableWizardMode ? i : i - 1);
                    float dotspacing = dotmargin + largedotheight;
                    float dotoffsetx = ((float)dotidx - ((float)(numdots - 1) / 2)) * dotspacing;
                    SKPoint dotpoint = new SKPoint(canvaswidth / 2 + dotoffsetx, canvasheight - dotmargin - largedotheight / 2);
                    float dotradius = (i == curpage ? largedotheight : smalldotheight) / 2;
                    textPaint.Color = i == curpage ? SKColors.LightGreen : SKColors.White;

                    canvas.DrawCircle(dotpoint, dotradius, textPaint.Paint);
                }
                textPaint.Color = SKColors.White;

                float btnMatrixEnd = canvasheight - dotmargin * 2 - largedotheight;
                float titlesize = Math.Min(48f * scale, 19f * 3.0f * Math.Min(canvaswidth, canvasheight) / 1080f);

                for (int page = pagemin; page <= pagemax; page++)
                {
                    float btnOffsetX = cmdOffsetX + canvaswidth * (page - curpage);

                    textPaint.Color = SKColors.White;
                    textPaint.Typeface = GHApp.ImmortalTypeface;
                    textPaint.TextSize = titlesize;
                    //textPaint.TextAlign = SKTextAlign.Center;

                    string titlestr = GHApp._moreButtonPageTitle[page];
                    float titletopmargin = 5f * scale;
                    float titley = titletopmargin + textPaint.FontSpacing - textPaint.FontMetrics.Descent;
                    textPaint.DrawTextOnCanvas(canvas, titlestr, new SKPoint(canvaswidth / 2 + btnOffsetX, titley), SKTextAlign.Center);

                    float btnMatrixStart = titletopmargin * 2 + textPaint.FontSpacing;

                    float btnMatrixAreaWidth = canvaswidth;
                    float btnMatrixAreaHeight = btnMatrixEnd - btnMatrixStart;

                    if(page == curpage)
                        CmdBtnMatrixRect = new SKRect(0, btnMatrixStart, btnMatrixAreaWidth, btnMatrixEnd);

                    int usedButtonsPerRow = isLandscape ? GHConstants.MoreButtonsPerColumn : GHConstants.MoreButtonsPerRow;
                    int usedButtonsPerColumn = isLandscape ? GHConstants.MoreButtonsPerRow : GHConstants.MoreButtonsPerColumn;
                    float btnAreaWidth = btnMatrixAreaWidth / usedButtonsPerRow;
                    float btnAreaHeight = btnMatrixAreaHeight / usedButtonsPerColumn;

                    float btnImgRawWidth = Math.Min(256, Math.Min(btnAreaWidth * 0.925f, 128 * scale));

                    textPaint.Color = SKColors.White;
                    textPaint.Typeface = GHApp.LatoRegular;
                    textPaint.TextSize = 12.0f * 3.0f * btnImgRawWidth / 256.0f;
                    //textPaint.TextAlign = SKTextAlign.Center;

                    float btnImgRawHeight = Math.Min(256, Math.Min(btnAreaHeight * 0.925f - textPaint.FontSpacing, 128 * scale));

                    float btnImgWidth = Math.Min(btnImgRawWidth, btnImgRawHeight);
                    float btnImgHeight = btnImgWidth;

                    lock (GHApp._moreBtnLock)
                    {
                        using(SKPaint paint = new SKPaint())
                        {
                            for (int i = 0; i < GHConstants.MoreButtonsPerRow; i++)
                            {
                                int pos_j = 0;
                                for (int j = 0; j < GHConstants.MoreButtonsPerColumn; j++)
                                {
                                    if (GHApp._moreBtnMatrix[page, i, j] != null && GHApp._moreBtnBitmaps[page, i, j] != null)
                                    {
                                        bool notInFilter = useFilter && !GHApp._moreBtnMatrix[page, i, j].Text.StartsWith(filter, StringComparison.InvariantCultureIgnoreCase);
                                        SKRect targetrect = new SKRect();
                                        int x = isLandscape ? pos_j : i;
                                        int y = isLandscape ? i : pos_j;
                                        targetrect.Left = btnOffsetX + x * btnAreaWidth + Math.Max(0, (btnAreaWidth - btnImgWidth) / 2);
                                        targetrect.Top = btnMatrixStart + y * btnAreaHeight + Math.Max(0, (btnAreaHeight - btnImgHeight - textPaint.FontSpacing) / 2);
                                        targetrect.Right = targetrect.Left + btnImgWidth;
                                        targetrect.Bottom = targetrect.Top + btnImgHeight;
                                        float text_x = (targetrect.Left + targetrect.Right) / 2;
                                        float text_y = targetrect.Bottom - textPaint.FontMetrics.Ascent;
                                        if (_isCommandHovering && targetrect.Contains(_commandHoverLocation))
                                            paint.ColorFilter = UIUtils.HighlightColorFilter;
                                        else
                                            paint.ColorFilter = null;
                                        if(useFilter)
                                        {
                                            textPaint.Color = paint.Color = notInFilter ? nonFilteredColor : SKColors.White;
                                        }
                                        canvas.DrawImage(GHApp._moreBtnBitmaps[page, i, j], targetrect, paint);
                                        textPaint.DrawTextOnCanvas(canvas, GHApp._moreBtnMatrix[page, i, j].Text, text_x, text_y, SKTextAlign.Center);
                                    }
                                    pos_j++;
                                }
                            }
                        }
                    }
                }

                if (ShowFPS)
                {
                    float textscale = UIUtils.CalculateTextScale();
                    float landscapeMultiplier = UIUtils.CalculateStatusBarFontSizeMultiplier(MainCanvasView.ThreadSafeWidth, MainCanvasView.ThreadSafeHeight);
                    float statusBarTextScale = landscapeMultiplier * textscale;
                    textPaint.TextSize = GHConstants.StatusBarBaseFontSize * statusBarTextScale;
                    float target_scale = textPaint.FontSpacing / GHApp._statusWizardBitmap.Height; // All are 64px high
                    float target_width = target_scale * GHApp._fpsBitmap.Width;
                    float target_height = target_scale * GHApp._fpsBitmap.Height;
                    float curx = canvaswidth - target_width - 24 * target_scale;
                    float cury = 16 * target_scale;
                    SKRect statusDest = new SKRect(curx, cury, curx + target_width, cury + target_height);
                    canvas.DrawImage(GHApp._fpsBitmap, statusDest);

                    string drawtext;
                    //lockTaken = false;
                    ////lock (_fpslock)
                    //try
                    //{
                    //    Monitor.TryEnter(_fpslock, ref lockTaken);
                    //    if (lockTaken)
                    //    {
                    //        _commandFps = _fps;
                    //    }
                    //}
                    //finally
                    //{
                    //    if (lockTaken)
                    //        Monitor.Exit(_fpslock);
                    //}
                    //lockTaken = false;

                    drawtext = string.Format("{0:0.0}", FPS);

                    const int topMargin = 4, bottomMargin = 16;
                    textPaint.Color = SKColors.White;
                    textPaint.TextSize = GHConstants.StatusBarDifFontSize * statusBarTextScale;
                    //textPaint.TextAlign = SKTextAlign.Center;
                    float vsize = target_height - (topMargin + bottomMargin) * target_scale;
                    float fsize = textPaint.FontSpacing;
                    float vpadding = (vsize - fsize) / 2;
                    SKPoint drawpoint = new SKPoint(curx + target_width / 2, cury + (topMargin * target_scale) + vpadding - textPaint.FontMetrics.Ascent);
                    textPaint.DrawTextOnCanvas(canvas, drawtext, drawpoint, SKTextAlign.Center);
                    //textPaint.TextAlign = SKTextAlign.Left;
                    textPaint.TextSize = GHConstants.StatusBarBaseFontSize * statusBarTextScale;
                }
            }
            if (Interlocked.Increment(ref _commandFPSCounterValue) == long.MaxValue)
                Interlocked.Exchange(ref _commandFPSCounterValue, 0L);
            //lock (_commandFPSCounterLock)
            //{
            //    _commandFPSCounterValue++;
            //    if (_commandFPSCounterValue < 0)
            //        _commandFPSCounterValue = 0;
            //}
            canvas.Flush();
        }

        private void CommandCanvas_Touch(object sender, SKTouchEventArgs e)
        {
            SKRect btnRect = CmdBtnMatrixRect;
            float btnMatrixStart = btnRect.Top;
            float btnMatrixEnd = btnRect.Bottom;
            float btnMatrixWidth = btnRect.Width;
            float btnMatrixHeight = btnRect.Height;
            //SKSize canvassize = CommandCanvas.ThreadSafeCanvasSize;
            //float canvaswidth = canvassize.Width;
            //float canvasheight = canvassize.Height;
            float canvaswidth;
            float canvasheight;
            lock (_savedCommandCanvasLock)
            {
                canvaswidth = _savedCommandCanvasWidth;
                canvasheight = _savedCommandCanvasHeight;
            }

            float scale = canvaswidth / Math.Max(1f, (float)CommandCanvas.ThreadSafeWidth);
            bool isLandscape = canvaswidth > canvasheight;

            lock (CommandButtonLock)
            {
                switch (e?.ActionType)
                {
                    case SKTouchAction.Entered:
                        break;
                    case SKTouchAction.Pressed:
                        _savedCommandSender = null;
                        _savedCommandEventArgs = null;
                        _savedCommandTimeStamp = DateTime.Now;

                        if (CommandTouchDictionary.ContainsKey(e.Id))
                            CommandTouchDictionary[e.Id] = new TouchEntry(e.Location, DateTime.Now);
                        else
                            CommandTouchDictionary.TryAdd(e.Id, new TouchEntry(e.Location, DateTime.Now));

                        if (CommandTouchDictionary.Count > 1)
                            _commandTouchMoved = true;
                        else
                        {
                            _savedCommandSender = sender;
                            _savedCommandEventArgs = e;
                            _commandChangedPage = false;
                        }

                        e.Handled = true;
                        break;
                    case SKTouchAction.Moved:
                        {
                            TouchEntry entry;
                            bool res = CommandTouchDictionary.TryGetValue(e.Id, out entry);
                            if (res && !_commandChangedPage)
                            {
                                SKPoint anchor = entry.Location;
                                SKPoint origanchor = entry.OriginalLocation;

                                float diffX = e.Location.X - anchor.X;
                                float diffY = e.Location.Y - anchor.Y;
                                //float dist = (float)Math.Sqrt((Math.Pow(diffX, 2) + Math.Pow(diffY, 2)));
                                float xdist = (float)Math.Abs(diffX);
                                long elapsedms = (DateTime.Now.Ticks - entry.PressTime.Ticks) / TimeSpan.TicksPerMillisecond;
                                int cmdPage = MoreCmdPage;
                                float cmdOffset = MoreCmdOffsetX;

                                if (CommandTouchDictionary.Count == 1)
                                {
                                    if (xdist > 25 || elapsedms > GHConstants.MoveOrPressTimeThreshold)
                                    {
                                        /* Just one finger */
                                        if (diffX != 0 || diffY != 0)
                                        {
                                            int minpage = EnableWizardMode ? 0 : 1;
                                            int maxpage = CurrentMoreButtonPageMaxNumber - 1;
                                            cmdOffset += diffX;
                                            if(cmdPage == minpage && cmdOffset > 0)
                                                MoreCmdOffsetX = cmdOffset = 0;
                                            else if (cmdPage == maxpage && cmdOffset < 0)
                                                MoreCmdOffsetX = cmdOffset = 0;
                                            else
                                                MoreCmdOffsetX = cmdOffset;


                                            CommandTouchDictionary[e.Id].Location = e.Location;
                                            _commandTouchMoved = true;
                                            _savedCommandTimeStamp = DateTime.Now;
                                        }
                                    }
                                }
                            }
                            e.Handled = true;
                        }
                        break;
                    case SKTouchAction.Released:
                        {
                            _savedCommandSender = null;
                            _savedCommandEventArgs = null;
                            _savedCommandTimeStamp = DateTime.Now;
                            _commandChangedPage = false;

                            TouchEntry entry;
                            bool res = CommandTouchDictionary.TryGetValue(e.Id, out entry);
                            if (res)
                            {
                                long elapsedms = (DateTime.Now.Ticks - entry.PressTime.Ticks) / TimeSpan.TicksPerMillisecond;
                                float swipelengththreshold = 30;

                                SKPoint origanchor = entry.OriginalLocation;

                                float origdiffX = e.Location.X - origanchor.X;
                                float origdiffY = e.Location.Y - origanchor.Y;
                                int cmdPage = MoreCmdPage;
                                float cmdOffset = MoreCmdOffsetX;

                                if (elapsedms <= GHConstants.MoveOrPressTimeThreshold && !_commandTouchMoved)
                                {
                                    /* Normal click */
                                    /* Select command here*/
                                    int used_btnHeight = GHConstants.MoreButtonsPerColumn;
                                    int usedButtonsPerRow = isLandscape ? used_btnHeight : GHConstants.MoreButtonsPerRow;
                                    int usedButtonsPerColumn = isLandscape ? GHConstants.MoreButtonsPerRow : used_btnHeight;
                                    float btnAreaWidth = btnMatrixWidth / usedButtonsPerRow;
                                    float btnAreaHeight = btnMatrixHeight / usedButtonsPerColumn;
                                    int btnX = (int)((e.Location.X - MoreCmdOffsetX) / btnAreaWidth);
                                    int btnY = (int)((e.Location.Y - btnMatrixStart) / btnAreaHeight);

                                    if (e.Location.Y >= btnMatrixStart && e.Location.Y <= btnMatrixEnd
                                        && e.Location.X - MoreCmdOffsetX >= 0 && e.Location.X - MoreCmdOffsetX <= canvaswidth
                                        && btnX >= 0 && btnX < usedButtonsPerRow && btnY >= 0 && btnY < usedButtonsPerColumn)
                                    {
                                        int i, j;
                                        if (isLandscape)
                                        {
                                            i = btnY;
                                            j = btnX;
                                        }
                                        else
                                        {
                                            i = btnX;
                                            j = btnY;
                                        }

                                        GHCommandButtonItem cbi = null;
                                        int cbi_cmd = 0;
                                        int page = MoreCmdPage;
                                        cbi = GHApp._moreBtnMatrix[page, i, j];
                                        if (cbi != null)
                                            cbi_cmd = cbi.Command;
                                        if (cbi != null)
                                        {
                                            if (cbi_cmd >= 0)
                                                GenericButton_Clicked(CommandCanvas, e, cbi_cmd);
                                            else
                                            {
                                                switch (cbi_cmd)
                                                {
                                                    case -102:
                                                        GenericButton_Clicked(sender, e, 'n');
                                                        GenericButton_Clicked(sender, e, -12);
                                                        GenericButton_Clicked(sender, e, -10);
                                                        GenericButton_Clicked(sender, e, 's');
                                                        break;
                                                    case -103:
                                                        GenericButton_Clicked(sender, e, 'n');
                                                        GenericButton_Clicked(sender, e, -12);
                                                        GenericButton_Clicked(sender, e, -10);
                                                        GenericButton_Clicked(sender, e, -10);
                                                        GenericButton_Clicked(sender, e, '.');
                                                        break;
                                                    case -104:
                                                        OpenGameMenu();
                                                        break;
                                                    case -105:
                                                        GenericButton_Clicked(sender, e, 'n');
                                                        DoShowNumberPad();
                                                        break;
                                                    default:
                                                        break;
                                                }
                                            }

                                            /* Hide the canvas */
                                            CommandCanvas_Pressed(sender, e);
                                        }

                                    }
                                }
                                else if (elapsedms <= GHConstants.SwipeTimeThreshold && Math.Abs(origdiffX) > swipelengththreshold)
                                {
                                    /* It is a swipe */
                                    if (origdiffX > swipelengththreshold)
                                    {
                                        if (cmdPage > (EnableWizardMode ? 0 : 1))
                                        {
                                            MoreCmdPage = cmdPage - 1;
                                            MoreCmdOffsetX = cmdOffset - btnMatrixWidth;
                                            UpdateMoreNextPrevButtonVisibility(true, true);
                                        }

                                        _commandChangedPage = true;
                                    }
                                    else if (origdiffX < -swipelengththreshold)
                                    {
                                        if (cmdPage < CurrentMoreButtonPageMaxNumber - 1)
                                        {
                                            MoreCmdPage = cmdPage + 1;
                                            MoreCmdOffsetX = cmdOffset + btnMatrixWidth;
                                            UpdateMoreNextPrevButtonVisibility(true, true);
                                        }

                                        _commandChangedPage = true;
                                    }
                                }
                                else
                                {
                                    if (cmdOffset > btnMatrixWidth / 2)
                                    {
                                        if (cmdPage > (EnableWizardMode ? 0 : 1))
                                        {
                                            MoreCmdPage = cmdPage - 1;
                                            MoreCmdOffsetX = cmdOffset - btnMatrixWidth;
                                            UpdateMoreNextPrevButtonVisibility(true, true);
                                        }

                                        _commandChangedPage = true;
                                    }
                                    else if (cmdOffset < -btnMatrixWidth / 2)
                                    {
                                        if (cmdPage < CurrentMoreButtonPageMaxNumber - 1)
                                        {
                                            MoreCmdPage = cmdPage + 1;
                                            MoreCmdOffsetX = cmdOffset + btnMatrixWidth;
                                            UpdateMoreNextPrevButtonVisibility(true, true);
                                        }

                                        _commandChangedPage = true;
                                    }
                                }

                                if (CommandTouchDictionary.ContainsKey(e.Id))
                                {
                                    TouchEntry removedEntry;
                                    CommandTouchDictionary.TryRemove(e.Id, out removedEntry);
                                }
                                else
                                    CommandTouchDictionary.Clear(); /* Something's wrong; reset the touch dictionary */

                                if (CommandTouchDictionary.Count == 0)
                                    _commandTouchMoved = false;
                            }
                            e.Handled = true;
                        }
                        break;
                    case SKTouchAction.Cancelled:
                        if (CommandTouchDictionary.ContainsKey(e.Id))
                        {
                            TouchEntry removedEntry;
                            CommandTouchDictionary.TryRemove(e.Id, out removedEntry);
                        }
                        else
                            CommandTouchDictionary.Clear(); /* Something's wrong; reset the touch dictionary */
                        e.Handled = true;
                        break;
                    case SKTouchAction.Exited:
                        break;
                    case SKTouchAction.WheelChanged:
                        break;
                    default:
                        break;
                }
            }
        }

        private void CommandCanvas_Pressed(object sender, EventArgs e)
        {
            MoreCommandsGrid.IsVisible = false;
            MoreCommandsFilterEntry.Unfocus();
            MoreCommandsFilterEntry.IsVisible = false;
            MoreCommandsFilterEntry.IsEnabled = false;
            //MainGrid.IsVisible = true;
            IsMainCanvasOn = true;
            UpdateMoreNextPrevButtonVisibility(true, true);
            StopCommandCanvasAnimation();
            RefreshScreen = true;
            StartMainCanvasAnimation();
        }

        private void CommandCanvas_MouseWheel(object sender, GHMouseWheelEventArgs e)
        {
            if (e.MouseWheelDelta > 0)
            {
                MorePreviousButton_BtnClicked(sender, EventArgs.Empty);
            }
            else if (e.MouseWheelDelta < 0)
            {
                MoreNextButton_BtnClicked(sender, EventArgs.Empty);
            }
        }

        private readonly object _commandHighlightLock = new object();
        private bool _isCommandHovering = false;
        private SKPoint _commandHoverLocation = new SKPoint();

        private void CommandCanvas_MousePointer(object sender, SKTouchEventArgs e)
        {
            lock(_commandHighlightLock)
            {
                _commandHoverLocation = e.Location;
                switch (e.ActionType)
                {
                    case SKTouchAction.Entered:
                    case SKTouchAction.Moved:
                        _isCommandHovering = true;
                        break;
                    case SKTouchAction.Exited:
                    case SKTouchAction.Cancelled:
                        _isCommandHovering = false;
                        break;
                }
            }
        }

        private void ToggleMessageNumberButton_Clicked(object sender, EventArgs e)
        {
            lock(_messageScrollLock)
            {
                _messageScrollOffset = 0.0f;
                _messageScrollSpeed = 0;
                _messageScrollSpeedOn = false;
                _messageScrollSpeedRecords.Clear();
                InterlockedMessageScrollOffset = _messageScrollOffset;
            }
            MainThread.BeginInvokeOnMainThread(() =>
            {
                if (MessageFilterFrame.IsVisible && MessageFilterEntry.IsVisible)
                {
                    MessageFilterEntry.Unfocus();
                    ESCButton.Focus();
                    //if (UpperCmdGrid.IsVisible)
                    //    ESCButton.Focus();
                    //else
                    //    SimpleESCButton.Focus();
                }
            });
            bool prevForceAllMessages = ForceAllMessages;
            ForceAllMessages = !prevForceAllMessages;
        }

        //private readonly object _tipLock = new object();
        private int _shownTip = -1;
        public int ShownTip { get { return Interlocked.CompareExchange(ref _shownTip, 0, 0); } set { Interlocked.Exchange(ref _shownTip, value); } } // { get { int val; lock (_tipLock) { val = _shownTip; } return val; } set { lock (_tipLock) { _shownTip = value; } } }
        private bool _blockingTipView = true;
        private SKRect _tipPaintLocalHealthRect;
        private SKRect _tipPaintLocalManaRect;

        private void TipView_PaintSurface(object sender, SKPaintSurfaceEventArgs e)
        {
            SKImageInfo info = e.Info;
            SKSurface surface = e.Surface;
            SKCanvas canvas = surface.Canvas;

            canvas.Clear(SKColors.Transparent);

            using (GHSkiaFontPaint textPaint = new GHSkiaFontPaint())
            {
                float canvaswidth = e.Info.Width; // MainCanvasView.CanvasSize.Width;
                float canvasheight = e.Info.Height; // MainCanvasView.CanvasSize.Height;
                bool landscape = (canvaswidth > canvasheight);
                float maincanvaswidth = 0;
                float maincanvasheight = 0;
                lock (_savedCanvasLock)
                {
                    maincanvaswidth = _savedCanvasWidth;
                    maincanvasheight = _savedCanvasHeight;
                }

                bool lockTaken = false;
                try
                {
                    Monitor.TryEnter(_uiRectLock, ref lockTaken);
                    if (lockTaken)
                    {
                        _tipPaintLocalHealthRect = _uiHealthRect;
                        _tipPaintLocalManaRect = _uiManaRect;
                    }
                }
                finally
                {
                    if (lockTaken)
                        Monitor.Exit(_uiRectLock);
                }
                lockTaken = false;

                float xscale = maincanvaswidth <= 0 || canvaswidth <= 0 ? 1.0f : canvaswidth / maincanvaswidth;
                float yscale = maincanvasheight <= 0 || canvasheight <= 0 ? 1.0f : canvasheight / maincanvasheight;

                float tx = 0, ty = 0;
                SKRect bounds = new SKRect();
                textPaint.Color = SKColors.White;

                string str = "TestText";
                textPaint.Typeface = GHApp.LatoRegular;
                textPaint.TextSize = 36;
                textPaint.MeasureText(str, ref bounds);
                float fontsize = Math.Min(48, 36 * 0.18f / Math.Max(0.01f, (bounds.Width / Math.Max(1f, Math.Min(canvaswidth, canvasheight)))));

                str = "This is an explanation.";
                textPaint.Typeface = GHApp.UnderwoodTypeface;
                textPaint.TextSize = 36;
                textPaint.MeasureText(str, ref bounds);
                float centerfontsize = Math.Min(72, 36 * 0.62f / Math.Max(0.01f, (bounds.Width / Math.Max(1f, Math.Min(canvaswidth, canvasheight)))));

                float scale_canvas = 1.0f;
                float target_scale_canvas = 1.0f;
                float mult_canvas = 1.0f;
                float prev_bottom = 0;
                float sbheight = yscale * UIUtils.CalculateStatusBarSkiaHeight(MainCanvasView.ThreadSafeWidth, MainCanvasView.ThreadSafeHeight); // GetStatusBarSkiaHeightEx(MainCanvasView.Width, MainCanvasView.Height, DesktopButtons, UseSimpleCmdLayout);
                SKRect statusBarCenterRect = new SKRect(canvaswidth / 2 - sbheight / 2, 0, canvaswidth / 2 + sbheight / 2, sbheight);

                switch (ShownTip)
                {
                    case 0:
                        textPaint.TextSize = 36;
                        textPaint.Typeface = GHApp.ARChristyTypeface;
                        str = "Welcome to GnollHack";
                        textPaint.MeasureText(str, ref bounds);
                        scale_canvas = bounds.Width / Math.Max(1f, Math.Min(canvaswidth, canvasheight)); //Math.Max(bounds.Width / canvaswidth, bounds.Height / canvasheight);
                        target_scale_canvas = 0.8f;
                        mult_canvas = target_scale_canvas / scale_canvas;
                        textPaint.TextSize = textPaint.TextSize * mult_canvas;
                        textPaint.MeasureText(str, ref bounds);
                        tx = canvaswidth / 2 - bounds.Width / 2;
                        ty = canvasheight / 2 - bounds.Height / 2;
                        textPaint.Style = SKPaintStyle.Fill;
                        textPaint.Color = SKColors.Black;
                        textPaint.MaskFilter = _blur;
                        textPaint.DrawTextOnCanvas(canvas, str, tx + textPaint.TextSize / 15, ty + textPaint.TextSize / 15);
                        textPaint.Style = SKPaintStyle.Fill;
                        textPaint.Color = SKColors.Gold;
                        textPaint.MaskFilter = null;
                        textPaint.DrawTextOnCanvas(canvas, str, tx, ty);

                        prev_bottom = ty + textPaint.FontMetrics.Descent;

                        textPaint.TextSize = 36;
                        textPaint.Typeface = GHApp.UnderwoodTypeface;
                        str = "Let's review the user interface";
                        textPaint.MeasureText(str, ref bounds);
                        scale_canvas = bounds.Width / Math.Max(1f, Math.Min(canvaswidth, canvasheight)); //Math.Max(bounds.Width / canvaswidth, bounds.Height / canvasheight);
                        target_scale_canvas = 0.8f;
                        mult_canvas = target_scale_canvas / scale_canvas;
                        textPaint.TextSize = textPaint.TextSize * mult_canvas;
                        textPaint.MeasureText(str, ref bounds);
                        tx = canvaswidth / 2 - bounds.Width / 2;
                        ty = prev_bottom - textPaint.FontMetrics.Ascent * 1.2f;
                        textPaint.Style = SKPaintStyle.Fill;
                        textPaint.Color = SKColors.Black;
                        textPaint.MaskFilter = _blur;
                        textPaint.DrawTextOnCanvas(canvas, str, tx + textPaint.TextSize / 15, ty + textPaint.TextSize / 15);
                        textPaint.Style = SKPaintStyle.Fill;
                        textPaint.Color = SKColors.White;
                        textPaint.MaskFilter = null;
                        textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
                        break;
                    case 1:
                        PaintTipButton(canvas, textPaint, GameMenuButton, "This opens the main menu.", "Main Menu", 1.5f, centerfontsize, fontsize, false, -0.15f, 0, canvaswidth, canvasheight);
                        break;
                    case 2:
                        PaintTipButton(canvas, textPaint, ESCButton, "This cancels any command.", "Escape Button", 1.5f, centerfontsize, fontsize, false, -1.5f, 0, canvaswidth, canvasheight);
                        break;
                    case 3:
                        PaintTipButton(canvas, textPaint, ToggleAutoCenterModeButton, "This toggles auto-center on player.", "Map Auto-Center", 1.5f, centerfontsize, fontsize, false, -1.5f, 0, canvaswidth, canvasheight);
                        break;
                    case 4:
                        PaintTipButton(canvas, textPaint, ToggleZoomMiniButton, "This zoom shows the entire level.", "Minimap", 1.5f, centerfontsize, fontsize, false, landscape ? -0.15f : -0.5f, landscape ? 0 : 1.5f, canvaswidth, canvasheight);
                        break;
                    case 5:
                        PaintTipButton(canvas, textPaint, ToggleZoomAlternateButton, "This is the secondary zoom.", "Alternative Zoom", 1.5f, centerfontsize, fontsize, false, landscape ? -1.5f : -0.15f, 0, canvaswidth, canvasheight);
                        break;
                    case 6:
                        PaintTipButton(canvas, textPaint, LookModeButton, "This allows you to inspect the map.", "Look Mode", 1.5f, centerfontsize, fontsize, false, -0.15f, landscape ? -0.5f : 0, canvaswidth, canvasheight);
                        break;
                    case 7:
                        PaintTipButton(canvas, textPaint, ToggleTravelModeButton, "Use this to set how you move around.", "Travel Mode", 1.5f, centerfontsize, fontsize, false, landscape ? -1.5f : -0.15f, landscape ? -0.5f : 0, canvaswidth, canvasheight);
                        break;
                    case 8:
                        PaintTipButton(canvas, textPaint, ToggleIgnoreModeButton, "This toggles stopping at items.", "Ignore Stopping", 1.5f, centerfontsize, fontsize, false, landscape ? -1.5f : -0.15f, landscape ? -0.5f : 0, canvaswidth, canvasheight);
                        break;
                    case 9:
                        PaintTipButton(canvas, textPaint, ToggleAutoDigButton, "This toggles auto-dig on and off.", "Auto-Dig", 1.5f, centerfontsize, fontsize, false, landscape ? -1.5f : -0.15f, landscape ? -0.5f : 0, canvaswidth, canvasheight);
                        break;
                    case 10:
                        PaintTipButtonByRect(canvas, textPaint, statusBarCenterRect, "You can " + GHApp.GetClickTapWord(false, false) + " the status bar.", "Open status screen", 1.0f, centerfontsize, fontsize, false, -0.15f, 1.0f, canvaswidth, canvasheight, 1.0f, 1.0f);
                        break;
                    case 11:
                        PaintTipButton(canvas, textPaint, DesktopButtons ? lRowAbilitiesButton : lAbilitiesButton, DesktopButtons ? "Some commands are specially located." : "Some commands do not have buttons.", "Character and game status", 1.0f, centerfontsize, fontsize, true, 0.15f, DesktopButtons ? -1.0f : 1.0f, canvaswidth, canvasheight);
                        break;
                    case 12:
                        PaintTipButton(canvas, textPaint, DesktopButtons ? lRowWornItemsButton : lWornItemsButton, "", GHApp.GetClickTapWord(true, false) + " here to access worn items", 1.0f, centerfontsize, fontsize, false, landscape ? -2.0f : -0.5f, DesktopButtons ? -2.0f : 2.0f, canvaswidth, canvasheight);
                        break;
                    case 13:
                        PaintTipButton(canvas, textPaint, ToggleMessageNumberButton, "", GHApp.GetClickTapWord(true, false) + " here to see more messages", 1.0f, centerfontsize, fontsize, true, 0.5f, -1.0f, canvaswidth, canvasheight);
                        break;
                    case 14:
                        PaintTipButtonByRect(canvas, textPaint, _tipPaintLocalHealthRect, GHApp.GetClickTapWord(true, true) + " shows your maximum health.", "Health Orb", 1.1f, centerfontsize, fontsize, true, 0.15f, 0.0f, canvaswidth, canvasheight, xscale, yscale);
                        break;
                    case 15:
                        PaintTipButtonByRect(canvas, textPaint, _tipPaintLocalManaRect, GHApp.GetClickTapWord(true, true) + " reveals your maximum mana.", "Mana Orb", 1.1f, centerfontsize, fontsize, true, 0.15f, 0.0f, canvaswidth, canvasheight, xscale, yscale);
                        break;
                    case 16:
                        textPaint.TextSize = 36;
                        textPaint.Typeface = GHApp.ARChristyTypeface;
                        str = "You are all set";
                        textPaint.MeasureText(str, ref bounds);
                        scale_canvas = bounds.Width / Math.Max(1f, Math.Min(canvaswidth, canvasheight)); //Math.Max(bounds.Width / canvaswidth, bounds.Height / canvasheight);
                        target_scale_canvas = 0.8f;
                        mult_canvas = target_scale_canvas / scale_canvas;
                        textPaint.TextSize = textPaint.TextSize * mult_canvas;
                        textPaint.MeasureText(str, ref bounds);
                        tx = canvaswidth / 2 - bounds.Width / 2;
                        ty = canvasheight / 2 - bounds.Height / 2;
                        textPaint.Style = SKPaintStyle.Fill;
                        textPaint.Color = SKColors.Black;
                        textPaint.MaskFilter = _blur;
                        textPaint.DrawTextOnCanvas(canvas, str, tx + textPaint.TextSize / 15, ty + textPaint.TextSize / 15);
                        textPaint.Style = SKPaintStyle.Fill;
                        textPaint.Color = SKColors.Gold;
                        textPaint.MaskFilter = null;
                        textPaint.DrawTextOnCanvas(canvas, str, tx, ty);

                        prev_bottom = ty + textPaint.FontMetrics.Descent;

                        textPaint.TextSize = 36;
                        textPaint.Typeface = GHApp.UnderwoodTypeface;
                        str = GHApp.GetClickTapWord(true, false) + " to start playing";
                        textPaint.MeasureText(str, ref bounds);
                        scale_canvas = bounds.Width / Math.Max(1f, Math.Min(canvaswidth, canvasheight)); //Math.Max(bounds.Width / canvaswidth, bounds.Height / canvasheight);
                        target_scale_canvas = 0.8f;
                        mult_canvas = target_scale_canvas / scale_canvas;
                        textPaint.TextSize = textPaint.TextSize * mult_canvas;
                        textPaint.MeasureText(str, ref bounds);
                        tx = canvaswidth / 2 - bounds.Width / 2;
                        ty = prev_bottom - textPaint.FontMetrics.Ascent * 1.2f;
                        textPaint.Style = SKPaintStyle.Fill;
                        textPaint.Color = SKColors.Black;
                        textPaint.MaskFilter = _blur;
                        textPaint.DrawTextOnCanvas(canvas, str, tx + textPaint.TextSize / 15, ty + textPaint.TextSize / 15);
                        textPaint.Style = SKPaintStyle.Fill;
                        textPaint.Color = SKColors.White;
                        textPaint.MaskFilter = null;
                        textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
                        break;
                    default:
                        textPaint.DrawTextOnCanvas(canvas, str, tx, ty);
                        break;
                }
            }
            canvas.Flush();
        }

        private SKRect _tipTouchLocalHealthRect;
        private SKRect _tipTouchLocalManaRect;

        private void TipView_Touch(object sender, SKTouchEventArgs e)
        {
            bool lockTaken = false;
            try
            {
                Monitor.TryEnter(_uiRectLock, ref lockTaken);
                if (lockTaken)
                {
                    _tipTouchLocalHealthRect = _uiHealthRect;
                    _tipTouchLocalManaRect = _uiManaRect;
                }
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(_uiRectLock);
            }
            lockTaken = false;

            switch (e?.ActionType)
            {
                case SKTouchAction.Entered:
                    e.Handled = true;
                    break;
                case SKTouchAction.Pressed:
                    e.Handled = true;
                    break;
                case SKTouchAction.Moved:
                    e.Handled = true;
                    break;
                case SKTouchAction.Released:
                    ShownTip++;
                    if (ShownTip == 5 && !ShowAltZoomButton)
                        ShownTip++;
                    if (ShownTip == 7 && !ShowTravelModeButton)
                        ShownTip++;
                    if (ShownTip == 8 && !ShowIgnoreStoppingButton)
                        ShownTip++;
                    if (ShownTip == 9 && !ShowAutoDigButton)
                        ShownTip++;
                    if (ShownTip == 14 && _tipTouchLocalHealthRect.Width == 0)
                        ShownTip++;
                    if (ShownTip == 15 && _tipTouchLocalManaRect.Width == 0)
                        ShownTip++;
                    TipView.InvalidateSurface();
                    if (ShownTip >= 17 - (_blockingTipView ? 0 : 1))
                    {
                        TipView.IsVisible = false;
                        ShownTip = -1;
                        try
                        {
                            Preferences.Set("GUITipsShown", true);
                        }
                        catch (Exception ex)
                        {
                            Debug.WriteLine(ex);
                        }
                        if (_blockingTipView)
                        {
                            GHGame curGame = GHApp.CurrentGHGame;
                            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.ShowGUITips));
                        }
                    }
                    e.Handled = true;
                    break;
                case SKTouchAction.Cancelled:
                    e.Handled = true;
                    break;
                case SKTouchAction.Exited:
                    e.Handled = true;
                    break;
                case SKTouchAction.WheelChanged:
                    e.Handled = true;
                    break;
                default:
                    break;
            }
        }

#if GNH_MAUI
        public SKRect GetViewScreenRect(Microsoft.Maui.Controls.VisualElement view)
#else
        public SKRect GetViewScreenRect(Xamarin.Forms.VisualElement view)
#endif
        {
            //float canvaswidth = MainCanvasView.CanvasSize.Width;
            //float canvasheight = MainCanvasView.CanvasSize.Height;
            float scale = GHApp.DisplayDensity;

            double screenCoordinateX = view.X;
            double screenCoordinateY = view.Y;
            // Get the view's parent (if it has one...)
            if (view.Parent.GetType() != typeof(App))
            {
#if GNH_MAUI
                Microsoft.Maui.Controls.VisualElement parent = (Microsoft.Maui.Controls.VisualElement)view.Parent;
#else
                Xamarin.Forms.VisualElement parent = (Xamarin.Forms.VisualElement)view.Parent;
#endif
                // Loop through all parents
                while (parent != null)
                {
                    screenCoordinateX += parent.X;
                    screenCoordinateY += parent.Y;

                    // If the parent of this parent isn't the app itself, get the parent's parent.
#if GNH_MAUI
                    if (parent.Parent == null || parent.Parent.GetType() == typeof(Microsoft.Maui.Controls.Window))
                        parent = null;
                    else
                        parent = (Microsoft.Maui.Controls.VisualElement)parent.Parent;
#else
                    if (parent.Parent.GetType() == typeof(App))
                        parent = null;
                    else
                        parent = (Xamarin.Forms.VisualElement)parent.Parent;
#endif
                }
            }
            float relX = (float)(screenCoordinateX * scale); // / MainCanvasView.Width) * canvaswidth;
            float relY = (float)(screenCoordinateY * scale); // / MainCanvasView.Height) * canvasheight;
            float relWidth = (float)(StandardMeasurementButton.ThreadSafeWidth * scale); // / MainCanvasView.Width) * canvaswidth;
            float relHeight = (float)(StandardMeasurementButton.ThreadSafeHeight * scale); // / MainCanvasView.Height) * canvasheight;

            SKRect res = new SKRect(relX, relY, relX + relWidth, relY + relHeight);
            return res;
        }

        public SKRect GetThreadSafeViewScreenRect(IThreadSafeView view)
        {
            //float canvaswidth = MainCanvasView.CanvasSize.Width;
            //float canvasheight = MainCanvasView.CanvasSize.Height;
            float scale = GHApp.DisplayDensity;

            double screenCoordinateX = view.ThreadSafeX;
            double screenCoordinateY = view.ThreadSafeY;
            // Get the view's parent (if it has one...)
            if(view.ThreadSafeParent != null && view.ThreadSafeParent.TryGetTarget(out IThreadSafeView parent))
            {
                if (!(parent is App))
                {
                    // Loop through all parents
                    while (parent != null)
                    {
                        screenCoordinateX += parent.ThreadSafeX;
                        screenCoordinateY += parent.ThreadSafeY;

                        // If the parent of this parent isn't the app itself, get the parent's parent.
                        if (parent.ThreadSafeParent == null || !parent.ThreadSafeParent.TryGetTarget(out parent))
                            parent = null;
                        else if (parent is App)
                            parent = null;
#if GNH_MAUI
                        else if (parent is Microsoft.Maui.Controls.Window)
                            parent = null;
#endif
                    }
                }
            }

            float relX = (float)(screenCoordinateX * scale); // / MainCanvasView.Width) * canvaswidth;
            float relY = (float)(screenCoordinateY * scale); // / MainCanvasView.Height) * canvasheight;
            float relWidth = (float)(StandardMeasurementButton.ThreadSafeWidth * scale); // / MainCanvasView.Width) * canvaswidth;
            float relHeight = (float)(StandardMeasurementButton.ThreadSafeHeight * scale); // / MainCanvasView.Height) * canvasheight;

            SKRect res = new SKRect(relX, relY, relX + relWidth, relY + relHeight);
            return res;
        }

        public void PaintTipButton(SKCanvas canvas, GHSkiaFontPaint textPaint, IThreadSafeView view,
//#if GNH_MAUI
//            Microsoft.Maui.Controls.VisualElement view,
//#else
//            Xamarin.Forms.VisualElement view, 
//#endif
            string centertext, string boxtext, float radius_mult, float centertextfontsize, float boxfontsize, bool linefromright, float lineoffsetx, float lineoffsety, float canvaswidth, float canvasheight)
        {
            SKRect viewrect = GetThreadSafeViewScreenRect(view);
            SKRect tiprect = GetThreadSafeViewScreenRect(TipView);
            SKRect adjustedrect = new SKRect(viewrect.Left - tiprect.Left, viewrect.Top - tiprect.Top, viewrect.Right - tiprect.Left, viewrect.Bottom - tiprect.Top);
            PaintTipButtonByRect(canvas, textPaint, adjustedrect, centertext, boxtext, radius_mult, centertextfontsize, boxfontsize, linefromright, lineoffsetx, lineoffsety, canvaswidth, canvasheight, 1.0f, 1.0f);
        }

        public void PaintTipButtonByRect(SKCanvas canvas, GHSkiaFontPaint textPaint, SKRect viewrect, string centertext, string boxtext, float radius_mult, float centertextfontsize, float boxfontsize, bool linefromright, float lineoffsetx, float lineoffsety, float canvaswidth, float canvasheight, float xscale, float yscale)
        {
            float tx = 0, ty = 0;
            SKRect bounds = new SKRect();
            float padding = 0.0f;
            float relX = 0;
            float relY = 0;
            float relWidth = 0;
            float relHeight = 0;
            SKRect rect = new SKRect();
            string str;
            float usedoffsetx = 0;
            float usedoffsety = 0;
            float usedboxwidth = 0;
            float usedboxheight = 0;
            float usedboxpadding = 0;
            float usedlinestartoffset = 0;

            textPaint.TextSize = centertextfontsize;
            textPaint.Typeface = GHApp.UnderwoodTypeface;
            str = centertext;
            textPaint.MeasureText(str, ref bounds);
            tx = canvaswidth / 2 - bounds.Width / 2;
            ty = canvasheight / 2 - bounds.Height / 2;
            textPaint.Style = SKPaintStyle.Fill;
            textPaint.Color = SKColors.Black;
            textPaint.MaskFilter = _blur;
            textPaint.DrawTextOnCanvas(canvas, str, tx + textPaint.TextSize / 15, ty + textPaint.TextSize / 15);
            textPaint.Style = SKPaintStyle.Fill;
            textPaint.Color = SKColors.White;
            textPaint.MaskFilter = null;
            textPaint.DrawTextOnCanvas(canvas, str, tx, ty);

            relX = viewrect.Left * xscale;
            relY = viewrect.Top * yscale;
            relWidth = viewrect.Width * xscale;
            relHeight = viewrect.Height * yscale;

            textPaint.Typeface = GHApp.LatoRegular;
            textPaint.TextSize = boxfontsize;
            str = boxtext;
            textPaint.MeasureText(str, ref bounds);

            usedoffsetx = relWidth * lineoffsetx;
            usedoffsety = relHeight * lineoffsety;
            usedboxpadding = bounds.Height * 0.75f;
            usedboxwidth = bounds.Width + usedboxpadding * 2;
            usedboxheight = bounds.Height + usedboxpadding * 2;
            usedlinestartoffset = linefromright  ? relWidth / 2 * radius_mult  : - relWidth / 2 * radius_mult;

            tx = relX + relWidth / 2;
            ty = relY + relHeight / 2;
            textPaint.Color = SKColors.Red;
            textPaint.Style = SKPaintStyle.Stroke;
            textPaint.StrokeWidth = relWidth / 15;
            canvas.DrawCircle(tx, ty, relWidth / 2 * radius_mult, textPaint.Paint);
            textPaint.StrokeWidth = relWidth / 15;
            canvas.DrawLine(tx + usedlinestartoffset + usedoffsetx, ty + usedoffsety, tx + usedlinestartoffset, ty, textPaint.Paint);
            textPaint.Color = SKColors.DarkRed;
            textPaint.Style = SKPaintStyle.Fill;
            rect = new SKRect(tx + usedoffsetx + usedlinestartoffset - (linefromright ? 0 : usedboxwidth),
                ty + usedoffsety - usedboxheight / 2,
                tx + usedoffsetx + usedlinestartoffset + (linefromright ? usedboxwidth : 0),
                ty + usedoffsety + usedboxheight / 2);
            canvas.DrawRect(rect, textPaint.Paint);
            textPaint.Color = SKColors.Red;
            textPaint.Style = SKPaintStyle.Stroke;
            textPaint.StrokeWidth = relWidth / 25;
            canvas.DrawRect(rect, textPaint.Paint);

            padding = (rect.Width - bounds.Width) / 2;
            textPaint.Color = SKColors.White;
            textPaint.Style = SKPaintStyle.Fill;
            textPaint.DrawTextOnCanvas(canvas, str, rect.Left + padding, ty + usedoffsety + (textPaint.FontMetrics.Ascent - textPaint.FontMetrics.Descent) / 2 - textPaint.FontMetrics.Ascent);
        }

        private void DrawOrb(SKCanvas canvas, GHSkiaFontPaint textPaint, SKRect orbBorderDest, SKColor fillcolor, string val, string maxval, float orbfillpercentage, bool showmax, bool isHighlighted)
        {
            float orbwidth = orbBorderDest.Width / 230.0f * 210.0f;
            float orbheight = orbBorderDest.Width / 230.0f * 210.0f;
            SKRect orbDest = new SKRect(orbBorderDest.Left + (orbBorderDest.Width - orbwidth) / 2,
                orbBorderDest.Top + (orbBorderDest.Height - orbheight) / 2,
                orbBorderDest.Left + (orbBorderDest.Width - orbwidth) / 2 + orbwidth,
                orbBorderDest.Top + (orbBorderDest.Height - orbheight) / 2 + orbheight);
            textPaint.Color = SKColors.White;
            //textPaint.TextAlign = SKTextAlign.Center;
#if GNH_MAP_PROFILING && DEBUG
            StartProfiling(GHProfilingStyle.Bitmap);
#endif
            using(SKPaint paint = new SKPaint())
            {
#if !GNH_MAUI
                paint.FilterQuality = SKFilterQuality.High;
#endif
                if (isHighlighted)
                    paint.ColorFilter = UIUtils.HighlightColorFilter;
                canvas.DrawImage(GHApp._orbBorderBitmap, orbBorderDest, paint);
                if (orbfillpercentage < 0)
                    orbfillpercentage = 0;
                if (orbfillpercentage > 1)
                    orbfillpercentage = 1;
                SKImage fillBitmap = fillcolor == SKColors.Red ? GHApp._orbFillBitmapRed : fillcolor == SKColors.Blue ? GHApp._orbFillBitmapBlue : GHApp._orbFillBitmap;
                SKRect orbFillSrc = new SKRect(0.0f, (float)fillBitmap.Height * (1.0f - orbfillpercentage), (float)fillBitmap.Width, (float)fillBitmap.Height);
                SKRect orbFillDest = new SKRect(orbDest.Left, orbDest.Top + orbDest.Height * (1.0f - orbfillpercentage), orbDest.Right, orbDest.Bottom);
                canvas.DrawImage(fillBitmap, orbFillSrc, orbFillDest,
#if GNH_MAUI
                    new SKSamplingOptions(SKFilterMode.Linear),
#endif
                    paint);
                canvas.DrawImage(GHApp._orbGlassBitmap, orbDest,
#if GNH_MAUI
                    new SKSamplingOptions(SKFilterMode.Linear),
#endif
                    paint);
            }
#if GNH_MAP_PROFILING && DEBUG
            StopProfiling(GHProfilingStyle.Bitmap);
#endif
            if (val != null && val != "")
            {
                textPaint.TextSize = 36;
                textPaint.Typeface = GHApp.LatoBold;
                SKRect bounds = new SKRect();
                textPaint.MeasureText(val.Length > 4 ? val : "9999", ref bounds);
                float scale = bounds.Width / orbwidth;
                if (scale > 0)
                    textPaint.TextSize = textPaint.TextSize * 0.90f / scale;

                float tx = orbDest.Left + orbDest.Width / 2;
                float ty = orbDest.Top + (orbDest.Height - (textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent)) / 2 - textPaint.FontMetrics.Ascent;
                textPaint.Style = SKPaintStyle.Stroke;
                textPaint.StrokeWidth = textPaint.TextSize / 10;
                textPaint.Color = SKColors.Black;
#if GNH_MAP_PROFILING && DEBUG
                StartProfiling(GHProfilingStyle.Text);
#endif
                textPaint.DrawTextOnCanvas(canvas, val, tx, ty, SKTextAlign.Center);
                textPaint.Style = SKPaintStyle.Fill;
                textPaint.Color = SKColors.White;
                textPaint.DrawTextOnCanvas(canvas, val, tx, ty, SKTextAlign.Center);
#if GNH_MAP_PROFILING && DEBUG
                StopProfiling(GHProfilingStyle.Text);
#endif
            }

            if (showmax && maxval != null && maxval != "")
            {
                textPaint.TextSize = 36;
                textPaint.Typeface = GHApp.LatoBold;
                SKRect bounds = new SKRect();
                textPaint.MeasureText(maxval.Length > 4 ? maxval : "9999", ref bounds);
                float scale = bounds.Width / orbwidth;
                if (scale > 0)
                    textPaint.TextSize = textPaint.TextSize * 0.50f / scale;

                float tx = orbDest.Left + orbDest.Width / 2;
                float ty = orbDest.Bottom - 0.07f * orbDest.Height - (textPaint.FontMetrics.Descent - textPaint.FontMetrics.Ascent) - textPaint.FontMetrics.Ascent;
                textPaint.Style = SKPaintStyle.Stroke;
                textPaint.StrokeWidth = textPaint.TextSize / 10;
                textPaint.Color = SKColors.Black;
#if GNH_MAP_PROFILING && DEBUG
                StartProfiling(GHProfilingStyle.Text);
#endif
                textPaint.DrawTextOnCanvas(canvas, maxval, tx, ty, SKTextAlign.Center);
                textPaint.Style = SKPaintStyle.Fill;
                textPaint.Color = SKColors.White;
                textPaint.DrawTextOnCanvas(canvas, maxval, tx, ty, SKTextAlign.Center);
#if GNH_MAP_PROFILING && DEBUG
                StopProfiling(GHProfilingStyle.Text);
#endif
            }
            //textPaint.TextAlign = SKTextAlign.Left;
        }

        public async Task ReportPanic(string text)
        {
            if (!PlayingReplay)
            {
                bool answer = await GHApp.DisplayMessageBox(this, "Panic", (text != null ? text : "GnollHack has panicked. See the Panic Log.") +
                    "\nDo you want to report the panic and send a crash report to help the developer fix the cause? This will create a zip archive of the files in your game directory and ask it to be shared further.",
                    "Yes", "No");

                if (answer)
                {
                    await GHApp.CreateCrashReport(this);
                }
                _mainPage.EnqueuePost(new GHPost(0, false, (int)diagnostic_data_types.DIAGNOSTIC_DATA_PANIC, 0, text, null, answer));
            }
            else
            {
                await GHApp.DisplayMessageBox(this, "Panic (Replay: Press OK)", (text != null ? text : "GnollHack has panicked. See the Panic Log."), "OK");
            }

            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.Panic));
        }

        public async Task ShowMessage(string text)
        {
            await GHApp.DisplayMessageBox(this, "Message", text != null ? text : "No message.", "OK");

            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.Message));
        }

        public async Task YnConfirmation(string title, string text, string accept, string cancel)
        {
            bool res = await GHApp.DisplayMessageBox(this, title != null ? title : "Confirmation", text != null ? text : "Confirm?",
                accept != null ? accept : "Yes", cancel != null ? cancel : "No");

            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.YnConfirmation, res));
        }

        public async Task ReportCrashDetected()
        {
            if(GHApp.InformAboutCrashReport && !PlayingReplay)
            {
                bool introDisplayed = false;
                string intro = "A crashed game has been detected. GnollHack will attempt to restore this game." + Environment.NewLine + Environment.NewLine;
                bool answer;
#if !SENTRY
                if (!GHApp.PostingDiagnosticData)
                {
                    introDisplayed = true;
                    answer = await GHApp.DisplayMessageBox(this, "Crash Detected", intro + "Do you want to switch sending diagnostic data on? This will report any panic to the development team and send basic data on your the state of your device upon each such panic." 
                        //+ (GHApp.IsiOS ? Environment.NewLine + Environment.NewLine + "Further, to enable us to get information on crashes, please make sure that Share With App Developers is switched on in the Settings app under Privacy & Security > Analytics & Improvements." : "") 
                        + (UseMainGLCanvas ? Environment.NewLine + Environment.NewLine + "If the problem persists, try switching GPU Acceleration off in Settings." : ""), "Yes", "No");
                    if (answer)
                    {
                        GHApp.PostingDiagnosticData = true;
                        try
                        {
                            Preferences.Set("PostingDiagnosticData", true);
                        }
                        catch (Exception ex)
                        {
                            Debug.WriteLine(ex);
                        }
                    }
                }
#endif
                answer = await GHApp.DisplayMessageBox(this, introDisplayed ? "Send Crash Report?" : "Crash Detected", (!introDisplayed ? intro : "")+ "Do you want to create a crash report? This will create a zip archive of the files in your game directory and ask it to be shared further.", "Yes", "No");
                if (answer)
                {
                    await GHApp.CreateCrashReport(this);
                }
            }

            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.CrashReport));
        }

        private void GetLineEntryText_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (GetLineAutoComplete.IsVisible)
                UpdateGetLineAutoComplete();
        }

        private void GetLineEntryText_Completed(object sender, EventArgs e)
        {
            if (GetLineGrid.IsVisible && GetLineOkButton.IsEnabled && GHApp.PressOkOnEntryCompleted)
            {
                GetLineOkButton_Clicked(sender, e);
            }
        }


#if GNH_MAUI
        private void GetLineAutoCompleteTapGestureRecognizer_Tapped(object sender, TappedEventArgs e)
#else
        private void GetLineAutoCompleteTapGestureRecognizer_Tapped(object sender, EventArgs e)
#endif
        {
            if(GetLineAutoComplete.Text != "")
            {
                GetLineEntryText.Text = GetLineAutoComplete.Text;
            }
        }

        private void UpdateGetLineAutoComplete()
        {
            if(_getLineStyle == (int)getline_types.GETLINE_EXTENDED_COMMAND)
            {
                if (string.IsNullOrEmpty(GetLineEntryText.Text))
                {
                    GetLineAutoComplete.Text = "";
                    return;
                }

                if (ExtendedCommands == null)
                    return;

                string searchstring = GetLineEntryText.Text.ToLower();
                for (int i = 0; i < ExtendedCommands.Count; i++)
                {
                    string command = ExtendedCommands[i];
                    if (command == null)
                        break;
                    if (command.ToLower().StartsWith(searchstring))
                    {
                        GetLineAutoComplete.Text = command;
                        break;
                    }
                }
            }
        }

        public void SetSimpleLayoutCommandButton(int btnCol, int btnSelectionIndex)
        {
            LabeledImageButton[] _simpleButtions = new LabeledImageButton[6] 
            { lSimpleInventoryButton, lSimpleSearchButton, lSimpleSwapWeaponButton, lSimpleKickButton, lSimpleCastButton, lSimpleRepeatButton };
            if (btnCol < 0 || btnCol >= _simpleButtions.Length) 
                return;
            LabeledImageButton targetButton = _simpleButtions[btnCol];
            if (btnSelectionIndex < 0 || btnSelectionIndex >= GHApp.SelectableShortcutButtons.Count)
                return;
            SelectableShortcutButton sourceButton = GHApp.SelectableShortcutButtons[btnSelectionIndex];
            targetButton.LblText = sourceButton.Label;
            targetButton.BtnCommand = sourceButton.RawCommand;
            targetButton.BtnLetter = sourceButton.Letter;
            targetButton.BtnCtrl = sourceButton.Ctrl;
            targetButton.BtnMeta = sourceButton.Meta;
            targetButton.ImgSourcePath = sourceButton.ImageSourcePath;
        }

        public void SetFullLayoutCommandButton(int btnCol, int btnSelectionIndex)
        {
            LabeledImageButton[] _simpleButtions = new LabeledImageButton[13]
            { lInventoryButton, lSearchButton, lWaitButton, lDropManyButton, lChatButton, lKickButton, lRepeatButton,
                lSwapWeaponButton,lFireButton, lThrowButton, lCastButton, lZapButton, lApplyButton  };
            if (btnCol < 0 || btnCol >= _simpleButtions.Length)
                return;
            LabeledImageButton targetButton = _simpleButtions[btnCol];
            if (btnSelectionIndex < 0 || btnSelectionIndex >= GHApp.SelectableShortcutButtons.Count)
                return;
            SelectableShortcutButton sourceButton = GHApp.SelectableShortcutButtons[btnSelectionIndex];
            targetButton.LblText = sourceButton.Label;
            targetButton.BtnCommand = sourceButton.RawCommand;
            targetButton.BtnLetter = sourceButton.Letter;
            targetButton.BtnCtrl = sourceButton.Ctrl;
            targetButton.BtnMeta = sourceButton.Meta;
            targetButton.ImgSourcePath = sourceButton.ImageSourcePath;
        }

        //public void StopWaitAndResumeSavedGame()
        //{
        //    GHGame curGame = GHApp.CurrentGHGame;
        //    curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.StopWaitAndRestoreSavedGame));
        //}

        //public bool IgnoreSave()
        //{
        //    /* Saving and reloading would lead to loss of the wish, so do not save; the game attempts to do insurance before expending charge from the wand of wishing and other similar situations instead */
        //    return GetLineGrid.IsVisible && _getLineStyle == (int)getline_types.GETLINE_WISHING;
        //}

        //public void SaveGameAndWaitForResume()
        //{
        //    GHGame curGame = GHApp.CurrentGHGame;
        //    curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SaveGameAndWaitForResume));
        //}

        //public void SaveCheckPoint()
        //{
        //    GHGame curGame = GHApp.CurrentGHGame;
        //    curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SaveInsuranceCheckPoint));
        //}

        public void SendRequestForTallyRealTime()
        {
            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.TallyRealTime));
        }

        public void Suspend()
        {
            StopMainCanvasAnimation();
            StopCommandCanvasAnimation();
            StopMenuCanvasAnimation();
            MenuWindowGlyphImage.StopAnimation();
            StopTextCanvasAnimation();
            TextWindowGlyphImage.StopAnimation();
        }

        public void Resume()
        {
            if (MenuGrid.IsVisible)
            {
                if (!MenuCanvas.AnimationIsRunning("GeneralAnimationCounter"))
                    StartMenuCanvasAnimation();
                MenuWindowGlyphImage.CheckStartAnimation();
            }
            else if (TextGrid.IsVisible)
            {
                if (!TextCanvas.AnimationIsRunning("GeneralAnimationCounter"))
                    StartTextCanvasAnimation();
                TextWindowGlyphImage.CheckStartAnimation();
            }
            else if (MoreCommandsGrid.IsVisible && !CommandCanvas.AnimationIsRunning("GeneralAnimationCounter"))
                StartCommandCanvasAnimation();
            else if (!LoadingGrid.IsVisible && IsMainCanvasOn /* && MainGrid.IsVisible */ && !MainCanvasView.AnimationIsRunning("GeneralAnimationCounter"))
                StartMainCanvasAnimation();
        }

        void UpdateMessageFilter()
        {
            GHMsgHistorySpan msgHistoryPtr = null;
            msgHistoryPtr = Interlocked.CompareExchange(ref _msgHistory, null, null);
            //lock (_msgHistoryLock)
            //{
            //    msgHistoryPtr = _msgHistory;
            //}

            if (msgHistoryPtr != null)
            {
                int cnt = msgHistoryPtr.Length;
                if (LongerMessageHistory)
                {
                    for (int i = 0; i < cnt; i++)
                    {
                        GHMsgHistoryItem msg = msgHistoryPtr[i];
                        if (msg != null)
                            msg.Filter = MessageFilterEntry.Text;
                    }
                }
                else
                {
                    for (int i = 0; i < cnt; i++)
                    {
                        GHMsgHistoryItem msg = msgHistoryPtr[i];
                        if (msg != null)
                            msg.Filter = null;
                    }
                }
            }
            RefreshMsgHistoryRowCounts = true;
        }

        private void MessageFilterEntry_TextChanged(object sender, TextChangedEventArgs e)
        {
            UpdateMessageFilter();
        }

        public void RequestEndReplayFile()
        {
            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.EndReplayFile));
        }


        private void ReplayQuitButton_Clicked(object sender, EventArgs e)
        {
            GHApp.StopReplay = true;
            UpdateReplayHeaderLabel();
        }

        private void UpdateReplaySpeedButtons()
        {
            double speed = GHApp.ReplaySpeed;
            ReplayFasterButton.Text = string.Format("{0:0.##}x", speed * 2);
            ReplaySlowerButton.Text = string.Format("{0:0.##}x", speed / 2);
            if(GHApp.ReplaySpeed >= 128)
            {
                ReplayFasterButton.TextColor = GHColors.Gray;
                ReplayFasterButton.IsEnabled = false;
            }
            else
            {
                ReplayFasterButton.TextColor = GHColors.White;
                ReplayFasterButton.IsEnabled = true;
            }
            if (GHApp.ReplaySpeed <= 1.0/128)
            {
                ReplaySlowerButton.TextColor = GHColors.Gray;
                ReplaySlowerButton.IsEnabled = false;
            }
            else
            {
                ReplaySlowerButton.TextColor = GHColors.White;
                ReplaySlowerButton.IsEnabled = true;
            }
            UpdateReplayHeaderLabel();
        }
        private void UpdateReplayPauseButton()
        {
            if(GHApp.PauseReplay)
            {
                ReplayPauseButton.Text = "Play";
                ReplayPauseButton.TextColor = GHColors.BrighterGreen;
                ReplaySlowerButton.IsVisible = false;
                ReplayFasterButton.IsVisible = false;
                ReplayGotoButton.IsVisible = true;
                ReplayNextButton.IsVisible = true;
            }
            else
            {
                ReplayPauseButton.Text = "Pause";
                ReplayPauseButton.TextColor = GHColors.Yellow;
                ReplaySlowerButton.IsVisible = true;
                ReplayFasterButton.IsVisible = true;
                ReplayGotoButton.IsVisible = false;
                ReplayNextButton.IsVisible = false;
            }

            UpdateReplayHeaderLabel();
        }

        private void UpdateReplayHeaderLabel()
        {
            int currentTurn = GHApp.ReplayTurn;
            int gotoTurn = GHApp.GoToTurn;
            string searchPattern = GHApp.ReplaySearchRegexString;
            int originalTurn = GHApp.OriginalReplayTurn;
            if (GHApp.StopReplay)
            {
                ReplayHeaderLabel.Text = "Stopping Replay...";
                ReplayHeaderLabel.TextColor = GHColors.BrighterRed;
            }
            else if (gotoTurn >= 0)
            {
                double percentage = currentTurn <= originalTurn ? 0.0 : gotoTurn <= originalTurn ? 1.0 : currentTurn < gotoTurn ? (currentTurn - originalTurn) / (gotoTurn - originalTurn) : 1.0;
                if(percentage > 0.0)
                    ReplayHeaderLabel.Text = string.Format("Rewinding to T:{0} ({1:0.#}%)", gotoTurn, percentage * 100);
                else
                    ReplayHeaderLabel.Text = string.Format("Rewinding to T:{0}...", gotoTurn);

                ReplayHeaderLabel.TextColor = GHColors.LightBlue;
            }
            else if (searchPattern != null)
            {
                ReplayHeaderLabel.Text = string.Format("Searching for \'{0}\' (T:{1})", searchPattern, GHApp.ReplayTurn);
                ReplayHeaderLabel.TextColor = GHColors.LightBlue;
            }
            else
            {
                if (GHApp.PauseReplay)
                {
                    ReplayHeaderLabel.Text = string.Format("Speed: Paused at {0:0.##}x", GHApp.ReplaySpeed);
                    ReplayHeaderLabel.TextColor = GHColors.Yellow;
                }
                else
                {
                    ReplayHeaderLabel.Text = string.Format("Speed: {0:0.##}x", GHApp.ReplaySpeed);
                    ReplayHeaderLabel.TextColor = GHColors.White;
                }
            }
        }
        private void ReplayFasterButton_Clicked(object sender, EventArgs e)
        {
            if(GHApp.ReplaySpeed < 128)
            {
                GHApp.ReplaySpeed = GHApp.ReplaySpeed * 2;
                UpdateReplaySpeedButtons();
            }
        }


        private void ReplaySlowerButton_Clicked(object sender, EventArgs e)
        {
            if (GHApp.ReplaySpeed > 1.0 / 128)
            {
                GHApp.ReplaySpeed = GHApp.ReplaySpeed / 2;
                UpdateReplaySpeedButtons();
            }
        }

        private void ReplayPauseButton_Clicked(object sender, EventArgs e)
        {
            GHApp.PauseReplay = !GHApp.PauseReplay;
            UpdateReplayPauseButton();
        }

        private void ReplayGotoButton_Clicked(object sender, EventArgs e)
        {
            if (GotoStylePicker.SelectedIndex < 1)
                GotoTurnEntryText.Text = "";
            GotoTurnEntryText.IsEnabled = true;
#if GNH_MAUI
            GotoTurnFrame.Stroke = SolidColorBrush.Black;
#else
            GotoTurnFrame.BorderColor = GHColors.Black;
#endif
            GotoTurnOkButton.IsEnabled = true;
            GotoTurnCancelButton.IsEnabled = true;
            if (GotoStylePicker.SelectedIndex < 0)
                GotoStylePicker.SelectedIndex = 0;
            GotoTurnGrid.IsVisible = true;
        }

        private void ReplayNextButton_Clicked(object sender, EventArgs e)
        {
            ReplayNextButton.IsEnabled = false;
            if (GHApp.ReplayTurn >= 0)
            {
                GHApp.GoToTurn = GHApp.ReplayTurn + 1;
            }
            UpdateReplayHeaderLabel();
            ReplayNextButton.IsEnabled = true;
        }

        private void GotoTurnOkButton_Clicked(object sender, EventArgs e)
        {
            GotoTurnOkButton.IsEnabled = false;
            GotoTurnCancelButton.IsEnabled = false;

            switch(GotoStylePicker.SelectedIndex)
            {
                default:
                    break;
                case 0:
                    if (string.IsNullOrWhiteSpace(GotoTurnEntryText.Text))
                    {
                        GHApp.GoToTurn = -1;
                    }
                    else
                    {
                        string txt = GotoTurnEntryText.Text.Trim();
                        if (int.TryParse(txt, out int turn))
                        {
                            GHApp.GoToTurn = turn;
                        }
                        else
                        {
#if GNH_MAUI
                            GotoTurnFrame.Stroke = SolidColorBrush.Red;
#else
                            GotoTurnFrame.BorderColor = GHColors.Red;
#endif
                            GotoTurnEntryText.Focus();
                            GotoTurnOkButton.IsEnabled = true;
                            GotoTurnCancelButton.IsEnabled = true;
                            return;
                        }
                    }
                    break;
                case 1:
                    if (!GHUtils.IsValidRegex(GotoTurnEntryText.Text))
                    {
                        GHApp.ReplaySearchRegexString = null;
                    }
                    else
                    {
                        string pattern = GotoTurnEntryText.Text.Trim();
                        if (GHUtils.IsValidRegex(pattern))
                        {
                            GHApp.ReplaySearchRegexString = pattern;
                        }
                        else
                        {
#if GNH_MAUI
                            GotoTurnFrame.Stroke = SolidColorBrush.Red;
#else
                            GotoTurnFrame.BorderColor = GHColors.Red;
#endif
                            GotoTurnEntryText.Focus();
                            GotoTurnOkButton.IsEnabled = true;
                            GotoTurnCancelButton.IsEnabled = true;
                            return;
                        }
                    }
                    break;
            }
            UpdateReplayHeaderLabel();
            GotoTurnGrid.IsVisible = false;
            GotoTurnEntryText.Unfocus();
            GotoTurnEntryText.IsEnabled = false;
        }

        private void GotoTurnCancelButton_Clicked(object sender, EventArgs e)
        {
            GotoTurnOkButton.IsEnabled = false;
            GotoTurnCancelButton.IsEnabled = false;

            switch (GotoStylePicker.SelectedIndex)
            {
                default:
                    break;
                case 0:
                    GHApp.GoToTurn = -1;
                    break;
                case 1:
                    GHApp.ReplaySearchRegexString = null;
                    break;
            }
            UpdateReplayHeaderLabel();

            GotoTurnGrid.IsVisible = false;
            GotoTurnEntryText.Unfocus();
            GotoTurnEntryText.IsEnabled = false;
        }

        private void GotoStylePicker_SelectedIndexChanged(object sender, EventArgs e)
        {
            GotoTurnEntryText.Text = "";
            switch (GotoStylePicker.SelectedIndex)
            {
                default:
                    break;
                case 0:
                    GotoTurnEntryText.Keyboard = Keyboard.Numeric;
                    GotoTurnEntryText.Placeholder = "Enter the turn here";
                    break;
                case 1:
                    GotoTurnEntryText.Keyboard = Keyboard.Default;
                    GotoTurnEntryText.Placeholder = "Enter regular expression";
                    break;
            }
        }

#if GNH_MAUI
        private async void GetLineCaptionTapGestureRecognizer_Tapped(object sender, TappedEventArgs e)
#else
        private async void GetLineCaptionTapGestureRecognizer_Tapped(object sender, EventArgs e)
#endif
        {
            switch (_getLineStyle)
            {
                case (int)getline_types.GETLINE_WISHING:
                case (int)getline_types.GETLINE_GENESIS:
                case (int)getline_types.GETLINE_POLYMORPH:
                case (int)getline_types.GETLINE_GENOCIDE:
                case (int)getline_types.GETLINE_MONSTER:
                case (int)getline_types.GETLINE_MONSTER_CLASS:
                    GetLineCaption.IsEnabled = false;
                    GHApp.PlayButtonClickedSound();
                    var menuPage = new GameMenuPage(this, true);
                    await GHApp.Navigation.PushModalAsync(menuPage);
                    GetLineCaption.IsEnabled = true;
                    break;
                default:
                    break;

            }
        }

        private async void GetLineMenuButton_BtnClicked(object sender, EventArgs e)
        {
            GetLineMenuButton.IsEnabled = false;
            GHApp.PlayButtonClickedSound();
            var menuPage = new GameMenuPage(this, true);
            await GHApp.Navigation.PushModalAsync(menuPage);
            GetLineMenuButton.IsEnabled = true;
        }

        public void SendEnterPressed()
        {
#if WINDOWS
            HandleKeyDown(this, VirtualKey.Enter);
#endif
        }

        private void SetupKeyListening()
        {
//#if WINDOWS
//            try
//            {
//                var window = this.Window;
//                var handler = window.Handler;
//                var platformView = handler.PlatformView;
//                Microsoft.UI.Xaml.Window xamlWindow = platformView as Microsoft.UI.Xaml.Window;
//                if (xamlWindow != null)
//                {
//                    xamlWindow.Content.KeyDown += PageContent_KeyDown;
//                    xamlWindow.Content.KeyUp += PageContent_KeyUp;
//                    xamlWindow.Content.PreviewKeyDown += Content_PreviewKeyDown;
//                    xamlWindow.Content.PreviewKeyUp += Content_PreviewKeyUp;
//                    xamlWindow.Content.CharacterReceived += PageContent_CharacterReceived;
//                    xamlWindow.Content.Focus(Microsoft.UI.Xaml.FocusState.Keyboard);
//                }
//            }
//            catch (Exception ex)
//            {
//                Debug.WriteLine(ex.Message);
//            }
//#endif
        }

        private void StopKeyListening()
        {
//#if WINDOWS
//            try
//            {
//                var window = this.Window;
//                var handler = window.Handler;
//                var platformView = handler.PlatformView;
//                Microsoft.UI.Xaml.Window xamlWindow = platformView as Microsoft.UI.Xaml.Window;
//                if (xamlWindow != null)
//                {
//                    xamlWindow.Content.KeyDown -= PageContent_KeyDown;
//                    xamlWindow.Content.KeyUp -= PageContent_KeyUp;
//                    xamlWindow.Content.PreviewKeyDown -= Content_PreviewKeyDown;
//                    xamlWindow.Content.PreviewKeyUp -= Content_PreviewKeyUp;
//                    xamlWindow.Content.CharacterReceived -= PageContent_CharacterReceived;
//                }
//            }
//            catch(Exception ex)
//            {
//                Debug.WriteLine(ex.Message);
//            }
//#endif
        }

        private void GotoTurnEntryText_Completed(object sender, EventArgs e)
        {
            if(ReplayGrid.IsVisible && GotoTurnOkButton.IsEnabled && GHApp.PressOkOnEntryCompleted)
            {
                GotoTurnOkButton_Clicked(sender, e);
            }
        }

        private int _menuCountNumber = -1;

        private void MorePreviousButton_BtnClicked(object sender, EventArgs e)
        {
            int cmdPage = MoreCmdPage;
            if (cmdPage > (EnableWizardMode ? 0 : 1))
            {
                MoreCmdPage = cmdPage - 1;
            }
            UpdateMoreNextPrevButtonVisibility(false, true);
        }

        private void MoreNextButton_BtnClicked(object sender, EventArgs e)
        {
            int cmdPage = MoreCmdPage;
            if (cmdPage < CurrentMoreButtonPageMaxNumber - 1)
            {
                MoreCmdPage = cmdPage + 1;
            }
            UpdateMoreNextPrevButtonVisibility(true, false);
        }

        private void UpdateMoreNextPrevButtonVisibility(bool resetPrevButton, bool resetNextButton)
        {
            if(GHApp.IsDesktop) /* Assuming mouse pointer usage */
            {
                int cmdPage = MoreCmdPage;
                MorePreviousGrid.IsVisible = cmdPage > (EnableWizardMode ? 0 : 1);
                MoreNextGrid.IsVisible = cmdPage < CurrentMoreButtonPageMaxNumber - 1;
            }
            else
            {
                MorePreviousGrid.IsVisible = false;
                MoreNextGrid.IsVisible = false;
            }

            if (resetPrevButton || !MorePreviousGrid.IsVisible)
                MorePreviousButton.IsVisible = false;
            if(resetNextButton || !MoreNextGrid.IsVisible)
                MoreNextButton.IsVisible = false;
        }

        public void SetZoomNormal()
        {
            if (ZoomMiniMode)
                ToggleZoomMiniButton_Clicked(null, null);
            if (ZoomAlternateMode)
                ToggleZoomAlternateButton_Clicked(null, null);
            MapFontSize = DefaultMapFontSize;
        }

        public void SetZoomNormalInCurrentMode()
        {
            if (ZoomAlternateMode)
                MapFontAlternateSize = DefaultMapFontSize * GHConstants.MapFontRelativeAlternateSize;
            else if (ZoomMiniMode)
                MapFontMiniRelativeSize = 1.0f;
            else
                MapFontSize = DefaultMapFontSize;
        }

        public void ZoomIn()
        {
            if (ZoomMiniMode)
                ToggleZoomMiniButton_Clicked(null, null);
            if (ZoomAlternateMode)
                ToggleZoomAlternateButton_Clicked(null, null);
            ZoomInOutInCurrentMode(false, false);
        }

        public void ZoomOut()
        {
            if (ZoomMiniMode)
                ToggleZoomMiniButton_Clicked(null, null);
            if (ZoomAlternateMode)
                ToggleZoomAlternateButton_Clicked(null, null);
            ZoomInOutInCurrentMode(true, false);
        }

        public void ZoomInOutInCurrentMode(bool isOut, bool isSmallChange)
        {
            bool isMeta = isSmallChange;
            float canvaswidth;
            float canvasheight;
            lock (_savedCanvasLock)
            {
                canvaswidth = _savedCanvasWidth;
                canvasheight = _savedCanvasHeight;
            }
            if (canvaswidth <= 0 || canvasheight <= 0)
                return;

            if (ZoomMiniMode)
            {
                SKPoint point = new SKPoint(canvaswidth / 2, canvasheight / 2);
                float ratio = !isOut ? (1 + (isMeta ? 0.001f : 0.01f)) : 1 / (1 + (isMeta ? 0.001f : 0.01f));
                AdjustZoomByRatio(ratio, point, point, point);
            }
            else
            {
                float multiplier = isOut ? -1.0f : 1.0f;
                float newfontsize;
                if (ZoomAlternateMode)
                    newfontsize = MapFontAlternateSize + multiplier * (isMeta ? 0.001f : 0.01f) * DefaultMapFontSize;
                else
                    newfontsize = MapFontSize + multiplier * (isMeta ? 0.001f : 0.01f) * DefaultMapFontSize;

                SKPoint point = new SKPoint(canvaswidth / 2, canvasheight / 2);
                SetZoomFontSize(newfontsize, point, point, point);
            }
            MapFontShowPercentageDecimal = isMeta;
        }

        public void SetZoomMini()
        {
            if (!ZoomMiniMode)
                ToggleZoomMiniButton_Clicked(null, null);
        }
        public void SetZoomHalf()
        {
            if (ZoomMiniMode)
                ToggleZoomMiniButton_Clicked(null, null);
            if (!ZoomAlternateMode)
                ToggleZoomAlternateButton_Clicked(null, null);
        }

        public bool HandleKeyPress(int key, bool isCtrl, bool isMeta)
        {
            Debug.WriteLine("HandleKeyPress: " + key);
            bool handled = false;
            if (LoadingGrid.IsVisible || key == 13 || !GHApp.IsPageOnTopOfModalNavigationStack(this))
            {
                /* Nothing */
            }
            else if (MoreCommandsGrid.IsVisible && MoreCommandsFilterEntry.IsFocused)
            {
                handled = false;
            }
            else if (GetLineGrid.IsVisible && (key == 27))
            {
                //if (key == 13)
                //    GetLineOkButton_Clicked(null, null);
                //else if (key == 27)
                    GetLineCancelButton_Clicked(null, null);

                handled = false;
            }
            else if (PopupGrid.IsVisible && (key == 27))
            {
                PopupOkButton_Clicked(null, null);
                handled = true;
            }
            else if (YnGrid.IsVisible && !string.IsNullOrWhiteSpace(_ynResponses) && _ynResponses.Contains((char)key))
            {
                YnButton_Pressed(null, null, key);
                handled = true;
            }
            else if (MenuGrid.IsVisible && !MenuCountGrid.IsVisible)
            {
                char c = (char)key;
                if(key == 27 && MenuCancelButton.IsEnabled)
                {
                    PressMenuCancelButton();
                    handled = true;
                }
                else if (MenuCanvas.SelectionHow == SelectionMode.Multiple && c == '.')
                {
                    MenuTapGestureRecognizer_Tapped(null, null);
                    handled = true;
                }
                else
                {
                    bool doclickok = false;
                    bool somethingFound = false;
                    //lock (MenuCanvas.MenuItemLock)
                    {
                        var menuItems = MenuCanvas.MenuItems;
                        if (menuItems == null)
                            return true;

                        for (int idx = 0; idx < menuItems.Count; idx++)
                        {
                            if (menuItems[idx].Accelerator == c)
                            {
                                somethingFound = true;
                                doclickok = ClickMenuItem(idx, false);
                                break;
                            }
                            else if (MenuCanvas.SelectionHow == SelectionMode.Multiple && (menuItems[idx].Flags & (ulong)MenuFlags.MENU_FLAGS_IS_GROUP_HEADING) != 0 && menuItems[idx].HeadingGroupAccelerator == c
                                && (_menuCountNumber < 0 || menuItems[idx].HeadingGroupAccelerator < '0' || menuItems[idx].HeadingGroupAccelerator > '9'))
                            {
                                somethingFound = true;
                                doclickok = ClickMenuItem(idx, false);
                                break;
                            }
                        }
                    }
                    if (somethingFound)
                    {
                        _menuCountNumber = -1;
                        if (MenuOKButton.IsEnabled)
                        {
                            if (doclickok)
                            {
                                MenuCanvas.InvalidateSurface();
                                PressMenuOKButton();
                            }
                            else
                            {
                                if (MenuCanvas.SelectionHow == SelectionMode.Single)
                                    PressMenuOKButton();
                            }
                        }
                        handled = true;
                    }
                    else if (c >= '0' && c <= '9' && _menuCountNumber < int.MaxValue / 10 - 10)
                    {
                        int res;
                        if (int.TryParse(c.ToString(), out res))
                        {
                            if (_menuCountNumber >= 0)
                                _menuCountNumber *= 10;
                            else
                                _menuCountNumber = 0;
                            _menuCountNumber += res;
                        }
                    }
                }
            }
            else if (ReplayGrid.IsVisible && !GotoTurnGrid.IsVisible)
            {
                if ((key == (int)'p' || key == (int)' ') && ReplayPauseButton.IsEnabled)
                    ReplayPauseButton_Clicked(null, null);
                else if ((key == (int)'<' || key == (int)'s' || key == (int)'-') && ReplaySlowerButton.IsEnabled)
                    ReplaySlowerButton_Clicked(null, null);
                else if ((key == (int)'>' || key == (int)'f' || key == (int)'+') && ReplayFasterButton.IsEnabled)
                    ReplayFasterButton_Clicked(null, null);
                else if ((key == (int)'g' || key == (int)'?') && ReplayGotoButton.IsEnabled)
                    ReplayGotoButton_Clicked(null, null);
                else if ((key == (int)'n' || key == (int)'1' || key == (int)'.') && ReplayNextButton.IsEnabled)
                    ReplayNextButton_Clicked(null, null);
                else if (key == (int)'q' && ReplayQuitButton.IsEnabled)
                    ReplayQuitButton_Clicked(null, null);

                handled = true;
            }
            else if (!MenuGrid.IsVisible && !TextGrid.IsVisible && !PopupGrid.IsVisible && !GetLineGrid.IsVisible && !YnGrid.IsVisible && !ReplayGrid.IsVisible && !PlayingReplay)
            {
                if (!MoreCommandsGrid.IsVisible && ForceAllMessages && MessageFilterEntry.IsFocused)
                {
                    handled = false;
                }
                else
                {
                    if (MoreCommandsGrid.IsVisible)
                    {
                        CommandCanvas_Pressed(null, null);
                    }

                    if (key != 0)
                    {
                        if (isMeta)
                            GenericButton_Clicked(null, null, GHUtils.Meta(key));
                        else if (isCtrl)
                            GenericButton_Clicked(null, null, GHUtils.Ctrl(key));
                        else
                            GenericButton_Clicked(null, null, key);

                        handled = true;
                    }
                }
            }
            return handled;
        }

        public bool HandleSpecialKeyPress(GHSpecialKey key, bool isCtrl, bool isMeta, bool isShift)
        {
            bool handled = false;
            if (LoadingGrid.IsVisible || !GHApp.IsPageOnTopOfModalNavigationStack(this))
            {
                /* Nothing */
            }
            else if(key == GHSpecialKey.None)
            {
                handled = true;
            }
            else if (TipView.IsVisible && (key == GHSpecialKey.Escape || key == GHSpecialKey.Enter || key == GHSpecialKey.Space))
            {
                if (key == GHSpecialKey.Escape)
                    ShownTip = 100; //Move to end
                TipView_Touch(this, new SKTouchEventArgs(0L, SKTouchAction.Released, new SKPoint(0, 0), true));
                handled = true;
            }
            else if (MoreCommandsGrid.IsVisible && (key == GHSpecialKey.Escape || key == GHSpecialKey.Enter || key == GHSpecialKey.Space))
            {
                CommandCanvas_Pressed(null, null);
                handled = true;
            }
            else if (MoreCommandsGrid.IsVisible && (key == GHSpecialKey.Left || key == GHSpecialKey.Right || key == GHSpecialKey.PageUp || key == GHSpecialKey.PageDown || key == GHSpecialKey.Home || key == GHSpecialKey.End))
            {
                int cmdPage = MoreCmdPage;
                if (key == GHSpecialKey.Left || key == GHSpecialKey.PageUp)
                {
                    if (cmdPage > (EnableWizardMode ? 0 : 1))
                    {
                        MoreCmdPage = cmdPage - 1;
                        MoreCmdOffsetX = 0;
                        MainThread.BeginInvokeOnMainThread(() =>
                        {
                            CommandCanvas.InvalidateSurface();
                            UpdateMoreNextPrevButtonVisibility(true, true);
                        });
                    }
                    handled = true;
                }
                else if (key == GHSpecialKey.Right || key == GHSpecialKey.PageDown)
                {
                    if (cmdPage < CurrentMoreButtonPageMaxNumber - 1)
                    {
                        MoreCmdPage = cmdPage + 1;
                        MoreCmdOffsetX = 0;
                        MainThread.BeginInvokeOnMainThread(() =>
                        {
                            CommandCanvas.InvalidateSurface();
                            UpdateMoreNextPrevButtonVisibility(true, true);
                        });
                    }
                    handled = true;
                }
                else if (key == GHSpecialKey.Home)
                {
                    if (cmdPage > (EnableWizardMode ? 0 : 1))
                    {
                        MoreCmdPage = 1;
                        MoreCmdOffsetX = 0;
                        MainThread.BeginInvokeOnMainThread(() =>
                        {
                            CommandCanvas.InvalidateSurface();
                            UpdateMoreNextPrevButtonVisibility(true, true);
                        });
                    }
                    handled = true;
                }
                else if (key == GHSpecialKey.End)
                {
                    if (cmdPage < CurrentMoreButtonPageMaxNumber - 1)
                    {
                        MoreCmdPage = CurrentMoreButtonPageMaxNumber - 1;
                        MoreCmdOffsetX = 0;
                        MainThread.BeginInvokeOnMainThread(() =>
                        {
                            CommandCanvas.InvalidateSurface();
                            UpdateMoreNextPrevButtonVisibility(true, true);
                        });
                    }
                    handled = true;
                }
            }
            else if (TextGrid.IsVisible && (key == GHSpecialKey.Escape || key == GHSpecialKey.Enter || key == GHSpecialKey.Space || key == GHSpecialKey.Up || key == GHSpecialKey.Down || key == GHSpecialKey.PageUp || key == GHSpecialKey.PageDown || key == GHSpecialKey.Home || key == GHSpecialKey.End))
            {
                if ((key == GHSpecialKey.Enter || TextGrid.IsVisible && key == GHSpecialKey.Escape) && !PlayingReplay)
                    TextCanvasPressed();
                else if (key == GHSpecialKey.Up)
                    ScrollTextWindow(120);
                else if (key == GHSpecialKey.Down)
                    ScrollTextWindow(-120);
                else if (key == GHSpecialKey.PageUp)
                    ScrollTextWindow(1200);
                else if (key == GHSpecialKey.PageDown)
                    ScrollTextWindow(-1200);
                else if (key == GHSpecialKey.Home)
                    ScrollTextWindow(1200000);
                else if (key == GHSpecialKey.End)
                    ScrollTextWindow(-1200000);
                else if (key == GHSpecialKey.Space)
                {
                    if (!IsTextWindowAtBottomScrollLimit())
                        ScrollTextWindow(-1200);
                    else if (!PlayingReplay)
                        TextCanvasPressed();
                }
                handled = true;
            }
            else if (MenuGrid.IsVisible && !MenuCountGrid.IsVisible && (key == GHSpecialKey.Escape || key == GHSpecialKey.Enter || key == GHSpecialKey.Up || key == GHSpecialKey.Down || key == GHSpecialKey.Space || key == GHSpecialKey.PageUp || key == GHSpecialKey.PageDown || key == GHSpecialKey.Home || key == GHSpecialKey.End))
            {
                if (MenuCancelButton.IsEnabled && key == GHSpecialKey.Escape && !PlayingReplay)
                    PressMenuCancelButton();
                else if (MenuOKButton.IsEnabled && (key == GHSpecialKey.Enter) && !PlayingReplay)
                    PressMenuOKButton();
                else if (key == GHSpecialKey.Up)
                    ScrollMenu(120);
                else if (key == GHSpecialKey.Down)
                    ScrollMenu(-120);
                else if (key == GHSpecialKey.PageUp)
                    ScrollMenu(1200);
                else if (key == GHSpecialKey.PageDown)
                    ScrollMenu(-1200);
                else if (key == GHSpecialKey.Home)
                    ScrollMenu(1200000);
                else if (key == GHSpecialKey.End)
                    ScrollMenu(-1200000);
                else if (key == GHSpecialKey.Space)
                {
                    if (!IsMenuAtBottomScrollLimit())
                        ScrollMenu(-1200);
                    else if (MenuOKButton.IsEnabled && !PlayingReplay)
                        PressMenuOKButton();
                }
                handled = true;
            }
            else if (MenuGrid.IsVisible && MenuCountGrid.IsVisible && !PlayingReplay && (key == GHSpecialKey.Escape || key == GHSpecialKey.Enter))
            {
                if (MenuCountCancelButton.IsEnabled && key == GHSpecialKey.Escape)
                    MenuCountCancelButton_Clicked(null, null);
                else if (MenuCountOkButton.IsEnabled && (key == GHSpecialKey.Enter))
                    MenuCountOkButton_Clicked(null, null);
                handled = true;
            }
            else if (GetLineGrid.IsVisible && (key == GHSpecialKey.Escape || key == GHSpecialKey.Enter || key == GHSpecialKey.Tab || key == GHSpecialKey.F1) && !PlayingReplay)
            {
                if (key == GHSpecialKey.Enter && GetLineOkButton.IsEnabled)
                    GetLineOkButton_Clicked(null, null);
                else if (key == GHSpecialKey.Escape && GetLineCancelButton.IsEnabled)
                    GetLineCancelButton_Clicked(null, null);
                else if (key == GHSpecialKey.Tab && GetLineAutoComplete.IsVisible && GetLineAutoComplete.IsEnabled)
                    GetLineAutoCompleteTapGestureRecognizer_Tapped(null, null);
                else if (key == GHSpecialKey.F1 && GetLineQuestionMarkButton.IsVisible && GetLineQuestionMarkButton.IsEnabled)
                    GetLineQuestionMarkButton_Clicked(null, null);
                handled = true;
            }
            else if (YnGrid.IsVisible && (key == GHSpecialKey.Escape) && !PlayingReplay)
            {
                YnButton_Pressed(null, null, GHConstants.CancelChar);
                handled = true;
            }
            else if (PopupGrid.IsVisible && (key == GHSpecialKey.Escape || key == GHSpecialKey.Enter || key == GHSpecialKey.Space) && !PlayingReplay)
            {
                PopupOkButton_Clicked(null, null);
                handled = true;
            }
            else if (ReplayGrid.IsVisible && !GotoTurnGrid.IsVisible && (key == GHSpecialKey.Enter || key == GHSpecialKey.Space || key == GHSpecialKey.Escape || key == GHSpecialKey.Down || key == GHSpecialKey.Up || key == GHSpecialKey.Right))
            {
                if ((key == GHSpecialKey.Enter || key == GHSpecialKey.Space) && ReplayPauseButton.IsEnabled)
                    ReplayPauseButton_Clicked(null, null);
                else if ((key == GHSpecialKey.Down) && ReplaySlowerButton.IsEnabled)
                    ReplaySlowerButton_Clicked(null, null);
                else if ((key == GHSpecialKey.Up) && ReplayFasterButton.IsEnabled)
                    ReplayFasterButton_Clicked(null, null);
                else if ((key == GHSpecialKey.Right) && ReplayNextButton.IsEnabled)
                    ReplayNextButton_Clicked(null, null);
                else if (key == GHSpecialKey.Escape && ReplayQuitButton.IsEnabled)
                    ReplayQuitButton_Clicked(null, null);

                handled = true;
            }
            else if (ReplayGrid.IsVisible && GotoTurnGrid.IsVisible && (key == GHSpecialKey.Enter || key == GHSpecialKey.Space || key == GHSpecialKey.Escape))
            {
                if ((key == GHSpecialKey.Enter || key == GHSpecialKey.Space) && GotoTurnOkButton.IsEnabled)
                    GotoTurnOkButton_Clicked(null, null);
                else if (key == GHSpecialKey.Escape && GotoTurnCancelButton.IsEnabled)
                    GotoTurnCancelButton_Clicked(null, null);

                handled = true;
            }
            else if (!MenuGrid.IsVisible && !PopupGrid.IsVisible && !GetLineGrid.IsVisible && !YnGrid.IsVisible && !TextGrid.IsVisible && !PopupGrid.IsVisible && !ReplayGrid.IsVisible)
            {
                if (MoreCommandsGrid.IsVisible && !MoreCommandsFilterEntry.IsFocused)
                {
                    CommandCanvas_Pressed(null, null);
                }
                else if (key == GHSpecialKey.F10)
                {
                    OpenGameMenu();
                    handled = true;
                }
                else if ((isCtrl || isMeta) && (key == GHSpecialKey.Number0 || key == GHSpecialKey.NumberPad0))
                {
                    SetZoomNormalInCurrentMode();
                    handled = true;
                }
                else if ((isCtrl || isMeta) && (key == GHSpecialKey.Decimal))
                {
                    ToggleZoomMiniButton_Clicked(null, null);
                    handled = true;
                }
                else if ((isCtrl || isMeta) && (key == GHSpecialKey.Add || key == GHSpecialKey.Subtract))
                {
                    ZoomInOutInCurrentMode(key == GHSpecialKey.Subtract, isMeta);
                    handled = true;
                }
                else if (ForceAllMessages)
                {
                    if (key == GHSpecialKey.Up)
                        ScrollMessages(120);
                    else if (key == GHSpecialKey.Down)
                        ScrollMessages(-120);
                    else if (key == GHSpecialKey.PageUp)
                        ScrollMessages(1200);
                    else if (key == GHSpecialKey.PageDown)
                        ScrollMessages(-1200);
                    else if (key == GHSpecialKey.Home)
                        ScrollMessages(1200000);
                    else if (key == GHSpecialKey.End)
                        ScrollMessages(-1200000);
                    else if (key == GHSpecialKey.Space)
                        ScrollMessages(1200);
                    handled = true;
                }
                else if (!PlayingReplay)
                {
                    int resp = 0;
                    if (key == GHSpecialKey.Escape)
                        resp = GHConstants.CancelChar;
                    else if (key == GHSpecialKey.Left)
                        resp = isCtrl == isMeta ? -4 : isCtrl ? -7 : -1;
                    else if (key == GHSpecialKey.Right)
                        resp = isCtrl == isMeta ? -6 : isCtrl ? -9 : -3;
                    else if (key == GHSpecialKey.Up)
                        resp = isCtrl == isMeta ? -8 : isCtrl ? -7 : -9;
                    else if (key == GHSpecialKey.Down)
                        resp = isCtrl == isMeta ? -2 : isCtrl ? -1 : -3;
                    else if (key == GHSpecialKey.UpLeft)
                        resp = -7;
                    else if (key == GHSpecialKey.UpRight)
                        resp = -9;
                    else if (key == GHSpecialKey.DownLeft)
                        resp = -1;
                    else if (key == GHSpecialKey.DownRight)
                        resp = -3;
                    else if (key >= GHSpecialKey.NumberPad1 && key <= GHSpecialKey.NumberPad9)
                        resp = -1 - (key - GHSpecialKey.NumberPad1);
                    else if (isMeta && key >= GHSpecialKey.A && key <= GHSpecialKey.Z)
                        resp = GHUtils.Meta((isShift ? (int)'A' : (int)'a') + (int)key - (int)GHSpecialKey.A);

                    if (resp != 0)
                    {
                        if (isShift && resp <= -1 && resp >= -9)
                            GenericButton_Clicked(null, null, -100 - (int)nh_keyfunc.NHKF_RUN);
                        GenericButton_Clicked(null, null, resp);
                        handled = true;
                    }
                }
            }
            return handled;
        }

        private void MoreCommandsFilterEntry_TextChanged(object sender, TextChangedEventArgs e)
        {

        }


        private readonly object _propertyLock = new object();

        private void ToggleAutoDigButton_BtnClicked(object sender, EventArgs e)
        {
            GHApp.PlayMenuSelectSound();
            bool newMode = !MapAutoDig;
            ToggleMapAutoDigOnMainThread(newMode);
            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SetAutoDig, newMode));
        }

        public void ToggleMapAutoDigOnMainThread(bool newMode)
        {
            try
            {
                MainThread.BeginInvokeOnMainThread(() =>
                {
                    MapAutoDig = newMode;
                    if (newMode)
                    {
                        ToggleAutoDigButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-autodig-on.png";
                    }
                    else
                    {
                        ToggleAutoDigButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-autodig-off.png";
                    }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.Message);
            }
        }

        private void ToggleIgnoreModeButton_BtnClicked(object sender, EventArgs e)
        {
            GHApp.PlayMenuSelectSound();
            bool newMode = !MapIgnoreMode;
            ToggleMapIgnoreModeOnMainThread(newMode);
            GHGame curGame = GHApp.CurrentGHGame;
            curGame?.ResponseQueue.Enqueue(new GHResponse(curGame, GHRequestType.SetIgnoreStopping, newMode));
        }

        public void ToggleMapIgnoreModeOnMainThread(bool newMode)
        {
            try
            {
                MainThread.BeginInvokeOnMainThread(() =>
                {
                    MapIgnoreMode = newMode;
                    if (newMode)
                    {
                        ToggleIgnoreModeButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-ignore-on.png";
                    }
                    else
                    {
                        ToggleIgnoreModeButton.ImgSourcePath = "resource://" + GHApp.AppResourceName + ".Assets.UI.stone-ignore-off.png";
                    }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.Message);
            }
        }

        public void StopCanvasAnimations()
        {
            StopMainCanvasAnimation();
            StopCommandCanvasAnimation();
            StopMenuCanvasAnimation();
            StopTextCanvasAnimation();
        }

        public void ShutDownCanvasViews()
        {
            MainCanvasView.ShutDown();
            MenuCanvas.ShutDown();
            TextCanvas.ShutDown();
            CommandCanvas.ShutDown();
        }

        private double _threadSafeWidth = 0;
        private double _threadSafeHeight = 0;
        public double ThreadSafeWidth { get { return Interlocked.CompareExchange(ref _threadSafeWidth, 0.0, 0.0); } private set { Interlocked.Exchange(ref _threadSafeWidth, value); } }
        public double ThreadSafeHeight { get { return Interlocked.CompareExchange(ref _threadSafeHeight, 0.0, 0.0); } private set { Interlocked.Exchange(ref _threadSafeHeight, value); } }

#if WINDOWS
        private void PageContent_CharacterReceived(Microsoft.UI.Xaml.UIElement sender, Microsoft.UI.Xaml.Input.CharacterReceivedRoutedEventArgs args)
        {
            char c = args.Character;
            args.Handled = HandleKeyPress((int)c, GHApp.CtrlDown, GHApp.AltDown);
            //if (LoadingGrid.IsVisible || !GHApp.IsPageOnTopOfModalNavigationStack(this))
            //{
            //    /* Nothing */
            //}
            //else if(YnGrid.IsVisible && !string.IsNullOrWhiteSpace(_ynResponses) && _ynResponses.Contains(args.Character))
            //{
            //    char c = args.Character;
            //    YnButton_Pressed(sender, EventArgs.Empty, (int)c);
            //    args.Handled = true;
            //}
            //else if (MenuGrid.IsVisible)
            //{
            //    char c = args.Character;
            //    if(MenuCanvas.SelectionHow == SelectionMode.Multiple && c == '.')
            //    {
            //        MenuTapGestureRecognizer_Tapped(sender, new TappedEventArgs(new object()));
            //        args.Handled = true;
            //    }
            //    else
            //    {
            //        //SKPoint location = new SKPoint();
            //        bool doclickok = false;
            //        bool somethingFound = false;
            //        lock (MenuCanvas.MenuItemLock)
            //        {
            //            if (MenuCanvas.MenuItems == null)
            //                return;

            //            for (int idx = 0; idx < MenuCanvas.MenuItems.Count; idx++)
            //            {
            //                if (MenuCanvas.MenuItems[idx].Accelerator == c)
            //                {
            //                    somethingFound = true;
            //                    doclickok = ClickMenuItem(idx, false);
            //                    //location = new SKPoint(MenuCanvas.MenuItems[idx].DrawBounds.MidX, MenuCanvas.MenuItems[idx].DrawBounds.MidY);
            //                    break;
            //                }
            //                else if (MenuCanvas.SelectionHow == SelectionMode.Multiple && (MenuCanvas.MenuItems[idx].Flags & (ulong)MenuFlags.MENU_FLAGS_IS_GROUP_HEADING) != 0 && MenuCanvas.MenuItems[idx].HeadingGroupAccelerator == c
            //                    && (_menuCountNumber < 0 || MenuCanvas.MenuItems[idx].HeadingGroupAccelerator < '0' || MenuCanvas.MenuItems[idx].HeadingGroupAccelerator > '9'))
            //                {
            //                    somethingFound = true;
            //                    doclickok = ClickMenuItem(idx, false);
            //                    //location = new SKPoint(MenuCanvas.MenuItems[idx].DrawBounds.MidX, MenuCanvas.MenuItems[idx].DrawBounds.MidY);
            //                    break;
            //                }
            //            }
            //        }
            //        if(somethingFound)
            //        {
            //            _menuCountNumber = -1;
            //            if (MenuOKButton.IsEnabled)
            //            {
            //                if (doclickok)
            //                {
            //                    MenuCanvas.InvalidateSurface();
            //                    MenuOKButton_Clicked(sender, EventArgs.Empty);
            //                }
            //                else
            //                {
            //                    if (MenuCanvas.SelectionHow == SelectionMode.Single)
            //                        MenuOKButton_Clicked(sender, EventArgs.Empty);
            //                }
            //            }
            //            args.Handled = true;
            //        }
            //        else if (c >= '0' && c <= '9' && _menuCountNumber < int.MaxValue / 10 - 10)
            //        {
            //            int res;
            //            if(int.TryParse(c.ToString(), out res))
            //            {
            //                if (_menuCountNumber >= 0)
            //                    _menuCountNumber *= 10;
            //                else
            //                    _menuCountNumber = 0;
            //                _menuCountNumber += res;
            //            }
            //        }

            //        //if (location.X > 0 && location.Y > 0)
            //        //{
            //        //    SKTouchEventArgs e = new SKTouchEventArgs(-1, SKTouchAction.Released, location, false);
            //        //    MenuCanvas_NormalClickRelease(sender, e);
            //        //    if (MenuCanvas.SelectionHow == SelectionMode.Single)
            //        //        MenuOKButton_Clicked(sender, EventArgs.Empty);
            //        //    args.Handled = true;
            //        //}
            //    }
            //}
            //else if (!MenuGrid.IsVisible && !TextGrid.IsVisible && !PopupGrid.IsVisible && !GetLineGrid.IsVisible && !YnGrid.IsVisible)
            //{
            //    if (MoreCommandsGrid.IsVisible)
            //    {
            //        CommandCanvas_Pressed(sender, EventArgs.Empty);
            //    }

            //    char c = args.Character;
            //    if(c != 0)
            //    {
            //        if (GHApp.AltDown)
            //            GenericButton_Clicked(sender, EventArgs.Empty, GHUtils.Meta((int)c));
            //        else if (GHApp.CtrlDown)
            //            GenericButton_Clicked(sender, EventArgs.Empty, GHUtils.Ctrl((int)c));
            //        else
            //            GenericButton_Clicked(sender, EventArgs.Empty, (int)c);

            //        args.Handled = true;
            //    }
            //}
        }

        private void PageContent_KeyDown(object sender, Microsoft.UI.Xaml.Input.KeyRoutedEventArgs e)
        {
            if(HandleKeyDown(sender, e.Key))
                e.Handled = true;
        }

        private bool HandleKeyDown(object sender, VirtualKey key)
        {
            bool handled = false;
            if (key == VirtualKey.LeftControl || key == VirtualKey.RightControl || key == VirtualKey.Control)
            {
                GHApp.CtrlDown = true;
                handled = true;
            }
            else if (key == VirtualKey.LeftMenu || key == VirtualKey.RightMenu || key == VirtualKey.Menu)
            {
                GHApp.AltDown = true;
                handled = true;
            }
            else if (key == VirtualKey.LeftShift || key == VirtualKey.RightShift || key == VirtualKey.Shift)
            {
                GHApp.ShiftDown = true;
                handled = true;
            }
            else
            {
                GHSpecialKey spkey = GHSpecialKey.None;
                switch(key)
                {
                    case VirtualKey.Left:
                        spkey = GHSpecialKey.Left;
                        break;
                    case VirtualKey.Right:
                        spkey = GHSpecialKey.Right;
                        break;
                    case VirtualKey.Up:
                        spkey = GHSpecialKey.Up;
                        break;
                    case VirtualKey.Down:
                        spkey = GHSpecialKey.Down;
                        break;
                    case VirtualKey.PageUp:
                        spkey = GHSpecialKey.PageUp;
                        break;
                    case VirtualKey.PageDown:
                        spkey = GHSpecialKey.PageDown;
                        break;
                    case VirtualKey.Home:
                        spkey = GHSpecialKey.Home;
                        break;
                    case VirtualKey.End:
                        spkey = GHSpecialKey.End;
                        break;
                    case VirtualKey.Escape:
                        spkey = GHSpecialKey.Escape;
                        break;
                    case VirtualKey.Enter:
                        spkey = GHSpecialKey.Enter;
                        break;
                    case VirtualKey.Space:
                        spkey = GHSpecialKey.Space;
                        break;
                    case VirtualKey.Add:
                        spkey = GHSpecialKey.Add;
                        break;
                    case VirtualKey.Subtract:
                        spkey = GHSpecialKey.Subtract;
                        break;
                    case VirtualKey.Decimal:
                        spkey = GHSpecialKey.Decimal;
                        break;
                    default:
                        if (key >= VirtualKey.Number0 && key <= VirtualKey.Number9)
                            spkey = key - VirtualKey.Number0 + GHSpecialKey.Number0;
                        else if (key >= VirtualKey.NumberPad0 && key <= VirtualKey.NumberPad9)
                            spkey = key - VirtualKey.NumberPad0 + GHSpecialKey.NumberPad0;
                        else if (key >= VirtualKey.A && key <= VirtualKey.Z)
                            spkey = key - VirtualKey.A + GHSpecialKey.A;
                        break;
                }
                if(spkey != GHSpecialKey.None)
                    handled = HandleSpecialKeyPress(spkey, GHApp.CtrlDown, GHApp.AltDown, GHApp.ShiftDown);
            }

            //if (LoadingGrid.IsVisible || !GHApp.IsPageOnTopOfModalNavigationStack(this))
            //{
            //    /* Nothing */
            //}
            //else if (MoreCommandsGrid.IsVisible && (key == Windows.System.VirtualKey.Escape || key == Windows.System.VirtualKey.Enter || key == Windows.System.VirtualKey.Space))
            //{
            //    CommandCanvas_Pressed(sender, EventArgs.Empty);
            //    handled = true;
            //}
            //else if (MoreCommandsGrid.IsVisible && (key == Windows.System.VirtualKey.Left || key == Windows.System.VirtualKey.Right))
            //{
            //    int cmdPage = MoreCmdPage;
            //    if (key == Windows.System.VirtualKey.Left)
            //    {
            //        if (cmdPage > (EnableWizardMode ? 0 : 1))
            //        {
            //            MoreCmdPage = cmdPage - 1;
            //            MoreCmdOffsetX = 0;
            //            CommandCanvas.InvalidateSurface();
            //            UpdateMoreNextPrevButtonVisibility(true, true);
            //        }
            //        handled = true;
            //    }
            //    else if (key == Windows.System.VirtualKey.Right)
            //    {
            //        if (cmdPage < CurrentMoreButtonPageMaxNumber - 1)
            //        {
            //            MoreCmdPage = cmdPage + 1;
            //            MoreCmdOffsetX = 0;
            //            CommandCanvas.InvalidateSurface();
            //            UpdateMoreNextPrevButtonVisibility(true, true);
            //        }
            //        handled = true;
            //    }
            //}
            //else if (TextGrid.IsVisible && (key == Windows.System.VirtualKey.Escape || key == Windows.System.VirtualKey.Enter || key == Windows.System.VirtualKey.Space || key == Windows.System.VirtualKey.Up || key == Windows.System.VirtualKey.Down))
            //{
            //    if (key == Windows.System.VirtualKey.Enter || TextGrid.IsVisible && key == Windows.System.VirtualKey.Escape)
            //        TextCanvasPressed(sender, EventArgs.Empty);
            //    else if (key == Windows.System.VirtualKey.Up)
            //        ScrollTextWindow(120);
            //    else if (key == Windows.System.VirtualKey.Down)
            //        ScrollTextWindow(-120);
            //    else if (key == Windows.System.VirtualKey.Space)
            //        ScrollTextWindow(-1200);
            //    handled = true;
            //}
            //else if (MenuGrid.IsVisible && (key == Windows.System.VirtualKey.Escape || (MenuOKButton.IsEnabled && (key == Windows.System.VirtualKey.Enter)) || key == Windows.System.VirtualKey.Up || key == Windows.System.VirtualKey.Down || key == Windows.System.VirtualKey.Space))
            //{
            //    if(key == Windows.System.VirtualKey.Escape)
            //        MenuCancelButton_Clicked(sender, EventArgs.Empty);
            //    else if (MenuOKButton.IsEnabled && (key == Windows.System.VirtualKey.Enter))
            //        MenuOKButton_Clicked(sender, EventArgs.Empty);
            //    else if (key == Windows.System.VirtualKey.Up)
            //        ScrollMenu(120);
            //    else if (key == Windows.System.VirtualKey.Down)
            //        ScrollMenu(-120);
            //    else if (key == Windows.System.VirtualKey.Space)
            //        ScrollMenu(-1200);
            //    handled = true;
            //}
            //else if (GetLineGrid.IsVisible && (key == Windows.System.VirtualKey.Escape))
            //{
            //    GetLineCancelButton_Clicked(sender, EventArgs.Empty);
            //    handled = true;
            //}
            //else if (YnGrid.IsVisible && (key == Windows.System.VirtualKey.Escape))
            //{
            //    YnButton_Pressed(sender, EventArgs.Empty, GHConstants.CancelChar);
            //    handled = true;
            //}
            //else if (PopupGrid.IsVisible && (key == Windows.System.VirtualKey.Escape || key == Windows.System.VirtualKey.Enter || key == Windows.System.VirtualKey.Space))
            //{
            //    PopupOkButton_Clicked(sender, EventArgs.Empty);
            //    handled = true;
            //}
            //else if (!MenuGrid.IsVisible && !PopupGrid.IsVisible && !GetLineGrid.IsVisible && !YnGrid.IsVisible && !TextGrid.IsVisible && !PopupGrid.IsVisible)
            //{
            //    if (MoreCommandsGrid.IsVisible)
            //    {
            //        CommandCanvas_Pressed(sender, EventArgs.Empty);
            //    }

            //    if (GHApp.CtrlDown && key == Windows.System.VirtualKey.Number0)
            //    {
            //        if (ZoomAlternateMode)
            //            MapFontAlternateSize = DefaultMapFontSize * GHConstants.MapFontRelativeAlternateSize;
            //        else if (ZoomMiniMode)
            //            MapFontMiniRelativeSize = 1.0f;
            //        else
            //            MapFontSize = DefaultMapFontSize;
            //        handled = true;
            //    }
            //    else if (GHApp.CtrlDown &&  (key == Windows.System.VirtualKey.Add || key == Windows.System.VirtualKey.Subtract))
            //    {
            //        if (ZoomMiniMode)
            //        {
            //            float canvaswidth = MainCanvasView.CanvasSize.Width;
            //            float canvasheight = MainCanvasView.CanvasSize.Height;
            //            SKPoint point = new SKPoint(canvaswidth / 2, canvasheight / 2);
            //            float ratio = key == Windows.System.VirtualKey.Add ? (1 + (GHApp.AltDown ? 0.001f : 0.01f)) : 1 / (1 + (GHApp.AltDown ? 0.001f : 0.01f));
            //            AdjustZoomByRatio(ratio, point, point, point);
            //        }
            //        else
            //        {
            //            float multiplier = key == Windows.System.VirtualKey.Subtract ? -1.0f : 1.0f;
            //            float newfontsize;
            //            if (ZoomAlternateMode)
            //                newfontsize = MapFontAlternateSize + multiplier * (GHApp.AltDown ? 0.001f : 0.01f) * DefaultMapFontSize;
            //            else
            //                newfontsize = MapFontSize + multiplier * (GHApp.AltDown ? 0.001f : 0.01f) * DefaultMapFontSize;

            //            float canvaswidth = MainCanvasView.CanvasSize.Width;
            //            float canvasheight = MainCanvasView.CanvasSize.Height;
            //            SKPoint point = new SKPoint(canvaswidth / 2, canvasheight / 2);
            //            SetZoomFontSize(newfontsize, point, point, point);
            //        }
            //        MapFontShowPercentageDecimal = GHApp.AltDown;
            //        handled = true;
            //    }
            //    else if (ForceAllMessages)
            //    {
            //        if (key == Windows.System.VirtualKey.Up)
            //            ScrollMessages(120);
            //        else if (key == Windows.System.VirtualKey.Down)
            //            ScrollMessages(-120);
            //        else if (key == Windows.System.VirtualKey.Space)
            //            ScrollMessages(1200);
            //        handled = true;
            //    }
            //    else
            //    {
            //        int resp = 0;
            //        if (key == Windows.System.VirtualKey.Escape)
            //            resp = GHConstants.CancelChar;
            //        else if (key == Windows.System.VirtualKey.Left)
            //            resp = -4;
            //        else if (key == Windows.System.VirtualKey.Right)
            //            resp = -6;
            //        else if (key == Windows.System.VirtualKey.Up)
            //            resp = -8;
            //        else if (key == Windows.System.VirtualKey.Down)
            //            resp = -2;
            //        else if (key >= Windows.System.VirtualKey.NumberPad1 && key <= Windows.System.VirtualKey.NumberPad9)
            //            resp = -1 - (key - Windows.System.VirtualKey.NumberPad1);
            //        else if (GHApp.AltDown && key >= Windows.System.VirtualKey.A && key <= Windows.System.VirtualKey.Z)
            //            resp = GHUtils.Meta((GHApp.ShiftDown ? (int)'A' : (int)'a') + (int)key - (int)Windows.System.VirtualKey.A);

            //        if (resp != 0)
            //        {
            //            if (GHApp.ShiftDown && resp <= -1 && resp >= -9)
            //                GenericButton_Clicked(sender, EventArgs.Empty, -100 - (int)nh_keyfunc.NHKF_RUN);
            //            GenericButton_Clicked(sender, EventArgs.Empty, resp);
            //            handled = true;
            //        }
            //    }
            //}
            return handled;
        }

        private void PageContent_KeyUp(object sender, Microsoft.UI.Xaml.Input.KeyRoutedEventArgs e)
        {
            if (e.Key == VirtualKey.LeftControl || e.Key == VirtualKey.RightControl || e.Key == VirtualKey.Control)
            {
                GHApp.CtrlDown = false;
                e.Handled = true;
            }
            else if (e.Key == VirtualKey.LeftMenu || e.Key == VirtualKey.RightMenu || e.Key == VirtualKey.Menu)
            {
                GHApp.AltDown = false;
                e.Handled = true;
            }
            else if (e.Key == VirtualKey.LeftShift || e.Key == VirtualKey.RightShift || e.Key == VirtualKey.Shift)
            {
                GHApp.ShiftDown = false;
                e.Handled = true;
            }
        }

        private void Content_PreviewKeyDown(object sender, Microsoft.UI.Xaml.Input.KeyRoutedEventArgs e)
        {

        }

        private void Content_PreviewKeyUp(object sender, Microsoft.UI.Xaml.Input.KeyRoutedEventArgs e)
        {

        }
#endif
    }

}